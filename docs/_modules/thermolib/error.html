<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>thermolib.error &mdash; ThermoLIB v1.7.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=131c94de"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ThermoLIB
              <img src="../../_static/logo_thermolib_light.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ig.html">Installation Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ig.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ig.html#download-and-install-thermolib">Download and install ThermoLIB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ig.html#direct-install-using-pip">Direct install using pip</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ig.html#developers-download">Developers download</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ig.html#test-installation">Test installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ug.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ug_1DFEP.html">Constructing 1D histograms &amp; free energy profiles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_1DFEP.html#construct-a-1d-histrogam">Construct a 1D histrogam …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#from-a-single-simulation">… from a single simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#from-multiple-simulations-using-wham">… from multiple simulations using WHAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_1DFEP.html#constructing-a-1d-free-energy-profile">Constructing a 1D free energy profile …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#using-the-constructor">… using the constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#reading-from-a-text-file">… reading from a text file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#from-a-histogram">… from a histogram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_2DFES.html">Constructing 2D histograms &amp; free energy surfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_2DFES.html#constructing-a-2d-histogram">Constructing a 2D histogram …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#from-single-simulation">… from single simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#from-multiple-simulations-using-wham">… from multiple simulations using WHAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_2DFES.html#constructing-a-2d-free-energy-surface">Constructing a 2D free energy surface …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#using-the-constructor">… using the constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#reading-from-a-text-file">… reading from a text file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#from-a-histogram">… from a histogram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_corrtime.html">Computing the correlation time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_corrtime.html#fit-to-autocorrelation-function-for-single-trajectory">Fit to autocorrelation function for single trajectory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_corrtime.html#compute-correlation-time-for-trajectory-series">Compute correlation time for trajectory series</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_error.html">Error estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_error.html#without-correlations">Without correlations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_error.html#with-correlations">With correlations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_plotting.html">Plotting histograms and FEP/FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_plotting.html#d-histograms-free-energy-profile">1D Histograms &amp; free energy profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_plotting.html#d-histograms-free-energy-surfaces">2D Histograms &amp; free energy surfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_micromacro.html">Extracting micro- and macrostate free energy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_kinetics.html">Computing the reaction rate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_transformation.html">Transformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_transformation.html#deterministic-transformation">Deterministic transformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_transformation.html#probabilistic-transformation">Probabilistic transformation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_projection.html">(De)projections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_projection.html#projecting-2d-fes-to-1d-fep">Projecting 2D FES to 1D FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_projection.html#deprojecting-1d-fep-to-2d-fes">Deprojecting 1D FEP to 2D FES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tut/basic_wham1d.html">Tutorial 1 - Construction of 1D free energy profile using WHAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham1d.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham1d.html#WHAM-without-error-estimation">WHAM without error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham1d.html#WHAM-with-error-estimation">WHAM with error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham1d.html#Defining-macrostates-and-microstates">Defining macrostates and microstates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/basic_kinetics.html">Tutorial 2 - Extracting kinetic reaction rates in 1D</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_kinetics.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_kinetics.html#Construct-free-energy-profile">Construct free energy profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_kinetics.html#Compute-rate-prefactor">Compute rate prefactor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_kinetics.html#Add-kinetic-information-to-FEP-plot">Add kinetic information to FEP plot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/basic_wham2d.html">Tutorial 3 - Construction of 2D free energy surface using WHAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham2d.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham2d.html#2D-WHAM-without-error-estimation">2D WHAM without error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham2d.html#2D-WHAM-with-error-estimate">2D WHAM with error estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham2d.html#Alternative-plotting">Alternative plotting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_error_estimation.html">Tutorial 4 - Advanced techniques in error estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Impact-correlation-between-samples-on-FEP">Impact correlation between samples on FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Estimating-the-autocorrelation-time">Estimating the autocorrelation time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Constructing-the-FEP-with-correlated-error-estimate">Constructing the FEP with correlated error estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Evaluating-the-correlated-error-estimate">Evaluating the correlated error estimate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Delayed-strided-WHAM-profiles">Delayed-strided WHAM profiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Blocked-WHAM-profile">Blocked WHAM profile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Bootstrapped-WHAM-profiles">Bootstrapped WHAM profiles</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Covariance-between-different-points-on-FEP">Covariance between different points on FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Error-propagation">Error propagation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_projection.html">Tutorial 5 - Projection of 2D FES to 1D FEP with error propagation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_projection.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_projection.html#Constructing-2D-FES">Constructing 2D FES</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_projection.html#Projection-onto-1D-profile">Projection onto 1D profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_projection.html#Along-predefined-direction">Along predefined direction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_projection.html#Along-any-custom-direction">Along any custom direction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_projection.html#Error-propagation">Error propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_projection.html#Deal-with-the-unsufficiently-sampled-edges-of-phase-space-in-FES-projection">Deal with the unsufficiently sampled edges of phase space in FES projection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_deprojection.html">Tutorial 6 - Deprojecting 1D FEP to 2D FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_deprojection.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_deprojection.html#Construct-1D-FEP">Construct 1D FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_deprojection.html#Deproject-to-2D-FES">Deproject to 2D FES</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#Direct-route---2D-WHAM">Direct route - 2D WHAM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#Indirect-route---deproject-1D-FEP">Indirect route - deproject 1D FEP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#CONSISTENCY-CHECK:-project-2D-FES-to-1D-FEP">CONSISTENCY CHECK: project 2D FES to 1D FEP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_deprojection.html#U(CV)-profile">U(CV) profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#Method-1---from-2D-FES">Method 1 - from 2D FES</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#Method-2---from-conditional-probability">Method 2 - from conditional probability</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#comparison">comparison</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_transformations.html">Tutorial 7 - Transformations of 1D FEP and kinetics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations.html#FEP-and-rate-with-original-CV">FEP and rate with original CV</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations.html#FEP-and-rate-in-terms-of-alternative-CV">FEP and rate in terms of alternative CV</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_transformations_2D.html">Tutorial 8 - Transformation of 2D free energy surfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations_2D.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations_2D.html#Construction-of-original-2D-FES">Construction of original 2D FES</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations_2D.html#Transformation-to-new-CVs">Transformation to new CVs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations_2D.html#Projection-comparison">Projection comparison</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../rg.html">Reference Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../rg_thermo.html">Thermodynamics – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.fep">Free energy profiles – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.fep</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.BaseFreeEnergyProfile"><code class="docutils literal notranslate"><span class="pre">BaseFreeEnergyProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.BaseProfile"><code class="docutils literal notranslate"><span class="pre">BaseProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.FreeEnergySurface2D"><code class="docutils literal notranslate"><span class="pre">FreeEnergySurface2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.SimpleFreeEnergyProfile"><code class="docutils literal notranslate"><span class="pre">SimpleFreeEnergyProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.plot_profiles"><code class="docutils literal notranslate"><span class="pre">plot_profiles()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.histogram">Histograms – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.histogram</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.histogram.Histogram1D"><code class="docutils literal notranslate"><span class="pre">Histogram1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.histogram.Histogram2D"><code class="docutils literal notranslate"><span class="pre">Histogram2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.histogram.plot_histograms"><code class="docutils literal notranslate"><span class="pre">plot_histograms()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.trajectory">Trajectory readers – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.trajectory</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.trajectory.ASEExtendedXYZReader"><code class="docutils literal notranslate"><span class="pre">ASEExtendedXYZReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.trajectory.CVComputer"><code class="docutils literal notranslate"><span class="pre">CVComputer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.trajectory.ColVarReader"><code class="docutils literal notranslate"><span class="pre">ColVarReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.trajectory.HDF5Reader"><code class="docutils literal notranslate"><span class="pre">HDF5Reader</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.bias">Bias potentials – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.bias</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.BiasPotential1D"><code class="docutils literal notranslate"><span class="pre">BiasPotential1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.BiasPotential2D"><code class="docutils literal notranslate"><span class="pre">BiasPotential2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.MultipleBiasses1D"><code class="docutils literal notranslate"><span class="pre">MultipleBiasses1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.Parabola1D"><code class="docutils literal notranslate"><span class="pre">Parabola1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.Parabola2D"><code class="docutils literal notranslate"><span class="pre">Parabola2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.PlumedSplinePotential1D"><code class="docutils literal notranslate"><span class="pre">PlumedSplinePotential1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.Polynomial1D"><code class="docutils literal notranslate"><span class="pre">Polynomial1D</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.cv">Collective variables – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.cv</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.Average"><code class="docutils literal notranslate"><span class="pre">Average</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.CenterOfMass"><code class="docutils literal notranslate"><span class="pre">CenterOfMass</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.CenterOfPosition"><code class="docutils literal notranslate"><span class="pre">CenterOfPosition</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.CoordinationNumber"><code class="docutils literal notranslate"><span class="pre">CoordinationNumber</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.Difference"><code class="docutils literal notranslate"><span class="pre">Difference</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.DistOrthProjOrig"><code class="docutils literal notranslate"><span class="pre">DistOrthProjOrig</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.Distance"><code class="docutils literal notranslate"><span class="pre">Distance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.DistanceCOP"><code class="docutils literal notranslate"><span class="pre">DistanceCOP</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.DotProduct"><code class="docutils literal notranslate"><span class="pre">DotProduct</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.LinearCombination"><code class="docutils literal notranslate"><span class="pre">LinearCombination</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.Minimum"><code class="docutils literal notranslate"><span class="pre">Minimum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.NormalToPlane"><code class="docutils literal notranslate"><span class="pre">NormalToPlane</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.NormalizedAxis"><code class="docutils literal notranslate"><span class="pre">NormalizedAxis</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.OrthogonalDistanceToPore"><code class="docutils literal notranslate"><span class="pre">OrthogonalDistanceToPore</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.state">State – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.state</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.state.Integrate"><code class="docutils literal notranslate"><span class="pre">Integrate</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.state.Maximum"><code class="docutils literal notranslate"><span class="pre">Maximum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.state.Minimum"><code class="docutils literal notranslate"><span class="pre">Minimum</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.condprob">Conditional probability – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.condprob</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D"><code class="docutils literal notranslate"><span class="pre">ConditionalProbability1D1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D"><code class="docutils literal notranslate"><span class="pre">ConditionalProbability1D2D</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rg_kin.html">Kinetics – <code class="docutils literal notranslate"><span class="pre">thermolib.kinetics</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_kin.html#module-thermolib.kinetics.rate">Rate constant – <code class="docutils literal notranslate"><span class="pre">thermolib.kinetics.rate</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_kin.html#thermolib.kinetics.rate.BaseRateFactor"><code class="docutils literal notranslate"><span class="pre">BaseRateFactor</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_kin.html#thermolib.kinetics.rate.RateFactorEquilibrium"><code class="docutils literal notranslate"><span class="pre">RateFactorEquilibrium</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rg_error.html">Error distributions – <code class="docutils literal notranslate"><span class="pre">thermolib.error</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray"><code class="docutils literal notranslate"><span class="pre">ErrorArray</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray.mean"><code class="docutils literal notranslate"><span class="pre">ErrorArray.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">ErrorArray.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray.sample"><code class="docutils literal notranslate"><span class="pre">ErrorArray.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray.std"><code class="docutils literal notranslate"><span class="pre">ErrorArray.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.copy"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.log_from_loggaussian"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.log_from_loggaussian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.mean"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.print"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.print()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.sample"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.set_ref"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.set_ref()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.shift"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.shift()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.std"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.copy"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.exp_from_gaussian"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.exp_from_gaussian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.mean"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.sample"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.set_ref"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.set_ref()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.shift"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.shift()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.std"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiDistribution"><code class="docutils literal notranslate"><span class="pre">MultiDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiDistribution.corr"><code class="docutils literal notranslate"><span class="pre">MultiDistribution.corr()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.copy"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.cov"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.cov()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.log_from_loggaussian"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.log_from_loggaussian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.mean"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.plot_corr_matrix"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.plot_corr_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.sample"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.set_ref"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.set_ref()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.std"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.copy"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.cov"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.cov()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.exp_from_gaussian"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.exp_from_gaussian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.mean"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.plot_corr_matrix"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.plot_corr_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.sample"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.std"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator"><code class="docutils literal notranslate"><span class="pre">Propagator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator.calc_fun_values"><code class="docutils literal notranslate"><span class="pre">Propagator.calc_fun_values()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator.gen_args_samples"><code class="docutils literal notranslate"><span class="pre">Propagator.gen_args_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator.get_distribution"><code class="docutils literal notranslate"><span class="pre">Propagator.get_distribution()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator.reset"><code class="docutils literal notranslate"><span class="pre">Propagator.reset()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution"><code class="docutils literal notranslate"><span class="pre">SampleDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.mean"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.sample"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.set_ref"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.set_ref()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.shift"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.shift()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.std"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.std()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rg_tools.html">Tools – <code class="docutils literal notranslate"><span class="pre">thermolib.tools</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.blav"><code class="docutils literal notranslate"><span class="pre">blav()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.corrtime_from_acf"><code class="docutils literal notranslate"><span class="pre">corrtime_from_acf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.decorrelate"><code class="docutils literal notranslate"><span class="pre">decorrelate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.extract_polynomial_bias_info"><code class="docutils literal notranslate"><span class="pre">extract_polynomial_bias_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.fisher_matrix_mle_probdens"><code class="docutils literal notranslate"><span class="pre">fisher_matrix_mle_probdens()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.format_scientific"><code class="docutils literal notranslate"><span class="pre">format_scientific()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.h5_read_dataset"><code class="docutils literal notranslate"><span class="pre">h5_read_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.integrate"><code class="docutils literal notranslate"><span class="pre">integrate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.integrate2d"><code class="docutils literal notranslate"><span class="pre">integrate2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.interpolate_surface_2d"><code class="docutils literal notranslate"><span class="pre">interpolate_surface_2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.invert_fisher_to_covariance"><code class="docutils literal notranslate"><span class="pre">invert_fisher_to_covariance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.multivariate_normal"><code class="docutils literal notranslate"><span class="pre">multivariate_normal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.read_wham_input"><code class="docutils literal notranslate"><span class="pre">read_wham_input()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.rolling_average"><code class="docutils literal notranslate"><span class="pre">rolling_average()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rg_ext.html">Extensions – <code class="docutils literal notranslate"><span class="pre">thermolib.ext</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham1d_bias"><code class="docutils literal notranslate"><span class="pre">wham1d_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham1d_error"><code class="docutils literal notranslate"><span class="pre">wham1d_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham1d_hs"><code class="docutils literal notranslate"><span class="pre">wham1d_hs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham1d_scf"><code class="docutils literal notranslate"><span class="pre">wham1d_scf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham2d_bias"><code class="docutils literal notranslate"><span class="pre">wham2d_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham2d_error"><code class="docutils literal notranslate"><span class="pre">wham2d_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham2d_hs"><code class="docutils literal notranslate"><span class="pre">wham2d_hs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham2d_scf"><code class="docutils literal notranslate"><span class="pre">wham2d_scf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ThermoLIB</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">thermolib.error</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for thermolib.error</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2019 - 2024 Louis Vanduyfhuys &lt;Louis.Vanduyfhuys@UGent.be&gt;</span>
<span class="c1"># Center for Molecular Modeling (CMM), Ghent University, Ghent, Belgium;</span>
<span class="c1"># all rights reserved unless otherwise stated.</span>
<span class="c1">#</span>
<span class="c1"># This file is part of a library developed by Louis Vanduyfhuys at</span>
<span class="c1"># the Center for Molecular Modeling under supervision of prof. Veronique</span>
<span class="c1"># Van Speybroeck. Usage of this package should be authorized by prof. Van</span>
<span class="c1"># Vanduyfhuys or prof. Van Speybroeck.</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="o">,</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">molmod.units</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pp</span>

<span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">format_scientific</span><span class="p">,</span> <span class="n">multivariate_normal</span>
<span class="kn">from</span> <span class="nn">.flatten</span> <span class="kn">import</span> <span class="n">DummyFlattener</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;SampleDistribution&#39;</span><span class="p">,</span> <span class="s1">&#39;GaussianDistribution&#39;</span><span class="p">,</span> <span class="s1">&#39;LogGaussianDistribution&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;MultiDistribution&#39;</span><span class="p">,</span> <span class="s1">&#39;MultiGaussianDistribution&#39;</span><span class="p">,</span> <span class="s1">&#39;MultiLogGaussianDistribution&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;ErrorArray&#39;</span><span class="p">,</span> <span class="s1">&#39;Propagator&#39;</span>
<span class="p">]</span>


<span class="n">ncycles_default</span> <span class="o">=</span> <span class="mi">50</span>


<span class="k">class</span> <span class="nc">Distribution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Abstract parent class for probability distributions used for error propagation. Most of the routines here are implemented in the child classes.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param shape: the dimensions of the property for which the distribution is stored</span>
<span class="sd">            :type shape: list of integers</span>

<span class="sd">            :param flattener: Only required for properties represented by nD-arrays with n&gt;=2. The flattener encodes how to flatten these multidimensional properties stored in nD-arrays into a longer 1D-array for easiear error propagation. This flattener also allows to do the inverse transformation, i.e. deflatten the flattened 1D-array back to its original nD-array format.</span>
<span class="sd">            :type flattener: :py:class:`Flattener &lt;thermolib.flatten.Flattener&gt;`, optional, default=None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span> <span class="o">=</span> <span class="n">flattener</span>

    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">nsigma_conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsigma</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_samples</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
    <span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">do_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine to print the statistical properties of a scalar quantity.</span>

<span class="sd">            :param fmt: python string formatting for how to format floats (such as the mean and error). This argument is ignored if ``do_scientific`` is set tot True.</span>
<span class="sd">            :type fmt: str, optional, default=&#39;%.3f&#39;</span>

<span class="sd">            :param unit: unit in which to print the current quantity.</span>
<span class="sd">            :type unit: str, optional, default=&#39;au&#39;</span>

<span class="sd">            :param do_scientific: use scientific formatting of floats</span>
<span class="sd">            :type do_scientific: bool, optional, default=False</span>

<span class="sd">            :param nsigma: print error bars as :math:`n\\sigma` error bars. Hence, setting ``nsigma=2`` will return error bars that are twice the standard deviation resulting from the error distribution.</span>
<span class="sd">            :type nsigma: int, optional, default=2</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t print information for multiple statistical variables&quot;</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="n">nsigma</span><span class="p">)</span>
        <span class="n">lower</span> <span class="o">/=</span> <span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">/=</span> <span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_scientific</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">format_scientific</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">format_scientific</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">format_scientific</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">lower</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">upper</span>
            <span class="n">mean</span>  <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">mean</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> &lt;= </span><span class="si">%s</span><span class="s1"> &lt;= </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>


<div class="viewcode-block" id="SampleDistribution"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.SampleDistribution">[docs]</a><span class="k">class</span> <span class="nc">SampleDistribution</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Define the distribution by explicitly supplying it with a population of samples. All statistical properties will be derived from this population.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param samples: the samples that define the population</span>
<span class="sd">            :type samples: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">Distribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="SampleDistribution.shift"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.SampleDistribution.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Shift all samples in the population with the given ref.</span>

<span class="sd">            :param ref: reference with which each sample will be shifted</span>
<span class="sd">            :type ref: type consistent with a sample from the population</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples</span> <span class="o">+=</span> <span class="n">ref</span></div>
    
<div class="viewcode-block" id="SampleDistribution.set_ref"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.SampleDistribution.set_ref">[docs]</a>    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Set reference of population samples by shifting all population samples over an amount equal to -value.</span>

<span class="sd">            :param index: invalid keyword for SampleDistribution. Only valid value is None.</span>

<span class="sd">            :param value: old population value that will become new reference (i.e. become zero)</span>
<span class="sd">            :type value: type consistent with population samples, optional, default=None</span>

<span class="sd">            :raises AssertionError: if index is not None</span>
<span class="sd">            :raises AssertionError: if value is None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;SampleDistribution.set_ref can only be called with value keyword&#39;</span>
        <span class="k">assert</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;SampleDistribution.set_ref can only be called with value keyword&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="SampleDistribution.from_samples"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.SampleDistribution.from_samples">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_samples</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Defines the current SampleDistribution based on a population defined by the given samples. A trivial routine for the current class, but implemented for completeness of Distribution parent class.</span>

<span class="sd">            :param samples: the samples that define the population</span>
<span class="sd">            :type samples: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SampleDistribution.mean"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.SampleDistribution.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution mean</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">samples_ma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples_ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SampleDistribution.std"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.SampleDistribution.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution standard deviation</span>

<span class="sd">            :return: standard deviation of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">samples_ma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples_ma</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SampleDistribution.sample"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.SampleDistribution.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Returns a random sample from the population given at initialization</span>

<span class="sd">            :return: a random sample from the population</span>
<span class="sd">            :rtype: np.ndarray or float</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_integers</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span></div></div>


<div class="viewcode-block" id="GaussianDistribution"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution">[docs]</a><span class="k">class</span> <span class="nc">GaussianDistribution</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Implementation of a Gaussian distribution defined by its mean and standard deviation.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">stds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param means: mean (or means if multidimensional) of the Gaussian distribution</span>
<span class="sd">            :type means: int, float or np.ndarray</span>
<span class="sd">            </span>
<span class="sd">            :param stds: standard deviation (or standard deviations if multidimensional) of the Gaussian distribution</span>
<span class="sd">            :type stds: int, float or np.ndarray</span>
<span class="sd">            </span>
<span class="sd">            :raises ValueError: if means is not an integer, float or np.ndarray</span>
<span class="sd">            :raises AssertionError: if means and stds do not have same shape</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">means</span><span class="p">)</span><span class="o">==</span><span class="nb">type</span><span class="p">(</span><span class="n">stds</span><span class="p">),</span> <span class="s1">&#39;Means and stds in GaussianDistribution should be of same type. Got </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">means</span><span class="p">)),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">stds</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stds</span> <span class="o">=</span> <span class="n">stds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">assert</span> <span class="n">stds</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;Means and stds in GaussianDistribution should be of same shape&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">=</span> <span class="n">means</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stds</span> <span class="o">=</span> <span class="n">stds</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Means in GaussianDistribution should be int, float or np.ndarray, got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">means</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">Distribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="GaussianDistribution.copy"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return a hard copy of the Gaussian distribution</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">GaussianDistribution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="GaussianDistribution.shift"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Shift the distribution means with the given ref.</span>

<span class="sd">            :param ref: reference with which means will be shifted</span>
<span class="sd">            :type ref: type consistent with means</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">+=</span> <span class="n">ref</span></div>
    
<div class="viewcode-block" id="GaussianDistribution.set_ref"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.set_ref">[docs]</a>    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Set reference of distribution means by shifting them over an amount equal to -value or -self.means[index].</span>

<span class="sd">            :param index: shift distribution means over an amount equal -self.means[index]. Ignored if set to None.</span>
<span class="sd">            :type index: int, optional, default=None</span>

<span class="sd">            :param value: shift distribution means over an amount equal to -value. Ignored if index is not None.</span>
<span class="sd">            :type value: type consistent with population samples, optional, default=None</span>

<span class="sd">            :raises ValueError: if both index and value are set to None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In GaussianDistribution.set_ref either index or value keyword argument should be defined&#39;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="GaussianDistribution.sample"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Returns a number of random samples from the population defined by the Gaussian distribution</span>

<span class="sd">            :param nsamples: the number of samples returned. If None, a single sample will be returned and the shape of the return value will be identical to self.means and self.stds. If not None, the return value will have an additional dimension with size given by nsamples.</span>
<span class="sd">            :type nsamples: int or None, optional, default=None</span>

<span class="sd">            :return: a (set of) random sample(s) from the population</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="GaussianDistribution.mean"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution mean</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span></div>
    
<div class="viewcode-block" id="GaussianDistribution.std"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution standard deviation</span>

<span class="sd">            :return: standard deviation of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stds</span></div>

<div class="viewcode-block" id="GaussianDistribution.nsigma_conf_int"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.nsigma_conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">nsigma_conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsigma</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute the n-sigma confidence interval, i.e. :math:`\\mu \\pm n\\cdot\\sigma`</span>
<span class="sd">        </span>
<span class="sd">            :param nsigma: value of n in the above formula</span>
<span class="sd">            :type nsigma: int, optional, default=2</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-</span> <span class="n">nsigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">+</span> <span class="n">nsigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span>
        <span class="k">return</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span></div>
    
<div class="viewcode-block" id="GaussianDistribution.from_samples"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.from_samples">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_samples</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Defines a GaussianDistribution based on a population defined by the given samples. The routine will derive the mean and std from the population and use that to define the Gaussian Distribution.</span>

<span class="sd">            :param samples: the samples that define the population</span>
<span class="sd">            :type samples: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">samples_ma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">samples_ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">stds</span> <span class="o">=</span> <span class="n">samples_ma</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">stds</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="GaussianDistribution.log_from_loggaussian"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.log_from_loggaussian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">log_from_loggaussian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">logdist</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Define the Gaussian distribution of a variable :math:`Y=log(X)` in which :math:`X` has a given LogGaussian distribution, potential after imposing a shift and rescaling.</span>

<span class="sd">            :param logdist: the LogGaussian distribution of variable X in the expression above.</span>
<span class="sd">            :type logdist: :py:class:`LogGaussianDistribution &lt;thermolib.error.LogGaussianDistribution&gt;`</span>

<span class="sd">            :param shift: shift to be applied to the mean upon conversion</span>
<span class="sd">            :type shift: float, optional, default=0.0</span>

<span class="sd">            :param scale: rescaling to be applied to the mean and std upon conversion</span>
<span class="sd">            :type scale: float, optional, default=1.0</span>

<span class="sd">            :raises AssertionError: if the given logdist is not an instance of :py:class:`LogGaussianDistribution &lt;thermolib.error.LogGaussianDistribution&gt;`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">logdist</span><span class="p">,</span> <span class="n">LogGaussianDistribution</span><span class="p">),</span> <span class="s1">&#39;Can only make Gaussian distribution from logarithm of LogGaussianDistribution&#39;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">scale</span><span class="o">*</span><span class="n">logdist</span><span class="o">.</span><span class="n">lmeans</span><span class="o">+</span><span class="n">shift</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">*</span><span class="n">logdist</span><span class="o">.</span><span class="n">lstds</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="GaussianDistribution.print"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.GaussianDistribution.print">[docs]</a>    <span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">do_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine to print the statistical properties of a scalar quantity.</span>

<span class="sd">            :param fmt: python string formatting for how to format floats (such as the mean and error). This argument is ignored if ``do_scientific`` is set tot True.</span>
<span class="sd">            :type fmt: str, optional, default=&#39;%.3f&#39;</span>

<span class="sd">            :param unit: unit in which to print the current quantity.</span>
<span class="sd">            :type unit: str, optional, default=&#39;au&#39;</span>

<span class="sd">            :param do_scientific: use scientific formatting of floats</span>
<span class="sd">            :type do_scientific: bool, optional, default=False</span>

<span class="sd">            :param nsigma: print error bars as :math:`n\\sigma` error bars. Hence, setting ``nsigma=2`` will return error bars that are twice the standard deviation resulting from the error distribution.</span>
<span class="sd">            :type nsigma: int, optional, default=2</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="n">nsigma</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper</span><span class="o">-</span><span class="n">lower</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">error</span> <span class="o">/=</span> <span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_scientific</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">format_scientific</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">format_scientific</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">error</span>
            <span class="n">mean</span>  <span class="o">=</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">mean</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> +- </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LogGaussianDistribution"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution">[docs]</a><span class="k">class</span> <span class="nc">LogGaussianDistribution</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Implementation of a Log-Gaussian distribution, i.e. variable X is Log-Gaussian with mean lmu and std lsigma if variable log(X) is Gaussian distributed with mean lmu and std lsigma.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lmeans</span><span class="p">,</span> <span class="n">lstds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param lmeans: mean (or means if multidimensional) of the corresponding Gaussian distribution of log(X)</span>
<span class="sd">            :type means: int, float or np.ndarray</span>
<span class="sd">            </span>
<span class="sd">            :param lstds: standard deviation (or standard deviations if multidimensional) of the corresponding Gaussian distribution of log(X)</span>
<span class="sd">            :type stds: int, float or np.ndarray</span>
<span class="sd">            </span>
<span class="sd">            :raises ValueError: if lmeans is not an integer, float or np.ndarray</span>
<span class="sd">            :raises AssertionError: if lmeans and lstds do not have same shape</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lmeans</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">=</span> <span class="n">lmeans</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">=</span> <span class="n">lmeans</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lstds</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lstds</span> <span class="o">=</span> <span class="n">lstds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lstds</span> <span class="o">=</span> <span class="n">lstds</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">lmeans</span><span class="p">)</span><span class="o">==</span><span class="nb">type</span><span class="p">(</span><span class="n">lstds</span><span class="p">),</span> <span class="s1">&#39;lmeans and lstds in GaussianDistribution should be of same type&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lmeans</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">assert</span> <span class="n">lstds</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;lmeans and stds in GaussianDistribution should be of same length&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lmeans</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lmeans</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;lmeans should be int, float or np.ndarray, got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lmeans</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">Distribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="LogGaussianDistribution.shift"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.shift">[docs]</a>    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Shift the distribution lmeans (NOT THE DISTRIBUTION MEAN!!) with the given ref.</span>

<span class="sd">            :param ref: reference with which lmeans will be shifted</span>
<span class="sd">            :type ref: type consistent with lmeans</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">+=</span> <span class="n">ref</span></div>

<div class="viewcode-block" id="LogGaussianDistribution.set_ref"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.set_ref">[docs]</a>    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Set reference of distribution lmeans (NOT THE DISTRIBUTION MEANS!!) by shifting them over an amount equal to -value or -self.lmeans[index].</span>

<span class="sd">            :param index: shift distribution lmeans over an amount equal -self.lmeans[index]. Ignored if set to None.</span>
<span class="sd">            :type index: int, optional, default=None</span>

<span class="sd">            :param value: shift distribution lmeans over an amount equal to -value. Ignored if index is not None.</span>
<span class="sd">            :type value: type consistent with population samples, optional, default=None</span>

<span class="sd">            :raises ValueError: if both index and value are set to None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">-=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In LogGaussianDistribution.set_ref either index or value keyword argument should be defined&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LogGaussianDistribution.mean"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution mean</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="LogGaussianDistribution.std"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution standard deviation</span>

<span class="sd">            :return: standard deviation of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>

<div class="viewcode-block" id="LogGaussianDistribution.copy"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return a hard copy of the LogGaussian distribution</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">LogGaussianDistribution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="LogGaussianDistribution.sample"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Returns a number of random samples from the population defined by the distribution</span>

<span class="sd">            :param nsamples: the number of samples returned. If None, a single sample will be returned and the shape of the return value will be identical to self.means and self.stds. If not None, the return value will have an additional dimension with size given by nsamples.</span>
<span class="sd">            :type nsamples: int or None, optional, default=None</span>

<span class="sd">            :return: a (set of) random sample(s) from the population</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span></div>
    
<div class="viewcode-block" id="LogGaussianDistribution.nsigma_conf_int"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.nsigma_conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">nsigma_conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsigma</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute the n-sigma confidence interval, i.e. :math:`\\exp\\left(\\mu \\pm n\\cdot\\sigma\\right)`</span>
<span class="sd">        </span>
<span class="sd">            :param nsigma: value of n in the above formula</span>
<span class="sd">            :type nsigma: int, optional, default=2</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">-</span> <span class="n">nsigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">+</span> <span class="n">nsigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lower</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="LogGaussianDistribution.from_samples"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.from_samples">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_samples</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Defines a LogGaussianDistribution based on a population defined by the given samples. The routine will derive lmean and lstd from the log of the given population samples and use that to define the LogGaussian Distribution.</span>

<span class="sd">            :param samples: the samples that define the population</span>
<span class="sd">            :type samples: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lsamples</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span>
        <span class="n">lmeans</span> <span class="o">=</span> <span class="n">lsamples</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lstds</span> <span class="o">=</span> <span class="n">lsamples</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">lmeans</span><span class="p">,</span> <span class="n">lstds</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="LogGaussianDistribution.exp_from_gaussian"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.exp_from_gaussian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">exp_from_gaussian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">gaussdist</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Define the LogGaussian distribution of a variable :math:`Y=exp(X)` in which :math:`X` has a given Gaussian distribution, potential after imposing a shift and rescaling.</span>

<span class="sd">            :param gaussdist: the Gaussian distribution of variable X in the expression above.</span>
<span class="sd">            :type gaussdist: :py:class:`GaussianDistribution &lt;thermolib.error.GaussianDistribution&gt;`</span>

<span class="sd">            :param shift: shift to be applied to the mean upon conversion</span>
<span class="sd">            :type shift: float, optional, default=0.0</span>

<span class="sd">            :param scale: rescaling to be applied to the mean and std upon conversion</span>
<span class="sd">            :type scale: float, optional, default=1.0</span>

<span class="sd">            :raises AssertionError: if the given gaussdist is not an instance of :py:class:`GaussianDistribution &lt;thermolib.error.GaussianDistribution&gt;`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gaussdist</span><span class="p">,</span> <span class="n">GaussianDistribution</span><span class="p">),</span> <span class="s1">&#39;Can only make LogGaussian distribution from exponent of GaussianDistribution&#39;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">scale</span><span class="o">*</span><span class="n">gaussdist</span><span class="o">.</span><span class="n">means</span><span class="o">+</span><span class="n">shift</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">*</span><span class="n">gaussdist</span><span class="o">.</span><span class="n">stds</span><span class="p">)</span></div></div>
    

<span class="k">class</span> <span class="nc">FunctionDistribution</span><span class="p">(</span><span class="n">Distribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Class to implement the distribution of a variable Y=f(X) with a known distribution for X</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param fun: function defining variable Y in the expression above.</span>
<span class="sd">            :type fun: callable</span>

<span class="sd">            :param dist: the distribution of variable X in the expression above.</span>
<span class="sd">            :type dist: instance of child of :py:class:`Distribution &lt;thermolib.error.Distribution&gt;`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fun</span> <span class="o">=</span> <span class="n">fun</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span>
        <span class="n">Distribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1">#def crop(self, indexes):</span>
    <span class="c1">#    &#39;&#39;&#39;</span>
    <span class="c1">#        Routine only applicable if self.dist is an instance of :py:class:`ErrorArray &lt;thermolib.error.ErrorArray&gt;`. Will crop the array of errors to the given indices.</span>
    <span class="c1">#</span>
    <span class="c1">#        :param indexes: indices to which the error array needs to be cropped</span>
    <span class="c1">#        :type indexes: list, tuple, np.ndarray of integers</span>
    <span class="c1">#    &#39;&#39;&#39;</span>
    <span class="c1">#    assert isinstance(self, ErrorArray)</span>
    <span class="c1">#    self.dist.crop(indexes)</span>
    
    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution mean through numerical estimation</span>

<span class="sd">            :param nsamples: number of samples used for numerical estimation</span>
<span class="sd">            :type nsamples: int, optional, default=50</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">sample</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)])</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution standard deviation through numerical estimation</span>
<span class="sd">            </span>
<span class="sd">            :param nsamples: number of samples used for numerical estimation</span>
<span class="sd">            :type nsamples: int, optional, default=50</span>

<span class="sd">            :return: standard deviation of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">sample</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">)])</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Returns a number of random samples from the population defined by the distribution</span>

<span class="sd">            :param nsamples: the number of samples returned. If None, a single sample will be returned and the shape of the return value will be identical to self.means and self.stds. If not None, the return value will have an additional dimension with size given by nsamples.</span>
<span class="sd">            :type nsamples: int or None, optional, default=None</span>

<span class="sd">            :return: a (set of) random sample(s) from the population</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">nsigma_conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsigma</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute the n-sigma confidence interval, i.e. :math:`[f(l),f(u)]` with ``l,u=self.dist.nsigma_conf_int(nsigma)``</span>
<span class="sd">        </span>
<span class="sd">            :param nsigma: value of n in the above formula</span>
<span class="sd">            :type nsigma: int, optional, default=2</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="n">nsigma</span><span class="p">)</span>
        <span class="n">fun_lower</span><span class="p">,</span> <span class="n">fun_upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fun</span><span class="p">(</span><span class="n">lower</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fun</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fun_lower</span><span class="o">&lt;=</span><span class="n">fun_upper</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fun_lower</span><span class="p">,</span> <span class="n">fun_upper</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fun_upper</span><span class="p">,</span> <span class="n">fun_lower</span>


<div class="viewcode-block" id="MultiDistribution"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiDistribution">[docs]</a><span class="k">class</span> <span class="nc">MultiDistribution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Abstract parent class for probability distributions of multidimensional stochastic properties used for error propagation. This class will explicitly account for correlation across the dimensions, as such it can be used to account for the correlation between the free energy at two different points in a FEP. Most of the routines here are implemented in the child classes.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">DummyFlattener</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param shape: the dimensions of the property for which the distribution is stored</span>
<span class="sd">            :type shape: list of integers</span>

<span class="sd">            :param flattener: The flattener encodes how to flatten the multidimensional properties stored in nD-arrays into a longer 1D-array for easiear error propagation. This flattener also allows to do the inverse transformation, i.e. deflatten the flattened 1D-array back to its original nD-array format.</span>
<span class="sd">            :type flattener: :py:class:`Flattener &lt;thermolib.flatten.Flattener&gt;`, optional, default=None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span> <span class="o">=</span> <span class="n">flattener</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">nsigma_conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="MultiDistribution.corr"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiDistribution.corr">[docs]</a>    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine that will convert the covariance matrix computed with self.cov to a correlation matrix according to the formula</span>

<span class="sd">            .. math:: </span>

<span class="sd">                Cor[i,j] &amp;= \\frac{Cov[i,j]}{\\sigma_i \\sigma_j}</span>
<span class="sd">            </span>
<span class="sd">            in which :math:`\\sigma_i` is the standard deviation of the i-th quantity in the multidimensional stochastic property.</span>

<span class="sd">            :param unflatten: If True, return the correlation matrix in a shape equal to &#39;the square&#39; of in the original dimensional shape. If False, return the correlation matrix as a flattened 2D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#get flattened correlation matrix</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">stdi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">std</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">stdj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">std</span><span class="p">):</span>
                <span class="n">corr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span><span class="n">stdi</span><span class="o">*</span><span class="n">stdj</span><span class="p">)</span>
        <span class="c1">#possibly deflatten the correlation matrix before returning it</span>
        <span class="k">if</span> <span class="n">unflatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">corr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
    
    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">from_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">DummyFlattener</span><span class="p">(),</span> <span class="n">flattened</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="MultiGaussianDistribution"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution">[docs]</a><span class="k">class</span> <span class="nc">MultiGaussianDistribution</span><span class="p">(</span><span class="n">MultiDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Implementation of a multivariate normal distribution for a given vector of means and a given covariance matrix</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">means</span><span class="p">,</span> <span class="n">covariance</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">DummyFlattener</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param means: means of the multivariate normal distribution</span>
<span class="sd">            :type means: np.ndarray</span>

<span class="sd">            :param covariance: covariance matrix of the multivariate normal distribution</span>
<span class="sd">            :type covariance: np.ndarray with a dimension equal tot the square of means, i.e. if means.shape=(N,) then covariance.shape=(N,N) and if means.shape=(K,L) then covariance.shape=(K,L,K,L).</span>

<span class="sd">            :param flattener: The flattener encodes how to flatten the multidimensional properties stored in nD-arrays into a longer 1D-array for easiear error propagation. This flattener also allows to do the inverse transformation, i.e. deflatten the flattened 1D-array back to its original nD-array format. Should be specified if len(means.shape)=1 because it represents a flattened 2D array (which also implies len(covariance.shape)=2 because it represents a flattened 4D array).</span>
<span class="sd">            :type flattener: :py:class:`Flattener &lt;thermolib.flatten.Flattener&gt;`, optional, default=DummyFlattener() indicating no flattening</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;means should be array, detected </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">means</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covariance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;covariance matrix should be array, detected </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">covariance</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;means should be 1D array, but detected array shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">covariance</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;covariance matrix should be 2D array, but detected array shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">covariance</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">covariance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Inconsistent shapes, means has shape </span><span class="si">%s</span><span class="s1"> while covariance has shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">covariance</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">covariance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Inconsistent shapes, means has shape </span><span class="si">%s</span><span class="s1"> while covariance has shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">covariance</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">=</span> <span class="n">means</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="n">covariance</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">covariance</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="n">MultiDistribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">means</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">)</span>

<div class="viewcode-block" id="MultiGaussianDistribution.copy"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return a hard copy of the MultiGaussian distribution</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">MultiGaussianDistribution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiGaussianDistribution.mean"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution mean</span>

<span class="sd">            :param unflatten: If True, return the distribution mean in the original dimensional shape. If False, return the distribution mean as a flattened 1D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">unflatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="MultiGaussianDistribution.std"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution standard deviation (std)</span>

<span class="sd">            :param unflatten: If True, return the distribution std in the original dimensional shape. If False, return the distribution std as a flattened 1D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>

<span class="sd">            :return: standard deviation of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">unflatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="MultiGaussianDistribution.cov"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.cov">[docs]</a>    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the covariance matrix of the MultiGaussian distribution.</span>

<span class="sd">            :param unflatten: If True, return the covariance matrix in a shape equal to &#39;the square&#39; of in the original dimensional shape. If False, return the covariance matrix as a flattened 2D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">unflatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="MultiGaussianDistribution.sample"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Returns a number of random samples from the population defined by the distribution</span>

<span class="sd">            :param nsamples: the number of samples returned. If None, a single sample will be returned with a shape depending on whether or not it is flattened (see parameter unflatten). If not None, the return value will have an additional dimension with size given by nsamples.</span>
<span class="sd">            :type nsamples: int or None, optional, default=None</span>

<span class="sd">            :param unflatten: If True, return each distribution sample in the original dimensional shape. If False, return each sample as a flattened 1D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>

<span class="sd">            :return: a (set of) random sample(s) from the population</span>
<span class="sd">            :rtype: np.ndarray whose dimension depend on the nsamples and unflatten keyword values. If nsamples is None, a single sample is returned whose shape depends on whether or not it is flattened (see parameter unflatten). If nsamples is not None, the return value will have an additinal dimension with size given by nsamples.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">samples_flattened</span> <span class="o">=</span> <span class="n">multivariate_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">if</span> <span class="n">unflatten</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="p">,</span> <span class="n">DummyFlattener</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">samples_unflattened</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">dim1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">dim2</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">isample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">):</span>
                    <span class="n">samples_unflattened</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">isample</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="n">samples_flattened</span><span class="p">[:,</span><span class="n">isample</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples_unflattened</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="n">samples_flattened</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">samples_unflattened</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samples_flattened</span></div>
    
<div class="viewcode-block" id="MultiGaussianDistribution.nsigma_conf_int"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.nsigma_conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">nsigma_conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsigma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute the n-sigma confidence interval, i.e. :math:`\\mu \\pm n\\cdot\\sigma`</span>
<span class="sd">        </span>
<span class="sd">            :param nsigma: value of n in the above formula</span>
<span class="sd">            :type nsigma: int, optional, default=2</span>

<span class="sd">            :param unflatten: If True, return the interval in the original dimensional shape. If False, return as a flattened 1D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="n">unflatten</span><span class="p">)</span> <span class="o">-</span> <span class="n">nsigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="n">unflatten</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="n">unflatten</span><span class="p">)</span> <span class="o">+</span> <span class="n">nsigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="n">unflatten</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span></div>

<div class="viewcode-block" id="MultiGaussianDistribution.set_ref"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.set_ref">[docs]</a>    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Set reference of distribution means by shifting them over an amount equal to -value or -self.means[index].</span>

<span class="sd">            :param index: shift distribution means over an amount equal -self.means[index]. Ignored if set to None.</span>
<span class="sd">            :type index: tuple|list, optional, default=None</span>

<span class="sd">            :param value: shift distribution means over an amount equal to -value. Ignored if index is not None.</span>
<span class="sd">            :type value: type consistent with population samples, optional, default=None</span>

<span class="sd">            :raises ValueError: if both index and value are set to None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">flatten_index</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">-=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In MultiGaussianDistribution.set_ref either index or value keyword argument should be defined&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiGaussianDistribution.from_samples"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.from_samples">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_samples</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">DummyFlattener</span><span class="p">(),</span> <span class="n">flattened</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">            Defines a MultiGaussianDistribution based on a population defined by the given samples. The routine will derive the mean and std from the population and use that to define the Gaussian Distribution.</span>

<span class="sd">            :param samples: the samples that define the population</span>
<span class="sd">            :type samples: np.ndarray</span>

<span class="sd">            :param flattened: </span>
<span class="sd">                </span>
<span class="sd">                - If flattened is True, the given samples should be a 2D array in which a row represents all observations of a single variable and a column represents a single observation of all variables.</span>
<span class="sd">                - If flattened is False, then the the samples array is assumed to be 3 dimensional for which the first two dimensions represent a 2D index and the third index is the sample index. Therefore, the flattener will first be applied to flatten the 2D index into a 1D index and hence convert the samples to a 2D array of the same shape as required if the flattened argument is True.</span>
<span class="sd">            </span>
<span class="sd">            :type flattened: bool, optional, default=False</span>

<span class="sd">            :raises AssertionError: if the dimensions of samples array are invalid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">flattened</span><span class="p">:</span>
            <span class="n">samples_unflattened</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">flattener</span><span class="o">.</span><span class="n">dim12</span><span class="p">,</span> <span class="n">samples_unflattened</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">isample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples_unflattened</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">samples</span><span class="p">[:,</span><span class="n">isample</span><span class="p">]</span> <span class="o">=</span> <span class="n">flattener</span><span class="o">.</span><span class="n">flatten_array</span><span class="p">(</span><span class="n">samples_unflattened</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">isample</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Samples should be a 2 dimensional array, got an array with </span><span class="si">%i</span><span class="s1"> dimensions&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="c1">#mask invalid samples</span>
        <span class="n">samples_ma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="c1">#compute means</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">samples_ma</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1">#compute covariance matrix (and fill rows/columns comming from invalid samples with np.nan)</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">samples_ma</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">flattener</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiGaussianDistribution.log_from_loggaussian"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.log_from_loggaussian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">log_from_loggaussian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">logdist</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Define the MultiGaussian distribution of a variable :math:`Y=log(X)` in which :math:`X` has a given MultiLogGaussian distribution, potential after imposing a shift and rescaling.</span>

<span class="sd">            :param logdist: the MultiLogGaussian distribution of variable X in the expression above.</span>
<span class="sd">            :type logdist: :py:class:`MultiLogGaussianDistribution &lt;thermolib.error.MultiLogGaussianDistribution&gt;`</span>

<span class="sd">            :param shift: shift to be applied to the mean upon conversion</span>
<span class="sd">            :type shift: float, optional, default=0.0</span>

<span class="sd">            :param scale: rescaling to be applied to the mean and std upon conversion</span>
<span class="sd">            :type scale: float, optional, default=1.0</span>

<span class="sd">            :raises AssertionError: if logdist is not instance of :py:class:`MultiLogGaussianDistribution &lt;thermolib.error.MultiLogGaussianDistribution&gt;`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">logdist</span><span class="p">,</span> <span class="n">MultiLogGaussianDistribution</span><span class="p">),</span> <span class="s1">&#39;Can only make multivariate Gaussian distribution from logarithm of Multivariate LogGaussianDistribution&#39;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">scale</span><span class="o">*</span><span class="n">logdist</span><span class="o">.</span><span class="n">lmeans</span><span class="o">+</span><span class="n">shift</span><span class="p">,</span> <span class="p">(</span><span class="n">scale</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">logdist</span><span class="o">.</span><span class="n">lcovariance</span><span class="p">,</span> <span class="n">logdist</span><span class="o">.</span><span class="n">flattener</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiGaussianDistribution.plot_corr_matrix"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.plot_corr_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">plot_corr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_size_inches</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span><span class="p">,</span> <span class="n">logscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cvs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nticks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            gMake a plot of the correlation matrix of the current multivariate Gaussian distribution</span>

<span class="sd">            :param fn: file name to which figure will be saved. If None, figure will note be written to file.</span>
<span class="sd">            :type fn: _type_, optional, default=None</span>

<span class="sd">            :param fig_size_inches: [x,y]-dimensions of the figure in inches</span>
<span class="sd">            :type fig_size_inches: list, optional, default=[8,8]</span>

<span class="sd">            :param cmap: color map to be used, see `matplotlib documentation &lt;https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html&gt;`_ to see possibilities.</span>
<span class="sd">            :type cmap: str, optional, default=&#39;bwr&#39;</span>

<span class="sd">            :param logscale: plot correlation in logarithmic scale</span>
<span class="sd">            :type logscale: bool, optional, default=False</span>

<span class="sd">            :param cvs: set x and y-tick labels to CV values given in cvs</span>
<span class="sd">            :type cvs: np.ndarray, optional, default=None</span>

<span class="sd">            :param nticks: number of ticks on x and y-axis. Only used when parameter cvs is given.</span>
<span class="sd">            :type nticks: int, optional, default=10</span>

<span class="sd">            :param decimals: number of decimals to be shown in CV tick labels. Only used when parameter cvs is given.</span>
<span class="sd">            :type decimals: int, optional, default=1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">logscale</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">special_log</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">100</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">100.0</span>
                <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="o">&lt;-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">100</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">100.0</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span><span class="o">&lt;</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">special_log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cvs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#set xtick and yticks positions and labels to CV values</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="n">nticks</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">delta</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">cv</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">decimals</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">decimals</span> <span class="k">for</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">cvs</span><span class="p">[</span><span class="n">positions</span><span class="p">]])</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="n">fig_size_inches</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="MultiLogGaussianDistribution"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution">[docs]</a><span class="k">class</span> <span class="nc">MultiLogGaussianDistribution</span><span class="p">(</span><span class="n">MultiDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Implementation of a multivariate log-normal distribution for a given vector of means and a given covariance matrix</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lmeans</span><span class="p">,</span> <span class="n">lcovariance</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">DummyFlattener</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param means: lmeans of the multivariate log-normal distribution, i.e. means of the underlying normal distribution of log(X)</span>
<span class="sd">            :type means: np.ndarray</span>

<span class="sd">            :param covariance: lcovariance matrix of the multivariate log-normal distribution, i.e. covariance matrix of the underlying normal distribution of log(X)</span>
<span class="sd">            :type covariance: np.ndarray with a dimension equal tot the square of means, i.e. if means.shape=(N,) then covariance.shape=(N,N) and if means.shape=(K,L) then covariance.shape=(K,L,K,L).</span>

<span class="sd">            :param flattener: The flattener encodes how to flatten the multidimensional properties stored in nD-arrays into a longer 1D-array for easiear error propagation. This flattener also allows to do the inverse transformation, i.e. deflatten the flattened 1D-array back to its original nD-array format. Should be specified if len(means.shape)=1 because it represents a flattened 2D array (which also implies len(covariance.shape)=2 because it represents a flattened 4D array).</span>
<span class="sd">            :type flattener: :py:class:`Flattener &lt;thermolib.flatten.Flattener&gt;`, optional, default=DummyFlattener() indicating no flattening</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lmeans</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;lmeans should be array, detected </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lmeans</span><span class="p">)))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lcovariance</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;lcovariance matrix should be array, detected </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lcovariance</span><span class="p">)))</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;lmeans should be 1D array, but detected array shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lcovariance</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;lcovariance matrix should be 2D array, but detected array shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lcovariance</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">lcovariance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Inconsistent shapes, lmeans has shape </span><span class="si">%s</span><span class="s1"> while lcovariance has shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">lcovariance</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">lcovariance</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Inconsistent shapes, lmeans has shape </span><span class="si">%s</span><span class="s1"> while lcovariance has shape </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lmeans</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">lcovariance</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">=</span> <span class="n">lmeans</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lcovariance</span> <span class="o">=</span> <span class="n">lcovariance</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lstds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lcovariance</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
        <span class="n">MultiDistribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">)</span>

<div class="viewcode-block" id="MultiLogGaussianDistribution.copy"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return a hard copy of the MultiLogGaussian distribution</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">MultiLogGaussianDistribution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lcovariance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiLogGaussianDistribution.mean"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution mean</span>

<span class="sd">            :param unflatten: If True, return the distribution mean in the original dimensional shape. If False, return the distribution mean as a flattened 1D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unflatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">means</span></div>

<div class="viewcode-block" id="MultiLogGaussianDistribution.std"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution standard deviation (std)</span>

<span class="sd">            :param unflatten: If True, return the distribution std in the original dimensional shape. If False, return the distribution std as a flattened 1D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>

<span class="sd">            :return: standard deviation of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unflatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="n">stds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stds</span></div>
    
<div class="viewcode-block" id="MultiLogGaussianDistribution.cov"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.cov">[docs]</a>    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute and and return the covariance matrix of the MultiLogGaussian distribution.</span>

<span class="sd">            :param unflatten: If True, return the covariance matrix in a shape equal to &#39;the square&#39; of in the original dimensional shape. If False, return the covariance matrix as a flattened 2D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#first construct the flattened covariance matrix</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lcovariance</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mui</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">muj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="kc">False</span><span class="p">)):</span>
                <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mui</span><span class="o">*</span><span class="n">muj</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lcovariance</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#possibly deflatten before returning</span>
        <span class="k">if</span> <span class="n">unflatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_matrix</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cov</span></div>
    
<div class="viewcode-block" id="MultiLogGaussianDistribution.sample"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Returns a number of random samples from the population defined by the distribution</span>

<span class="sd">            :param nsamples: the number of samples returned. If None, a single sample will be returned with a shape depending on whether or not it is flattened (see parameter unflatten). If not None, the return value will have an additional dimension with size given by nsamples.</span>
<span class="sd">            :type nsamples: int or None, optional, default=None</span>

<span class="sd">            :param unflatten: If True, return each distribution sample in the original dimensional shape. If False, return each sample as a flattened 1D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>

<span class="sd">            :return: a (set of) random sample(s) from the population</span>
<span class="sd">            :rtype: np.ndarray whose dimension depend on the nsamples and unflatten keyword values. If nsamples is None, a single sample is returned whose shape depends on whether or not it is flattened (see parameter unflatten). If nsamples is not None, the return value will have an additinal dimension with size given by nsamples.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">samples_flattened</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lcovariance</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unflatten</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="p">,</span> <span class="n">DummyFlattener</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">samples_unflattened</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">dim1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">dim2</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">isample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamples</span><span class="p">):</span>
                    <span class="n">samples_unflattened</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">isample</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="n">samples_flattened</span><span class="p">[:,</span><span class="n">isample</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples_unflattened</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="n">samples_flattened</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">samples_unflattened</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">samples_flattened</span></div>
    
<div class="viewcode-block" id="MultiLogGaussianDistribution.nsigma_conf_int"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.nsigma_conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">nsigma_conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsigma</span><span class="p">,</span> <span class="n">unflatten</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute the n-sigma confidence interval, i.e. :math:`\\exp\\left(\\mu \\pm n\\cdot\\sigma\\right)`</span>
<span class="sd">        </span>
<span class="sd">            :param nsigma: value of n in the above formula</span>
<span class="sd">            :type nsigma: int, optional, default=2</span>

<span class="sd">            :param unflatten: If True, return the interval in the original dimensional shape. If False, return as a flattened 1D array.</span>
<span class="sd">            :type unflatten: bool, optional, default=True</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#first compute the flattened lower and upper bounds</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">-</span> <span class="n">nsigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lmeans</span> <span class="o">+</span> <span class="n">nsigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lstds</span><span class="p">)</span>
        <span class="c1">#possibly deflatten before returning</span>
        <span class="k">if</span> <span class="n">unflatten</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="n">lower</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span><span class="o">.</span><span class="n">unflatten_array</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span></div>
    
<div class="viewcode-block" id="MultiLogGaussianDistribution.from_samples"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.from_samples">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_samples</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">DummyFlattener</span><span class="p">(),</span> <span class="n">flattened</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">            Defines a MultiLogGaussianDistribution based on a population defined by the given samples. The routine will derive the lmean and lcovariance from the population and use that to define the MultiLogGaussian Distribution.</span>

<span class="sd">            :param samples: the samples that define the population</span>
<span class="sd">            :type samples: np.ndarray</span>

<span class="sd">            :param flattened: </span>
<span class="sd">                </span>
<span class="sd">                - If flattened is True, the given samples should be a 2D array in which a row represents all observations of a single variable and a column represents a single observation of all variables.</span>
<span class="sd">                - If flattened is False, then the the samples array is assumed to be 3 dimensional for which the first two dimensions represent a 2D index and the third index is the sample index. Therefore, the flattener will first be applied to flatten the 2D index into a 1D index and hence convert the samples to a 2D array of the same shape as required if the flattened argument is True.</span>
<span class="sd">            </span>
<span class="sd">            :type flattened: bool, optional, default=False</span>

<span class="sd">            :raises AssertionError: if the dimensions of samples array are invalid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">flattened</span><span class="p">:</span>
            <span class="n">samples_unflattened</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">flattener</span><span class="o">.</span><span class="n">dim12</span><span class="p">,</span> <span class="n">samples_unflattened</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">isample</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples_unflattened</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">samples</span><span class="p">[:,</span><span class="n">isample</span><span class="p">]</span> <span class="o">=</span> <span class="n">flattener</span><span class="o">.</span><span class="n">flatten_array</span><span class="p">(</span><span class="n">samples_unflattened</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">isample</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Samples should be a 2 dimensional array, got an array with </span><span class="si">%i</span><span class="s1"> dimensions&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="c1">#compute the log of samples and mask invalid values</span>
        <span class="n">lsamples</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span>
        <span class="c1">#compute means</span>
        <span class="n">lmeans</span> <span class="o">=</span> <span class="n">lsamples</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#construct covariance matrix (and fill columns/rows coming from invalid log samples with np.nan)</span>
        <span class="n">lcov</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">lsamples</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">lcov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">lmeans</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">lmeans</span><span class="p">,</span> <span class="n">lcov</span><span class="p">,</span> <span class="n">flattener</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiLogGaussianDistribution.exp_from_gaussian"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.exp_from_gaussian">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">exp_from_gaussian</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">gaussdist</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Define the MultiLogGaussian distribution of a variable :math:`Y=exp(X)` in which :math:`X` has a given MultiGaussian distribution, potential after imposing a shift and rescaling.</span>

<span class="sd">            :param gaussdist: the Gaussian distribution of variable X in the expression above.</span>
<span class="sd">            :type gaussdist: :py:class:`GaussianDistribution &lt;thermolib.error.GaussianDistribution&gt;`</span>

<span class="sd">            :param shift: shift to be applied to the mean upon conversion</span>
<span class="sd">            :type shift: float, optional, default=0.0</span>

<span class="sd">            :param scale: rescaling to be applied to the mean and std upon conversion</span>
<span class="sd">            :type scale: float, optional, default=1.0</span>

<span class="sd">            :raises AssertionError: if the given gaussdist is not an instance of :py:class:`MultiGaussianDistribution &lt;thermolib.error.MultiGaussianDistribution&gt;`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gaussdist</span><span class="p">,</span> <span class="n">MultiGaussianDistribution</span><span class="p">),</span> <span class="s1">&#39;Can only make MultiLogGaussian distribution from exponent of MultiGaussianDistribution&#39;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">scale</span><span class="o">*</span><span class="n">gaussdist</span><span class="o">.</span><span class="n">means</span><span class="o">+</span><span class="n">shift</span><span class="p">,</span> <span class="p">(</span><span class="n">scale</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">gaussdist</span><span class="o">.</span><span class="n">covariance</span><span class="p">,</span> <span class="n">gaussdist</span><span class="o">.</span><span class="n">flattener</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiLogGaussianDistribution.plot_corr_matrix"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.plot_corr_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">plot_corr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_size_inches</span><span class="o">=</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;bwr&#39;</span><span class="p">,</span> <span class="n">logscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cvs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nticks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            gMake a plot of the correlation matrix of the current multivariate Gaussian distribution</span>

<span class="sd">            :param fn: file name to which figure will be saved. If None, figure will note be written to file.</span>
<span class="sd">            :type fn: _type_, optional, default=None</span>

<span class="sd">            :param fig_size_inches: [x,y]-dimensions of the figure in inches</span>
<span class="sd">            :type fig_size_inches: list, optional, default=[8,8]</span>

<span class="sd">            :param cmap: color map to be used, see `matplotlib documentation &lt;https://matplotlib.org/2.0.2/examples/color/colormaps_reference.html&gt;`_ to see possibilities.</span>
<span class="sd">            :type cmap: str, optional, default=&#39;bwr&#39;</span>

<span class="sd">            :param logscale: plot correlation in logarithmic scale</span>
<span class="sd">            :type logscale: bool, optional, default=False</span>

<span class="sd">            :param cvs: set x and y-tick labels to CV values given in cvs</span>
<span class="sd">            :type cvs: np.ndarray, optional, default=None</span>

<span class="sd">            :param nticks: number of ticks on x and y-axis. Only used when parameter cvs is given.</span>
<span class="sd">            :type nticks: int, optional, default=10</span>

<span class="sd">            :param decimals: number of decimals to be shown in CV tick labels. Only used when parameter cvs is given.</span>
<span class="sd">            :type decimals: int, optional, default=1</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">unflatten</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">logscale</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">special_log</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">100</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">100.0</span>
                <span class="n">result</span><span class="p">[</span><span class="n">x</span><span class="o">&lt;-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">100</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">100.0</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span><span class="o">&lt;</span><span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">special_log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cvs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#set xtick and yticks positions and labels to CV values</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="n">nticks</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">delta</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">cv</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">decimals</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">decimals</span> <span class="k">for</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">cvs</span><span class="p">[</span><span class="n">positions</span><span class="p">]])</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="n">fig_size_inches</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ErrorArray"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.ErrorArray">[docs]</a><span class="k">class</span> <span class="nc">ErrorArray</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A class to represent an array of independent error distributions. This class is used to store the distributiosn for errors on the conditional probabilities, i.e. for each value of cv in p(q|cv) there is an error distribution. The error distribution on p(q|cv1) is assumed uncorrelated with that of p(q|cv2), but we still want to store the distribution for the errors for each cv value in one object.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param errors: list of error distirbutions to be stored</span>
<span class="sd">            :type errors: list of instances of :py:class:`Distribution &lt;thermolib.error.Distribution&gt;`</span>

<span class="sd">            :param axis: the axis index along which the errors are stacked. Only two valid choices: 0 and -1</span>
<span class="sd">            :type axis: int, optional, default=0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">axis</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">axis</span><span class="o">==-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;For axis argument, only value 0 or -1 is supported&#39;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">errors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">shape</span><span class="o">==</span><span class="n">error</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;Detected an error with shape </span><span class="si">%s</span><span class="s1"> and an error with shape </span><span class="si">%s</span><span class="s1">, but all errors should be of same shape.&#39;</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="n">errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>

    <span class="c1">#def crop(self, indexes):</span>
    <span class="c1">#    for error in self.errors:</span>
    <span class="c1">#        error.crop(indexes)</span>

<div class="viewcode-block" id="ErrorArray.mean"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.ErrorArray.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution mean for each element in the errors list</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ErrorArray.std"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.ErrorArray.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return the distribution standard deviation for each element in the errors list</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">error</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="ErrorArray.nsigma_conf_int"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.ErrorArray.nsigma_conf_int">[docs]</a>    <span class="k">def</span> <span class="nf">nsigma_conf_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsigma</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute the n-sigma confidence interval, i.e. :math:`\\mu \\pm n\\cdot\\sigma`, for each element in the errors list</span>

<span class="sd">            :return: mean of the distibution</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">lowers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">uppers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="n">nsigma</span><span class="p">)</span>
            <span class="n">lowers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
            <span class="n">uppers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">uppers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="ErrorArray.sample"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.ErrorArray.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsamples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Returns a number of random samples taken according to the error distribution for each element in the error list</span>

<span class="sd">            :param nsamples: the number of samples returned. If None, a single sample will be returned and the shape of the return value will be identical to self.means and self.stds. If not None, the return value will have an additional dimension with size given by nsamples.</span>
<span class="sd">            :type nsamples: int or None, optional, default=None</span>

<span class="sd">            :return: multidimensional numpy array containing random samples for each element in self.errors. Shape of this array depends on nsamples, self.naxis and number of elements in self.errors.</span>
<span class="sd">            :rtype: np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">),]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span><span class="p">[</span><span class="n">nsamples</span><span class="p">,])</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">error</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">):</span>
                    <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">),</span><span class="n">nsamples</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">error</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">):</span>
                    <span class="n">samples</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis attribute should be 0 or -1 but found </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">sample</span><span class="p">())</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span></div></div>


<div class="viewcode-block" id="Propagator"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.Propagator">[docs]</a><span class="k">class</span> <span class="nc">Propagator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A class to propagate the error distribution on a set of arguments towards the error distribution on a given function of those arguments. This routine uses the ``sample`` routine of each of its distrubution arguments, meaning that the resulting error is stochastic (will not give the same repeated result).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncycles</span><span class="o">=</span><span class="n">ncycles_default</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">GaussianDistribution</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">DummyFlattener</span><span class="p">(),</span> <span class="n">samples_are_flattened</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param ncycles: the number of cycles for which a random sample is taken for each argument and corresponding function value is computed.</span>
<span class="sd">            :type ncycles: int, optional, default given by value of global variable ncycles_default</span>

<span class="sd">            :param target_distribution: the type of distribution to be used for the error of the function value. Can be overwritten in the get_distribution routine.</span>
<span class="sd">            :type target_distribution: child class of :py:class:`Distribution &lt;thermolib.error.Distribution&gt;`, optional, default=GaussianDistribution</span>

<span class="sd">            :param flattener: Flattener to be parsed to the error distribution of the function value. Can be overwritten in the get_distribution routine.</span>
<span class="sd">            :type flattener: instance of child class of :py:class:`Flattener &lt;thermolib.flattener.Flattener&gt;`, optional, default=DummyFlattener()</span>

<span class="sd">            :param samples_are_flattened: whether or not the samples generated by ``gen_args_samples`` (and hence the ``sample`` routine of the arguments) are flattened. Can be overwritten in the get_distribution routine.</span>
<span class="sd">            :type samples_are_flattened: bool, optional, default=False</span>

<span class="sd">            :param verbose: If True, increase verbosity of the propagator logging</span>
<span class="sd">            :type verbose: bool, optional, default=False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncycles</span> <span class="o">=</span> <span class="n">ncycles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argsamples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_distribution</span> <span class="o">=</span> <span class="n">target_distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span> <span class="o">=</span> <span class="n">flattener</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">samples_are_flattened</span> <span class="o">=</span> <span class="n">samples_are_flattened</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    
<div class="viewcode-block" id="Propagator.reset"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.Propagator.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">samples_are_flattened</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Reinitialize argsamples  for future reuse. For more info on arguments target_distribution, flattener or samples_are_flattened, see documentation in the initializer. Only if such an argument is explicitly specified (i.e. is not None), will it be overwritten with the given value.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argsamples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">target_distribution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_distribution</span> <span class="o">=</span> <span class="n">target_distribution</span>
        <span class="k">if</span> <span class="n">flattener</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span> <span class="o">=</span> <span class="n">flattener</span>
        <span class="k">if</span> <span class="n">samples_are_flattened</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples_are_flattened</span> <span class="o">=</span> <span class="n">samples_are_flattened</span></div>

<div class="viewcode-block" id="Propagator.gen_args_samples"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.Propagator.gen_args_samples">[docs]</a>    <span class="k">def</span> <span class="nf">gen_args_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine that will generate random samples for each of the given arguments. The total number of samples per argument is defined in self.ncycles. </span>
<span class="sd">            </span>
<span class="sd">            :param args: list of arguments of the function for which the error needs to be computed</span>
<span class="sd">            :type args: list of distributions</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error propagation - generating </span><span class="si">%i</span><span class="s1"> argument samples...&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncycles</span><span class="p">))</span>
        <span class="c1">#generate samples for arguments        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argsamples</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iarg</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  ... for argument </span><span class="si">%i</span><span class="s1"> (=</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">iarg</span><span class="p">,</span><span class="n">arg</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">argsamples</span><span class="p">[</span><span class="n">iarg</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">nsamples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ncycles</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  ..... resulted in argsamples[</span><span class="si">%i</span><span class="s1">].shape=&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">iarg</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">argsamples</span><span class="p">[</span><span class="n">iarg</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Propagator.calc_fun_values"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.Propagator.calc_fun_values">[docs]</a>    <span class="k">def</span> <span class="nf">calc_fun_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine to compute the function value for each set of random samples stored for the arguments during execution of the ``gen_args_samples`` routine.</span>

<span class="sd">            :param fun: function f for which the error needs to be computed</span>
<span class="sd">            :type fun: callable</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error propagation - calculating function values for </span><span class="si">%i</span><span class="s1"> cycles...&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncycles</span><span class="p">))</span>
        <span class="c1">#propagate argument samples to function values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncycles</span>
        <span class="k">for</span> <span class="n">icycle</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncycles</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  ... for cycle </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">icycle</span><span class="p">))</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">argsamples</span><span class="p">[</span><span class="n">iarg</span><span class="p">][</span><span class="o">...</span><span class="p">,</span><span class="n">icycle</span><span class="p">]</span> <span class="k">for</span> <span class="n">iarg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">argsamples</span><span class="p">))]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  ..... function has </span><span class="si">%i</span><span class="s1"> arguments&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">iarg</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  ..... argument </span><span class="si">%i</span><span class="s1"> has shape:&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">iarg</span><span class="p">),</span> <span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span><span class="p">[</span><span class="n">icycle</span><span class="p">]</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c1">#Some post process book keeping and logging</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error propagation - generating distribution from samples ...&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;funsamples.shape=&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="Propagator.get_distribution"><a class="viewcode-back" href="../../rg_error.html#thermolib.error.Propagator.get_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">get_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">samples_are_flattened</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine to construct the error distribution of the function value from a population generated by the routines ``gen_args_samples`` and ``calc_fun_values``. For more info on arguments target_distribution, flattener or samples_are_flattened, see documentation in the initializer. Only if such an argument is explicitly specified (i.e. is not None), will it be overwritten with the given value.</span>

<span class="sd">            :return: Distribution of the function value</span>
<span class="sd">            :rtype: determined by parameter target_distribution</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">target_distribution</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">target_distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_distribution</span>
        <span class="k">if</span> <span class="n">flattener</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">flattener</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flattener</span>
        <span class="k">if</span> <span class="n">samples_are_flattened</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">samples_are_flattened</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_are_flattened</span>
        <span class="k">if</span> <span class="n">target_distribution</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MultiGaussianDistribution</span><span class="p">,</span> <span class="n">MultiLogGaussianDistribution</span><span class="p">]:</span>
            <span class="n">distr</span> <span class="o">=</span> <span class="n">target_distribution</span><span class="o">.</span><span class="n">from_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">,</span> <span class="n">flattened</span><span class="o">=</span><span class="n">samples_are_flattened</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distr</span> <span class="o">=</span> <span class="n">target_distribution</span><span class="o">.</span><span class="n">from_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funsamples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">distr</span></div>
    
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">samples_are_flattened</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Default calling sequence of the various Propagator routines.  For more info on arguments target_distribution, flattener or samples_are_flattened, see documentation of :py:meth:`Propagator.__init__ &lt;thermolib.error.Propoagator.__init__&gt;`. Only if such an argument is explicitly specified (i.e. is not None), will it be overwritten with the given value.</span>

<span class="sd">            :param fun: function f for which the error needs to be computed</span>
<span class="sd">            :type fun: callable</span>

<span class="sd">            :param args: list of arguments of the function for which the error needs to be computed</span>
<span class="sd">            :type args: list of distributions</span>

<span class="sd">            :return: Distribution of the function value</span>
<span class="sd">            :rtype: determined by parameter target_distribution</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#for backward compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen_args_samples</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_fun_values</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distribution</span><span class="p">(</span><span class="n">target_distribution</span><span class="o">=</span><span class="n">target_distribution</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">,</span> <span class="n">samples_are_flattened</span><span class="o">=</span><span class="n">samples_are_flattened</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Louis Vanduyfhuys.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>