<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>thermolib.thermodynamics.condprob &mdash; ThermoLIB v1.7.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=131c94de"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ThermoLIB
              <img src="../../../_static/logo_thermolib_light.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ig.html">Installation Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ig.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ig.html#download-and-install-thermolib">Download and install ThermoLIB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ig.html#direct-install-using-pip">Direct install using pip</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ig.html#developers-download">Developers download</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ig.html#test-installation">Test installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../ug.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_1DFEP.html">Constructing 1D histograms &amp; free energy profiles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_1DFEP.html#construct-a-1d-histrogam">Construct a 1D histrogam …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#from-a-single-simulation">… from a single simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#from-multiple-simulations-using-wham">… from multiple simulations using WHAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_1DFEP.html#constructing-a-1d-free-energy-profile">Constructing a 1D free energy profile …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#using-the-constructor">… using the constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#reading-from-a-text-file">… reading from a text file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#from-a-histogram">… from a histogram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_2DFES.html">Constructing 2D histograms &amp; free energy surfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_2DFES.html#constructing-a-2d-histogram">Constructing a 2D histogram …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#from-single-simulation">… from single simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#from-multiple-simulations-using-wham">… from multiple simulations using WHAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_2DFES.html#constructing-a-2d-free-energy-surface">Constructing a 2D free energy surface …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#using-the-constructor">… using the constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#reading-from-a-text-file">… reading from a text file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#from-a-histogram">… from a histogram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_corrtime.html">Computing the correlation time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_corrtime.html#fit-to-autocorrelation-function-for-single-trajectory">Fit to autocorrelation function for single trajectory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_corrtime.html#compute-correlation-time-for-trajectory-series">Compute correlation time for trajectory series</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_error.html">Error estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_error.html#without-correlations">Without correlations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_error.html#with-correlations">With correlations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_plotting.html">Plotting histograms and FEP/FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_plotting.html#d-histograms-free-energy-profile">1D Histograms &amp; free energy profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_plotting.html#d-histograms-free-energy-surfaces">2D Histograms &amp; free energy surfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_micromacro.html">Extracting micro- and macrostate free energy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_kinetics.html">Computing the reaction rate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_transformation.html">Transformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_transformation.html#deterministic-transformation">Deterministic transformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_transformation.html#probabilistic-transformation">Probabilistic transformation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_projection.html">(De)projections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_projection.html#projecting-2d-fes-to-1d-fep">Projecting 2D FES to 1D FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_projection.html#deprojecting-1d-fep-to-2d-fes">Deprojecting 1D FEP to 2D FES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/basic_wham1d.html">Tutorial 1 - Construction of 1D free energy profile using WHAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham1d.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham1d.html#WHAM-without-error-estimation">WHAM without error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham1d.html#WHAM-with-error-estimation">WHAM with error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham1d.html#Defining-macrostates-and-microstates">Defining macrostates and microstates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/basic_kinetics.html">Tutorial 2 - Extracting kinetic reaction rates in 1D</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_kinetics.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_kinetics.html#Construct-free-energy-profile">Construct free energy profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_kinetics.html#Compute-rate-prefactor">Compute rate prefactor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_kinetics.html#Add-kinetic-information-to-FEP-plot">Add kinetic information to FEP plot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/basic_wham2d.html">Tutorial 3 - Construction of 2D free energy surface using WHAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham2d.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham2d.html#2D-WHAM-without-error-estimation">2D WHAM without error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham2d.html#2D-WHAM-with-error-estimate">2D WHAM with error estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham2d.html#Alternative-plotting">Alternative plotting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/advanced_error_estimation.html">Tutorial 4 - Advanced techniques in error estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Impact-correlation-between-samples-on-FEP">Impact correlation between samples on FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Estimating-the-autocorrelation-time">Estimating the autocorrelation time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Constructing-the-FEP-with-correlated-error-estimate">Constructing the FEP with correlated error estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Evaluating-the-correlated-error-estimate">Evaluating the correlated error estimate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Delayed-strided-WHAM-profiles">Delayed-strided WHAM profiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Blocked-WHAM-profile">Blocked WHAM profile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Bootstrapped-WHAM-profiles">Bootstrapped WHAM profiles</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Covariance-between-different-points-on-FEP">Covariance between different points on FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Error-propagation">Error propagation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/advanced_projection.html">Tutorial 5 - Projection of 2D FES to 1D FEP with error propagation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_projection.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_projection.html#Constructing-2D-FES">Constructing 2D FES</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_projection.html#Projection-onto-1D-profile">Projection onto 1D profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_projection.html#Along-predefined-direction">Along predefined direction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_projection.html#Along-any-custom-direction">Along any custom direction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_projection.html#Error-propagation">Error propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_projection.html#Deal-with-the-unsufficiently-sampled-edges-of-phase-space-in-FES-projection">Deal with the unsufficiently sampled edges of phase space in FES projection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/advanced_deprojection.html">Tutorial 6 - Deprojecting 1D FEP to 2D FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Construct-1D-FEP">Construct 1D FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Deproject-to-2D-FES">Deproject to 2D FES</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Direct-route---2D-WHAM">Direct route - 2D WHAM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Indirect-route---deproject-1D-FEP">Indirect route - deproject 1D FEP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#CONSISTENCY-CHECK:-project-2D-FES-to-1D-FEP">CONSISTENCY CHECK: project 2D FES to 1D FEP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_deprojection.html#U(CV)-profile">U(CV) profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Method-1---from-2D-FES">Method 1 - from 2D FES</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Method-2---from-conditional-probability">Method 2 - from conditional probability</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#comparison">comparison</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/advanced_transformations.html">Tutorial 7 - Transformations of 1D FEP and kinetics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_transformations.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_transformations.html#FEP-and-rate-with-original-CV">FEP and rate with original CV</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_transformations.html#FEP-and-rate-in-terms-of-alternative-CV">FEP and rate in terms of alternative CV</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../rg.html">Reference Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_thermo.html">Thermodynamics – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.fep">Free energy profiles – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.fep</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.BaseFreeEnergyProfile"><code class="docutils literal notranslate"><span class="pre">BaseFreeEnergyProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.BaseProfile"><code class="docutils literal notranslate"><span class="pre">BaseProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.FreeEnergySurface2D"><code class="docutils literal notranslate"><span class="pre">FreeEnergySurface2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.SimpleFreeEnergyProfile"><code class="docutils literal notranslate"><span class="pre">SimpleFreeEnergyProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.plot_profiles"><code class="docutils literal notranslate"><span class="pre">plot_profiles()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.histogram">Histograms – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.histogram</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.histogram.Histogram1D"><code class="docutils literal notranslate"><span class="pre">Histogram1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.histogram.Histogram2D"><code class="docutils literal notranslate"><span class="pre">Histogram2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.histogram.plot_histograms"><code class="docutils literal notranslate"><span class="pre">plot_histograms()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.trajectory">Trajectory readers – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.trajectory</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.trajectory.ASEExtendedXYZReader"><code class="docutils literal notranslate"><span class="pre">ASEExtendedXYZReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.trajectory.CVComputer"><code class="docutils literal notranslate"><span class="pre">CVComputer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.trajectory.ColVarReader"><code class="docutils literal notranslate"><span class="pre">ColVarReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.trajectory.HDF5Reader"><code class="docutils literal notranslate"><span class="pre">HDF5Reader</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.bias">Bias potentials – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.bias</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.BiasPotential1D"><code class="docutils literal notranslate"><span class="pre">BiasPotential1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.BiasPotential2D"><code class="docutils literal notranslate"><span class="pre">BiasPotential2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.MultipleBiasses1D"><code class="docutils literal notranslate"><span class="pre">MultipleBiasses1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.Parabola1D"><code class="docutils literal notranslate"><span class="pre">Parabola1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.Parabola2D"><code class="docutils literal notranslate"><span class="pre">Parabola2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.PlumedSplinePotential1D"><code class="docutils literal notranslate"><span class="pre">PlumedSplinePotential1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.Polynomial1D"><code class="docutils literal notranslate"><span class="pre">Polynomial1D</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.cv">Collective variables – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.cv</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.Average"><code class="docutils literal notranslate"><span class="pre">Average</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.CenterOfMass"><code class="docutils literal notranslate"><span class="pre">CenterOfMass</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.CenterOfPosition"><code class="docutils literal notranslate"><span class="pre">CenterOfPosition</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.CoordinationNumber"><code class="docutils literal notranslate"><span class="pre">CoordinationNumber</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.Difference"><code class="docutils literal notranslate"><span class="pre">Difference</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.DistOrthProjOrig"><code class="docutils literal notranslate"><span class="pre">DistOrthProjOrig</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.Distance"><code class="docutils literal notranslate"><span class="pre">Distance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.DistanceCOP"><code class="docutils literal notranslate"><span class="pre">DistanceCOP</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.DotProduct"><code class="docutils literal notranslate"><span class="pre">DotProduct</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.LinearCombination"><code class="docutils literal notranslate"><span class="pre">LinearCombination</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.Minimum"><code class="docutils literal notranslate"><span class="pre">Minimum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.NormalToPlane"><code class="docutils literal notranslate"><span class="pre">NormalToPlane</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.NormalizedAxis"><code class="docutils literal notranslate"><span class="pre">NormalizedAxis</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.OrthogonalDistanceToPore"><code class="docutils literal notranslate"><span class="pre">OrthogonalDistanceToPore</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.state">State – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.state</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.state.Integrate"><code class="docutils literal notranslate"><span class="pre">Integrate</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.state.Maximum"><code class="docutils literal notranslate"><span class="pre">Maximum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.state.Minimum"><code class="docutils literal notranslate"><span class="pre">Minimum</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.condprob">Conditional probability – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.condprob</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D"><code class="docutils literal notranslate"><span class="pre">ConditionalProbability1D1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D"><code class="docutils literal notranslate"><span class="pre">ConditionalProbability1D2D</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_kin.html">Kinetics – <code class="docutils literal notranslate"><span class="pre">thermolib.kinetics</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_kin.html#module-thermolib.kinetics.rate">Rate constant – <code class="docutils literal notranslate"><span class="pre">thermolib.kinetics.rate</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_kin.html#thermolib.kinetics.rate.RateFactorEquilibrium"><code class="docutils literal notranslate"><span class="pre">RateFactorEquilibrium</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_error.html">Error distributions – <code class="docutils literal notranslate"><span class="pre">thermolib.error</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.Distribution"><code class="docutils literal notranslate"><span class="pre">Distribution</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.GaussianDistribution"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.LogGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.MultiGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_error.html#thermolib.error.MultiGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.from_samples()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.MultiLogGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.from_samples()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.Propagator"><code class="docutils literal notranslate"><span class="pre">Propagator</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.SampleDistribution"><code class="docutils literal notranslate"><span class="pre">SampleDistribution</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_tools.html">Tools – <code class="docutils literal notranslate"><span class="pre">thermolib.tools</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.blav"><code class="docutils literal notranslate"><span class="pre">blav()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.corrtime_from_acf"><code class="docutils literal notranslate"><span class="pre">corrtime_from_acf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.decorrelate"><code class="docutils literal notranslate"><span class="pre">decorrelate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.extract_polynomial_bias_info"><code class="docutils literal notranslate"><span class="pre">extract_polynomial_bias_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.fisher_matrix_mle_probdens"><code class="docutils literal notranslate"><span class="pre">fisher_matrix_mle_probdens()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.format_scientific"><code class="docutils literal notranslate"><span class="pre">format_scientific()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.h5_read_dataset"><code class="docutils literal notranslate"><span class="pre">h5_read_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.integrate"><code class="docutils literal notranslate"><span class="pre">integrate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.integrate2d"><code class="docutils literal notranslate"><span class="pre">integrate2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.invert_fisher_to_covariance"><code class="docutils literal notranslate"><span class="pre">invert_fisher_to_covariance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.multivariate_normal"><code class="docutils literal notranslate"><span class="pre">multivariate_normal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.read_wham_input"><code class="docutils literal notranslate"><span class="pre">read_wham_input()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.rolling_average"><code class="docutils literal notranslate"><span class="pre">rolling_average()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_ext.html">Extensions – <code class="docutils literal notranslate"><span class="pre">thermolib.ext</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham1d_bias"><code class="docutils literal notranslate"><span class="pre">wham1d_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham1d_error"><code class="docutils literal notranslate"><span class="pre">wham1d_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham1d_hs"><code class="docutils literal notranslate"><span class="pre">wham1d_hs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham1d_scf"><code class="docutils literal notranslate"><span class="pre">wham1d_scf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham2d_bias"><code class="docutils literal notranslate"><span class="pre">wham2d_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham2d_error"><code class="docutils literal notranslate"><span class="pre">wham2d_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham2d_hs"><code class="docutils literal notranslate"><span class="pre">wham2d_hs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham2d_scf"><code class="docutils literal notranslate"><span class="pre">wham2d_scf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ThermoLIB</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">thermolib.thermodynamics.condprob</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for thermolib.thermodynamics.condprob</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2019 - 2024 Louis Vanduyfhuys &lt;Louis.Vanduyfhuys@UGent.be&gt;</span>
<span class="c1"># Center for Molecular Modeling (CMM), Ghent University, Ghent, Belgium;</span>
<span class="c1"># all rights reserved unless otherwise stated.</span>
<span class="c1">#</span>
<span class="c1"># This file is part of a library developed by Louis Vanduyfhuys at</span>
<span class="c1"># the Center for Molecular Modeling under supervision of prof. Veronique</span>
<span class="c1"># Van Speybroeck. Usage of this package should be authorized by prof. Van</span>
<span class="c1"># Vanduyfhuys or prof. Van Speybroeck.</span>

<span class="kn">from</span> <span class="nn">molmod.units</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molmod.constants</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molmod.io.xyz</span> <span class="kn">import</span> <span class="n">XYZReader</span>

<span class="kn">from</span> <span class="nn">ase.io</span> <span class="kn">import</span> <span class="n">read</span>

<span class="kn">from</span> <span class="nn">..tools</span> <span class="kn">import</span> <span class="n">integrate2d</span><span class="p">,</span> <span class="n">invert_fisher_to_covariance</span><span class="p">,</span> <span class="n">fisher_matrix_mle_probdens</span>
<span class="kn">from</span> <span class="nn">.fep</span> <span class="kn">import</span> <span class="n">BaseProfile</span><span class="p">,</span> <span class="n">BaseFreeEnergyProfile</span><span class="p">,</span> <span class="n">FreeEnergySurface2D</span>
<span class="kn">from</span> <span class="nn">..error</span> <span class="kn">import</span> <span class="n">ncycles_default</span><span class="p">,</span> <span class="n">Propagator</span><span class="p">,</span> <span class="n">GaussianDistribution</span><span class="p">,</span> <span class="n">LogGaussianDistribution</span><span class="p">,</span> <span class="n">MultiGaussianDistribution</span><span class="p">,</span> <span class="n">MultiLogGaussianDistribution</span><span class="p">,</span> <span class="n">ErrorArray</span>
<span class="kn">from</span> <span class="nn">.trajectory</span> <span class="kn">import</span> <span class="n">CVComputer</span><span class="p">,</span> <span class="n">ColVarReader</span>
<span class="kn">from</span> <span class="nn">..flatten</span> <span class="kn">import</span> <span class="n">Flattener</span>
<span class="c1">#from thermolib.ext import fisher_matrix_mle_probdens, invert_fisher_to_covariance</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">rc</span>
<span class="n">rc</span><span class="p">(</span><span class="s1">&#39;font&#39;</span><span class="p">,</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;family&#39;</span><span class="p">:</span><span class="s1">&#39;sans-serif&#39;</span><span class="p">,</span><span class="s1">&#39;sans-serif&#39;</span><span class="p">:[</span><span class="s1">&#39;Helvetica&#39;</span><span class="p">]})</span>
<span class="n">rc</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ConditionalProbability1D1D&#39;</span><span class="p">,</span> <span class="s1">&#39;ConditionalProbability1D2D&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ConditionalProbability</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Class to compute conditional probabilities of the form :math:`p([qs]|[cvs])`, i.e. probability of finding states characterized with collective variables qs, on the condition that the states are also characterized by collective variables cvs. Such conditional probabiliy allows to convert a free energy surface/profile in terms of the collective variables :math:`cvs` to a free energy surface/profile in terms of the collective variables :math:`qs`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nq</span><span class="p">,</span> <span class="n">ncv</span><span class="p">,</span> <span class="n">q_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param nq: dimension of q-space</span>
<span class="sd">            :type nq: int</span>

<span class="sd">            :param ncv: dimension of cv-space</span>
<span class="sd">            :type ncv: int</span>

<span class="sd">            :param q_labels: list of labels (one for each q) to be used in plots or prints</span>
<span class="sd">            :type q_labels: list of strings, optional, default=[&#39;Q1&#39;, [&#39;Q2&#39;, [...]]]</span>

<span class="sd">            :param cv_labels: list of labels (one for each cv) to be used in plots or prints</span>
<span class="sd">            :type cv_labels: list of strings, optional, default=[&#39;CV1&#39;, [&#39;CV2&#39;, [...]]]</span>

<span class="sd">            :param q_units: list of units (one for each q) to be used in plots or prints</span>
<span class="sd">            :type q_units: list of strings, optional, default=[&#39;au&#39;, [&#39;au&#39;, [...]]]</span>

<span class="sd">            :param cv_labels: list of units (one for each cv) to be used in plots or prints</span>
<span class="sd">            :type cv_labels: list of strings, optional, default=[&#39;au&#39;, [&#39;au&#39;, [...]]]</span>

<span class="sd">            :param verbose: make all class routines more verbose in their logging</span>
<span class="sd">            :type verbose: bool, optional, default=False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">=</span> <span class="n">nq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">=</span> <span class="n">ncv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">if</span> <span class="n">q_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Q</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nq</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span> <span class="o">=</span> <span class="n">q_labels</span>
        <span class="k">if</span> <span class="n">cv_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CV</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncv</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span> <span class="o">=</span> <span class="n">cv_labels</span>
        <span class="k">if</span> <span class="n">q_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;au&#39;</span><span class="p">,]</span><span class="o">*</span><span class="n">nq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_units</span> <span class="o">=</span> <span class="n">q_units</span>
        <span class="k">if</span> <span class="n">cv_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;au&#39;</span><span class="p">,]</span><span class="o">*</span><span class="n">ncv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span> <span class="o">=</span> <span class="n">cv_units</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#correlation time in q samples in each simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples_persim</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#number of samples in each simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># number of simulations</span>

    <span class="k">def</span> <span class="nf">init_bins_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_bins</span><span class="p">,</span> <span class="n">cv_bins</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine to initialize the bins used for constructing the conditional probability histograms</span>

<span class="sd">            :param q_bins: list of numpy arrays, each array corresponding to the bin edges for one of the Qs. Alternatively, a single numpy array can be given which is then interpreted as the bin edges for all of the Qs.</span>
<span class="sd">            :type q_bins: list(np.ndarray) or np.ndarray</span>

<span class="sd">            :param cv_bins: list of numpy arrays, each array corresponding to the bin edges for one of the CVs. Alternatively, a single numpy array can be given which is then interpreted as the bin edges for all of the CVs.</span>
<span class="sd">            :type cv_bins: list(np.ndarray) or np.ndarray</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initializing grids for CV and Q ...&#39;</span><span class="p">)</span>
        <span class="c1">#type checking and storing of input arguments</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_bins</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">q_bins</span><span class="p">)</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">,</span> <span class="s1">&#39;When q_bins is a list, it should contain a number of arrays equal to the number of Qs (=</span><span class="si">%i</span><span class="s1">) corresponding to the edges for each Q, but instead got a list of length </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">q_bins</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">q_bins</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;When q_bins is a list, all its elements should be a numpy array containing the bin edges of the corresponding Q.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;Argument q_bins should be a list of numpy arrays, one array for each Q, or a single numpy array valid for each Q&#39;</span>
            <span class="n">q_bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">q_bins</span><span class="p">,]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_bins</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cv_bins</span><span class="p">)</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="s1">&#39;When cv_bins is a list, it should contain a number of arrays equal to the number of CVs (=</span><span class="si">%i</span><span class="s1">) corresponding to the edges for each CV, but instead got a list of length </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cv_bins</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cv_bins</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;When cv_bins is a list, all its elements should be a numpy array containing the bin edges of the corresponding CV.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;Argument cv_bins should be a list of numpy arrays, one array for each CV, or a single numpy array valid for each CV&#39;</span>
            <span class="n">cv_bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv_bins</span><span class="p">,]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span> <span class="o">=</span> <span class="n">q_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span> <span class="o">=</span> <span class="n">cv_bins</span>
        <span class="c1">#construct grids for q, cv and q+cv, useful for iterating over later</span>
        <span class="c1">#self.qs is just a list of the bin centers for each q</span>
        <span class="c1">#self.q_grid is a meshgrid of the bin centers</span>
        <span class="c1">#same for cv</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="c1">#self.q_grid = self.qs[0]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qs</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="c1">#self.cv_grid = self.cvs[0]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_q_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_q</span><span class="p">,</span> <span class="n">input_cv</span><span class="p">,</span> <span class="n">corr_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine to extract data samples for the CVs and Qs from given files. In a later stage, these samples will be used to histogram in terms of Q for each conditional CV.</span>

<span class="sd">            :param input_q: list of tuples of the form (fn, reader), one for each Q to be included, with fn the file name of the trajectory from which reader will extract the q-values</span>
<span class="sd">            :type input_q: list</span>

<span class="sd">            :param input_cv: list of tuples of the form (fn, reader), one for each CV to be included, with fn the file name of the trajectory from which reader will extract the cv-values</span>
<span class="sd">            :type input_cv: list</span>
<span class="sd">            </span>
<span class="sd">            :param corr_time: only relevant if error estimation is also desired, in which case corr_time represent the correlation time within the Q samples which will be used for more accurate error estimation.</span>
<span class="sd">            :type corr_time: float, optional, default=1.0</span>

<span class="sd">            :raises RuntimeError: if attempted to add additional simulations after the ``finish`` routine has been called already.</span>
<span class="sd">            :raises AssertionError: if any 2 Q-readers detect different number of samples in any simulation</span>
<span class="sd">            :raises AssertionError: if any 2 CV-readers detect different number of samples in any simulation</span>
<span class="sd">            :raises AssertionError: if any combination of one Q-reader and one CV-reader detect different number of samples in any simulation</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#init</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot read additional XYZ trajectory because current conditional probability has already been finished.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processing simulation </span><span class="si">%i</span><span class="s1">  &#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">))</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">q_samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cv_samples</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1">#extracting Q samples</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reader</span> <span class="ow">in</span> <span class="n">input_q</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  reading samples for </span><span class="si">%s</span><span class="s1"> from file </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">q_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">q_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q_samples</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="n">num_samples</span><span class="p">,</span> <span class="s1">&#39;Each Q reader should detect equal number of samples for the same simulation!&#39;</span>
            <span class="c1">#estimating number of independent Q-samples</span>

        <span class="c1">#extracting CV samples</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reader</span> <span class="ow">in</span> <span class="n">input_cv</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  reading samples for </span><span class="si">%s</span><span class="s1"> from file </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="n">num_samples</span><span class="p">,</span> <span class="s1">&#39;Each CV reader should detect equal number of samples as all other Qs and CVs for the same simulation!&#39;</span>
            <span class="k">if</span> <span class="n">cv_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cv_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cv_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_samples</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#some final bookkeeping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  detected </span><span class="si">%i</span><span class="s1"> samples, from which </span><span class="si">%i</span><span class="s1"> independent (correlation time = </span><span class="si">%i</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">/</span><span class="n">corr_time</span><span class="p">,</span> <span class="n">corr_time</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Routine that allows to re-reference all samples of a given Q/CV collective variable. This is usefull, e.g. if a certain collective variable represents an energy and you want to put the zero for that energy at the minimum across all samples.</span>

<span class="sd">            :param q_index: specify the index of the Q collective variable you want to re-ref with the given q_ref. If an integer is given, it should be larger than (or equal to) 0 and smaller then the number of Qs. If None, no Q re-reffing will be done. If set to &#39;all&#39;, all Qs will be re-reffed.</span>
<span class="sd">            :type q_index: int|&#39;all&#39;|None, optional, default=None</span>

<span class="sd">            :param q_ref: specify how to re-reference. If a float is given, substract the given float from all samples of all processed simulations of the corresponding Q. If the string &#39;global_minimum&#39; is given, first compute the global min of all samples of all processed simulations of the corresponding Q and then substract that value from all those samples. If the string &#39;minimum_average&#39; is given, first compute the minima of the samples of the corresponding Q for each simulation separately, then compute the average of all those simulation minima. Finally, substract that average from all the samples of all simulatios of the corresponding Q. Value None only allowed if q_index is also None, in which case no re-reffing is done for any Q.</span>
<span class="sd">            :type q_ref: float|str|None, optional, default=None</span>

<span class="sd">            :param cv_index: specify the index of the CVcollective variable you want to re-ref with the given cv_ref. If an integer is given, it should be larger than (or equal to) 0 and smaller then the number of CVs. If None, no CV re-reffing will be done. If set to &#39;all&#39;, all Qs will be re-reffed.</span>
<span class="sd">            :type cv_index: int|&#39;all&#39;|None, optional, default=None</span>

<span class="sd">            :param cv_ref: specify how to re-reference. If a float is given, substract the given float from all samples of all processed simulations of the corresponding CV. If the string &#39;global_minimum&#39; is given, first compute the global min of all samples of all processed simulations of the corresponding CV and then substract that value from all those samples. If the string &#39;minimum_average&#39; is given, first compute the minima of the samples of the corresponding CV for each simulation separately, then compute the average of all those simulation minima. Finally, substract that average from all the samples of all simulatios of the corresponding CV. Value None only allowed if cv_index is also None, in which case no re-reffing is done for any CV.</span>
<span class="sd">            :type cv_ref: float|str|None, optional, default=None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#set q references</span>
        <span class="k">if</span> <span class="n">q_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting Q reference&#39;</span><span class="p">)</span>
            <span class="c1">#check and init q_indices</span>
            <span class="k">if</span> <span class="n">q_index</span><span class="o">==</span><span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">q_index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">q_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">q_index</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_index</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">q_index</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;q_index should be integer, list of integers or &#39;all&#39;. Received </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q_index</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q_index should be integer, list of integers or &#39;all&#39;. Received </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q_index</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="n">q_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  of Q</span><span class="si">%i</span><span class="s1"> to </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span><span class="n">q_ref</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="c1">#check and init reference value</span>
                <span class="k">if</span> <span class="n">q_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;global_minimum&#39;</span><span class="p">]:</span>
                    <span class="n">q_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                        <span class="n">q_ref</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">q_ref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">iq</span><span class="p">])])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;which is </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">q_ref</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">q_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;minimum_average&#39;</span><span class="p">]:</span>
                    <span class="n">q_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                        <span class="n">q_ref</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">q_ref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">iq</span><span class="p">])])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;which is </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">q_ref</span><span class="p">))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_ref</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q_ref should be either &#39;global_minimum&#39;, &#39;minimum_average&#39; or a float value&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="c1">#set ref</span>
                <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">iq</span><span class="p">]</span> <span class="o">-=</span> <span class="n">q_ref</span>
        <span class="c1">#set q references</span>
        <span class="k">if</span> <span class="n">cv_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting CV reference&#39;</span><span class="p">)</span>
            <span class="c1">#check and init cv_indices</span>
            <span class="k">if</span> <span class="n">cv_index</span><span class="o">==</span><span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">cv_index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">cv_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_index</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">cv_index</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;cv_index should be integer, list of integers or &#39;all&#39;. Received </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cv_index</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cv_index should be integer, list of integers or &#39;all&#39;. Received </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cv_index</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">icv</span> <span class="ow">in</span> <span class="n">cv_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  of CV</span><span class="si">%i</span><span class="s1"> to </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">icv</span><span class="p">,</span><span class="n">cv_ref</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="c1">#check and init reference value</span>
                <span class="k">if</span> <span class="n">cv_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;global_minimum&#39;</span><span class="p">]:</span>
                    <span class="n">cv_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                        <span class="n">cv_ref</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">cv_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;which is </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">cv_ref</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">cv_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;minimum_average&#39;</span><span class="p">]:</span>
                    <span class="n">cv_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                        <span class="n">cv_ref</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">cv_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;which is </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">cv_ref</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_ref</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cv_ref should be either &#39;global_minimum&#39;, &#39;minimum_average&#39; or a float value&quot;</span><span class="p">)</span>
                <span class="c1">#set ref</span>
                <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">icv</span><span class="p">]</span> <span class="o">-=</span> <span class="n">cv_ref</span>
    
    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_bins</span><span class="p">,</span> <span class="n">cv_bins</span><span class="p">,</span> <span class="n">error_estimate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_p_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Flag the process of adding simulation data as finished and process all samples to compute the conditional probability histograms.</span>

<span class="sd">            :param q_bins: see init_bins_grids</span>
<span class="sd">            :type q_bins: see init_bins_grids</span>

<span class="sd">            :param cv_bins: see init_bins_grids</span>
<span class="sd">            :type cv_bins: see init_bins_grids</span>

<span class="sd">            :param error_estimate: If not None, this will turn on error estimation an call the ``finish_error`` routine at then end. See ``finish_error`` routine for more information.</span>

<span class="sd">            :param error_p_threshold: Only relevant if error_estimate is not None. See ``finish_error`` routine for more information.</span>

<span class="sd">            :raises AssertionError: if attempting to finish the conditional probability that is already finished.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t finish current conditional probability as it has already been finished.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finishing conditional probability&#39;</span><span class="p">)</span>
        <span class="c1">#init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconds_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">histcounts_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">histnorms_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fishers_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#set grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_bins_grids</span><span class="p">(</span><span class="n">q_bins</span><span class="p">,</span> <span class="n">cv_bins</span><span class="p">)</span>

        <span class="c1">#loop over each simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span><span class="p">)</span>
        <span class="n">Htot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_q_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">Ntot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  constructing histograms for all simulations&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
            <span class="c1">#compute and store histograms from current simulations</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">H</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span><span class="p">)</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">cv_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">histcounts_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">histnorms_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="c1">#add histograms to global histogram</span>
            <span class="n">Ntot</span> <span class="o">+=</span> <span class="n">N</span>
            <span class="n">Htot</span> <span class="o">+=</span> <span class="n">H</span>
            <span class="c1">#compute and store corresponding conditional probability from current simulation</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">cv_index</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">cv_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span>
                    <span class="n">Ncurrent</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">invNcurrent</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncurrent</span>
                    <span class="k">else</span><span class="p">:</span>          <span class="n">invNcurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Ncurrent</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
                    <span class="n">invNcurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ncurrent</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">invNcurrent</span><span class="p">[</span><span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncurrent</span><span class="p">[</span><span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ps</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">+</span> <span class="n">cv_index</span> <span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">+</span> <span class="n">cv_index</span> <span class="p">]</span><span class="o">*</span><span class="n">invNcurrent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pconds_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  constructing global conditional probability&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Htot</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">cv_index</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">cv_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span>
                <span class="n">Ncurrent</span> <span class="o">=</span> <span class="n">Ntot</span><span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">invNcurrent</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncurrent</span>
                <span class="k">else</span><span class="p">:</span>          <span class="n">invNcurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ncurrent</span> <span class="o">=</span> <span class="n">Ntot</span><span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span>
                <span class="n">invNcurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ncurrent</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">invNcurrent</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncurrent</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">+</span> <span class="n">cv_index</span> <span class="p">]</span> <span class="o">=</span> <span class="n">Htot</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">+</span> <span class="n">cv_index</span> <span class="p">]</span><span class="o">*</span><span class="n">invNcurrent</span>

        <span class="c1">#define error bars based on Fisher matrix is implemented in inheriting classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">error_estimate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finish_error</span><span class="p">(</span><span class="n">error_estimate</span><span class="p">,</span> <span class="n">error_p_threshold</span><span class="o">=</span><span class="n">error_p_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span> <span class="o">=</span> <span class="kc">True</span>
        
    <span class="k">def</span> <span class="nf">finish_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_estimate</span><span class="p">,</span> <span class="n">error_p_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            This routine is not (yet) implemented in the most general case. Instead, it is (will be) implemented in the child classes.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Error estimation not yet implemented for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slicer</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obss</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">linestyles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">croplims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;rainbow&#39;</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Plot self.pconds[slicer], where slicer needs to be chosen such that self.pconds[slice] is 1D or 2D. The resulting graph will respectively by a regular 1D plot or 2D contourplot.</span>

<span class="sd">            :param fn: name of the file to store graph in, defaults to &#39;condprob.png&#39;</span>
<span class="sd">            :type fn: str, optional</span>

<span class="sd">            :param obss: Specify which statistical property/properties to plot. Multiple values are allowed, which will be plotted on the same figure. Following options are supported:</span>

<span class="sd">                - **value** - the values stored in self.pconds</span>
<span class="sd">                - **mean** - the mean according to the error distribution, i.e. self.error.mean()</span>
<span class="sd">                - **lower** - the lower limit of the 2-sigma error bar (which corresponds to a 95% confidence interval in case of a normal distribution), i.e. self.error.nsigma_conf_int(2)[0]</span>
<span class="sd">                - **upper** - the upper limit of the 2-sigma error bar (which corresponds to a 95% confidence interval in case of a normal distribution), i.e. self.error.nsigma_conf_int(2)[1]</span>
<span class="sd">                - **error** - half the width of the 2-sigma error bar (which corresponds to a 95% confidence interval in case of a normal distribution), i.e. abs(upper-lower)/2</span>
<span class="sd">                - **sample** - a random sample taken from the error distribution, i.e. self.error.sample()</span>
<span class="sd">            :type obss: list, optional, default=[&#39;value&#39;]</span>

<span class="sd">            :param linestyles: Specify the line style (using matplotlib definitions) for each quantity requested in ``obss``. If None, all linestyles are set to &#39;-&#39;</span>
<span class="sd">            :type linestyles: list or None, optional, default=None</span>

<span class="sd">            :param linewidths: Specify the line width (using matplotlib definitions) for each quantity requested in ``obss``. If None, al linewidths are set to 1</span>
<span class="sd">            :type linewidths: list of strings or None, optional, default=None</span>

<span class="sd">            :param colors: Specify the color (using matplotlib definitions) for each quantity requested in ``obss``. If None, matplotlib will choose.</span>
<span class="sd">            :type colors: list of strings or None, optional, default=None</span>

<span class="sd">            :param logscale: applying log scale to y-axis (in case of 1D plot) or color axis (in case of 2D plot), defaults to False</span>
<span class="sd">            :type logscale: bool, optional</span>

<span class="sd">            :param croplims: limits to the plotting range of the cv(s) in case of a 1D plot. If None, no cropping is done</span>
<span class="sd">            :type croplims: list, optional, default=None</span>

<span class="sd">            :param ylims: limits to the plotting range of the probability in case of a 1D plot. If None, no limits are enforced</span>
<span class="sd">            :type ylims: list, optional, default=None</span>

<span class="sd">            :param cmap: color map to be used, only relevant in case of 2D contourplot</span>
<span class="sd">            :type cmap: color map from matplotlib, optional, default=pp.get_cmap(&#39;rainbow&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#preprocess</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Conditional probability needs to be finished before plotting it.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slicer</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slicer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;slicer should be list or array, instead got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">slicer</span><span class="p">)</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="s1">&#39;slicer should be list of length equal to sum of number of Qs (whic is </span><span class="si">%i</span><span class="s1">) and number of CVs (which is </span><span class="si">%i</span><span class="s1">), instead got list of length </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">slicer</span><span class="p">))</span>
        <span class="c1">#read q slicer</span>
        <span class="n">iqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">qstring</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">):</span>
            <span class="n">qslicer</span> <span class="o">=</span> <span class="n">slicer</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qslicer</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">iqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iq</span><span class="p">)</span>
                <span class="n">qstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="n">iq</span><span class="p">])</span>
                <span class="n">q_label</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> [</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iq</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qslicer</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">qstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;q=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iq</span><span class="p">][</span><span class="n">qslicer</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Slicer list elements should be of type Slice or integer, instead got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">qslicer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">qstring</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span>
        <span class="c1">#read q slicer</span>
        <span class="n">icvs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cvstring</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cv_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">icv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">):</span>
            <span class="n">cvslicer</span> <span class="o">=</span> <span class="n">slicer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="o">+</span><span class="n">icv</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cvslicer</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">icvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">icv</span><span class="p">)</span>
                <span class="n">cvstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="n">icv</span><span class="p">])</span>
                <span class="n">cv_label</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> [</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="n">icv</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icv</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cvslicer</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">cvstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cv=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icv</span><span class="p">][</span><span class="n">cvslicer</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Slicer list elements should be of type Slice or integer, instead got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">cvslicer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">cvstring</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cvstring</span><span class="p">)</span>
        <span class="c1">#print(&#39;Q-slicer: &#39;, qstring)</span>
        <span class="c1">#print(&#39;CV-slicer: &#39;, cvstring)</span>

        <span class="c1">#read data </span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">obss</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()[</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">sample</span><span class="p">()[</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">slicer</span><span class="p">]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="n">slicer</span><span class="p">]</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not interpret observable </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">obs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ndim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">ndim</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="s1">&#39;Various observable data has inconsistent dimensions!&#39;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">),</span> <span class="s1">&#39;Inconsistency in sliced observable data for </span><span class="si">%s</span><span class="s1"> and detected number of Qs and CVs&#39;</span> <span class="o">%</span><span class="n">obs</span>
            <span class="c1">#crop if required</span>
            <span class="k">if</span> <span class="n">croplims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xs</span><span class="p">[</span><span class="n">xs</span><span class="o">&lt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">xs</span><span class="p">[</span><span class="n">xs</span><span class="o">&gt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1">#transform to logscale if required</span>
            <span class="k">if</span> <span class="n">logscale</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
            <span class="c1">#print(&#39;Retrieved data for %s with dimensions: %s&#39; %(obs, xs.shape))</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">lower</span><span class="p">[</span><span class="n">slicer</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">croplims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lower</span><span class="p">[</span><span class="n">lower</span><span class="o">&lt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">lower</span><span class="p">[</span><span class="n">lower</span><span class="o">&gt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">upper</span><span class="p">[</span><span class="n">upper</span><span class="o">&lt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">upper</span><span class="p">[</span><span class="n">upper</span><span class="o">&gt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">logscale</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linestyles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1">#make plot</span>
        <span class="c1">#print(&#39;Making %i-dimensional plot (icvs=%i,iqs=%i)&#39; %(ndim,len(icvs),len(iqs)))</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Inconsistency in shape of sliced q and cv data!&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">linestyle</span><span class="p">,</span><span class="n">linewidth</span><span class="p">,</span><span class="n">color</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">,</span><span class="n">colors</span><span class="p">):</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.33</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">q_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cv_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">q_label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">q_label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cv_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">cv_label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Something went wrong in trying to determine the correct plot labels.&#39;</span><span class="p">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Conditional probability p(</span><span class="si">%s</span><span class="s1">;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">qstring</span><span class="p">,</span><span class="n">cvstring</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ylims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylims</span><span class="p">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">do_ij_to_xz_indexing</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">do_ij_to_xz_indexing</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">do_ij_to_xz_indexing</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Inconsistency in shape of sliced q and cv data!&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">8</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">24</span><span class="p">,</span><span class="mi">8</span><span class="o">*</span><span class="n">nrows</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">axs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">do_ij_to_xz_indexing</span><span class="p">:</span>
                    <span class="n">contourf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span> <span class="c1">#transpose data to convert ij indexing (internal) to xy indexing (for plotting)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">contourf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">cv_label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">q_label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> p(</span><span class="si">%s</span><span class="s1">;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">qstring</span><span class="p">,</span><span class="n">cvstring</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contourf</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only plot 1D or 2D pcond data, but received </span><span class="si">%i</span><span class="s1">-d data. Make sure that the combination of qslice and cvslice results in 1 or 2 dimensional data.&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span>




<div class="viewcode-block" id="ConditionalProbability1D1D"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D">[docs]</a><span class="k">class</span> <span class="nc">ConditionalProbability1D1D</span><span class="p">(</span><span class="n">ConditionalProbability</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Class to compute and store conditional probabilities of the form :math:`p(q|cv)` which allow to convert a free energy profile in terms of the collective variable :math:`cv` to a free energy profile in terms of the collective variable :math:`q`.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_label</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="n">cv_label</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">q_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param q_bins: np.histogram argument for defining the bins of Q samples</span>
<span class="sd">            :type q_bins: see np.histogram and np.histogram2d, optional</span>

<span class="sd">            :param cv_bins: np.histogram argument for defining the bins of CV samples</span>
<span class="sd">            :type cv_bins: see np.histogram and np.histogram2d, optional</span>

<span class="sd">            :param q_label: label for Q used for plotting/logging, defaults to &#39;Q&#39;</span>
<span class="sd">            :type q_label: str, optional</span>
<span class="sd">            </span>
<span class="sd">            :param cv_label: label for Q used for plotting/logging, defaults to &#39;CV&#39;</span>
<span class="sd">            :type cv_label: str, optional</span>

<span class="sd">            :param verbose: make all class routines more verbose in their logging</span>
<span class="sd">            :type verbose: bool, optional, default=False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ConditionalProbability</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q_labels</span><span class="o">=</span><span class="p">[</span><span class="n">q_label</span><span class="p">],</span> <span class="n">cv_labels</span><span class="o">=</span><span class="p">[</span><span class="n">cv_label</span><span class="p">],</span> <span class="n">q_units</span><span class="o">=</span><span class="p">[</span><span class="n">q_output_unit</span><span class="p">],</span> <span class="n">cv_units</span><span class="o">=</span><span class="p">[</span><span class="n">cv_output_unit</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="ConditionalProbability1D1D.process_trajectory_xyz"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.process_trajectory_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">process_trajectory_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">CV</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Included for backwards compatibility , this routine will call the more general process_trajectory routine of the parent class.</span>

<span class="sd">            .. warning:: </span>
<span class="sd">            </span>
<span class="sd">                It is no longer possible to finish automatically after processing a trajectory. Finishing must alwasy be done manually by calling the finish routine!</span>

<span class="sd">            Extract Q and CV samples from the given XYZ trajectories. These samples will later be utilized by the finish routine to construct the conditional probability. The trajectory files may also contain data from simulations that are biased in CV space (not Q space!!).</span>

<span class="sd">            :param fns: file name (or list of file names) which contain trajectories that are used to compute the conditional probability.</span>
<span class="sd">            :type fns: str or list(str)</span>

<span class="sd">            :param Q: collective variable used to compute the CV value from a trajectory file</span>
<span class="sd">            :type Q: CollectiveVariable</span>

<span class="sd">            :param CV: collective variable used to compute the CV value from a trajectory file</span>
<span class="sd">            :type CV: CollectiveVariable</span>

<span class="sd">            :param sub: python slice instance to subsample the trajectory</span>
<span class="sd">            :type sub: slice, optional, default=slice(None, None, None)</span>

<span class="sd">            :param verbose: set to True to increase verbosity of the CVComputer to compute CV values from the trajectories</span>
<span class="sd">            :type verbose: bool, optional, default=False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cv_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">CV</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">q_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">Q</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_simulation</span><span class="p">([(</span><span class="n">fn</span><span class="p">,</span> <span class="n">q_reader</span> <span class="p">)],</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span> <span class="n">cv_reader</span><span class="p">)])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D1D.process_trajectory_cvs"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.process_trajectory_cvs">[docs]</a>    <span class="k">def</span> <span class="nf">process_trajectory_cvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">col_q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">col_cv</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> <span class="n">unit_q</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">unit_cv</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Included for backwards compatibility, this routine will call the more general process_trajectory routine of the parent class. </span>
<span class="sd">            </span>
<span class="sd">            .. warning:: </span>
<span class="sd">            </span>
<span class="sd">                It is no longer possible to finish automatically after processing a trajectory. Finishing must alwasy be done manually by calling the finish routine!</span>

<span class="sd">            Extract Q and CV samples from the given COLVAR trajectories. These samples will later be utilized by the finish routine to construct the conditional probability. The trajectory files may also contain data from simulations that are biased in CV space (not Q space!!). Each CV trajectory file contains rows of the form</span>

<span class="sd">                time q cv</span>

<span class="sd">            If the trajectory file contains this data in a different order, it can be accounted for using the col_xx keyword arguments.</span>

<span class="sd">            :param fns: file name (or list of file names) of colvar files with the above formatting containing the trajectory data.</span>
<span class="sd">            :type fns: str or list(str)</span>

<span class="sd">            :param col_q: column index of the collective variable Q in the given input file</span>
<span class="sd">            :type col_q: int, optional, default=1</span>

<span class="sd">            :param col_cv: column index of the collective variable CV in the given input file</span>
<span class="sd">            :type col_cv: int, optional, default=2</span>

<span class="sd">            :param unit_q: unit in which the q values are stored in the file</span>
<span class="sd">            :type unit_q: str, optional, default=&#39;au&#39;</span>

<span class="sd">            :param unit_cv: unit in which the cv values are stored in the file</span>
<span class="sd">            :type unit_cv: str, optional, default=&#39;au&#39;</span>
<span class="sd">            </span>
<span class="sd">            :param sub: python slice instance to subsample the trajectory</span>
<span class="sd">            :type sub: slice, optional, default=slice(None, None, None)</span>

<span class="sd">            :param verbose: set to True to increase verbosity of the ColVarReader when reading samples from the trajectory files.</span>
<span class="sd">            :type verbose: bool, optional, default=False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">q_reader</span>  <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_q</span><span class="p">]</span> <span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_q</span><span class="p">]</span> <span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span> <span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">cv_reader</span> <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_cv</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_cv</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_simulation</span><span class="p">([(</span><span class="n">fn</span><span class="p">,</span> <span class="n">q_reader</span> <span class="p">)],</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span> <span class="n">cv_reader</span><span class="p">)])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D1D.finish_error"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.finish_error">[docs]</a>    <span class="k">def</span> <span class="nf">finish_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_estimate</span><span class="p">,</span> <span class="n">error_p_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Estimate error bars on the conditional probability. This routine will be called by the ``finish`` routine if the error_estimate keyword parsed there is not None.</span>

<span class="sd">            :param error_estimate: indicate if and how to perform error analysis. One of following options is available:</span>

<span class="sd">				- **mle_p** - Estimating the error directly for the probability of each bin in the histogram. This method does not explicitly impose the positivity of the probability.</span>

<span class="sd">				- **mle_p_cov** - Estimate the full covariance matrix for the probability of all bins in the histogram. In other words, appart from the error on the probability/free energy of a bin itself, we now also account for the covariance between the probabilty/free energy of the bins. This method does not explicitly impose the positivity of the probability.</span>

<span class="sd">				- **mle_f** - Estimating the error for minus the logarithm of the probability, which is proportional to the free energy (hence f in mle_f). As the probability is expressed as :math:`\propto e^{-f}`, its positivity is explicitly accounted for.</span>

<span class="sd">				- **mle_f_cov** - Estimate the full covariance matrix for minus the logarithm of the probability of all bins in the histogram. In other words, appart from the error on the probabilty/free energy of a bin itself (including explicit positivity constraint), we now also account for the covariance between the probability/free energy of the bins.</span>

<span class="sd">			:type error_estimate: str</span>

<span class="sd">            :param error_p_threshold: When ``error_p_threshold`` is set to x, bins in the histogram for which the probability resulting from the trajectory is smaller than x will be disabled for error estimation (i.e. its error will be set to np.nan).</span>
<span class="sd">			:type error_p_threshold: float, optional, default=0.0</span>

<span class="sd">            :raises ValueError: if an invalid definition for error_estimate is provided</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  computing Fisher matrices for each simulation&#39;</span><span class="p">)</span>
        <span class="n">Ngrid_q</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1">#extra [0] because only 1 Q and then self.q_grid=[np.ndarray(...)]</span>
        <span class="c1">#loop over each simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
            <span class="c1">#compute and store contribution to fisher matrix from current simulation as well as add contribution to global fisher matrix</span>
            <span class="n">Is</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cv_index</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1">#if self.verbose: print(&#39;    for simulation %i cv[%s]=%.3f&#39; %(isim,str(cv_index),cv))</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">fisher_matrix_mle_probdens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pconds_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">cv_index</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">error_estimate</span><span class="p">)</span>
                <span class="n">Is</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">histnorms_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][</span><span class="n">cv_index</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fisher</span><span class="p">[:,:,</span><span class="n">cv_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span><span class="o">*</span><span class="n">I</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fishers_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Is</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  extracting error for conditional probability&#39;</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cv_index</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">[:,</span><span class="n">cv_index</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">invert_fisher_to_covariance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher</span><span class="p">[:,:,</span><span class="n">cv_index</span><span class="p">],</span> <span class="n">ps</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">error_p_threshold</span><span class="p">)[:</span><span class="n">Ngrid_q</span><span class="p">,:</span><span class="n">Ngrid_q</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">error_estimate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_p&#39;</span><span class="p">]:</span>
                <span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">stds</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">error_estimate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_p_cov&#39;</span><span class="p">]:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">MultiGaussianDistribution</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">error_estimate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_f&#39;</span><span class="p">]:</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
                <span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">LogGaussianDistribution</span><span class="p">(</span><span class="o">-</span><span class="n">fs</span><span class="p">,</span> <span class="n">stds</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">error_estimate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_f_cov&#39;</span><span class="p">]:</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">MultiLogGaussianDistribution</span><span class="p">(</span><span class="o">-</span><span class="n">fs</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error estimation method </span><span class="si">%s</span><span class="s1"> not supported&#39;</span> <span class="o">%</span><span class="n">error_estimate</span><span class="p">)</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">ErrorArray</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConditionalProbability1D1D.average"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.average">[docs]</a>    <span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_distribution</span><span class="o">=</span><span class="n">MultiGaussianDistribution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute the average of Q as function of CV</span>

<span class="sd">            :param error_distribution: the model for the error distribution of Q profile</span>
<span class="sd">            :type error_distribution: class from :py:mod:`error &lt;thermolib.error&gt;` module, optional, default= :py:class:`MultiGaussianDistribution &lt;thermolib.error.MultiGaussianDistribution&gt;`</span>

<span class="sd">            :returns: Q profile as function of CV</span>
<span class="sd">            :rtype: :py:class:`BaseProfile &lt;thermolib.thermodynamics.fep.BaseProfile&gt;`</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">pconds</span><span class="p">):</span>
            <span class="n">qs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,:])</span>
                <span class="n">qs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>   <span class="o">+=</span> <span class="n">q</span><span class="o">*</span><span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span>   <span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">qs</span><span class="p">[</span><span class="n">norm</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1">#normalization in case pconds would not be normalized along second axis</span>
            <span class="n">qs</span><span class="p">[</span><span class="n">norm</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">[</span><span class="n">norm</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">qs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">()</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">,</span> <span class="n">samples_are_flattened</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BaseProfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cv_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D1D.transform"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fep</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_output_class</span><span class="o">=</span><span class="n">BaseFreeEnergyProfile</span><span class="p">,</span> <span class="n">error_distribution</span><span class="o">=</span><span class="n">MultiGaussianDistribution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Transform the provided 1D FES to a different 1D FES using the current conditional probability according to the formula. </span>

<span class="sd">            .. math:: F(q) &amp;= -kT \\ln\\left(\\int p(q|v)\\cdot e^{-\\beta F(v)} dv\\right)</span>
<span class="sd">            </span>
<span class="sd">            :param fep: the input free energy profile F(cv) which will be transformed towards F(q)</span>
<span class="sd">            :type fep: :py:class:`BaseFreeEnergyProfile &lt;thermolib.thermodynamics.fep.BaseFreeEnergyProfile&gt;`</span>

<span class="sd">            :param f_output_unit: the unit of the transformed free energy profile to be used in plotting and printing of energies. If None, the f_output_unit of the original free energy profile will be used.</span>
<span class="sd">            :type f_output_unit: str, optional, default=None</span>

<span class="sd">            :param f_label: the label of the transformed free energy profile to be used in plotting and printing. If None, the f_label of the original free energy profile will be used.</span>
<span class="sd">            :type f_output_unit: str, optional, default=None</span>

<span class="sd">            :param f_output_class: the class of the output free energy profile. If you want to use specific features of the :py:class:`SimpleFreeEnergyProfile &lt;thermolib.thermodynamics.fep.SimpleFreeEnergyProfile&gt;` class (such as e.g. automatic detection of reactant, transition state and product state micro/macrostates) in the transformed fep, define this argument as :py:class:`SimpleFreeEnergyProfile &lt;thermolib.thermodynamics.fep.SimpleFreeEnergyProfile&gt;`.</span>
<span class="sd">            :type f_output_class: class, optional, default= :py:class:`BaseFreeEnergyProfile &lt;thermolib.thermodynamics.fep.BaseFreeEnergyProfile&gt;`</span>

<span class="sd">            :param error_distribution: the model for the error distribution of Q profile</span>
<span class="sd">            :type error_distribution: class from :py:mod:`error &lt;thermolib.error&gt;` module, optional, default= :py:class:`MultiGaussianDistribution &lt;thermolib.error.MultiGaussianDistribution&gt;`</span>

<span class="sd">            :raises AssertionError: if the conditional probability has not been finished yetµ</span>
<span class="sd">            :raises AssertionError: if the fep argument is not a :py:class:`BaseFreeEnergyProfile &lt;thermolib.thermodynamics.fep.BaseFreeEnergyProfile&gt;`</span>
<span class="sd">            :raises AssertionError: if the cv grids in self.cvs[0] and fep.cvs are not consistent</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#consistency checks and initalization</span>
        <span class="n">qs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Conditional probability needs to be finished before applying at in transformations.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fep</span><span class="p">,</span> <span class="n">BaseFreeEnergyProfile</span><span class="p">),</span> <span class="s1">&#39;Input argument should be instance of (child of) BaseFreeEnergyProfile, instead received </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">fep</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">),</span> <span class="s1">&#39;Dimension of 1D CV in conditional probability inconsistent with 1D FEP&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="o">-</span><span class="n">cvs</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Values of 1D CV in conditional probability not identical to those of 1D FEP&#39;</span>
        <span class="k">if</span> <span class="n">f_output_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_output_unit</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_output_unit</span>
        <span class="k">if</span> <span class="n">f_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_label</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_label</span>
        <span class="c1"># Construct 1D FEP</span>
        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pconds</span><span class="p">[:,</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fep</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="n">fs</span><span class="p">[</span><span class="n">mask</span><span class="p">]),</span> <span class="n">x</span><span class="o">=</span><span class="n">cvs</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">ps</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">qs</span><span class="p">)</span>
            <span class="n">fs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">)],</span> <span class="nb">float</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">fs_new</span><span class="p">[</span><span class="n">ps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">ps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">fep</span><span class="o">.</span><span class="n">beta</span>
            <span class="k">return</span> <span class="n">fs_new</span>
        <span class="k">if</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">ncycles</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transf1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">fs</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transf1</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">ncycles</span><span class="p">)</span>
            <span class="n">transf2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">pconds</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transf2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">f_output_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="n">f_output_unit</span><span class="p">,</span> <span class="n">cv_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_label</span><span class="o">=</span><span class="n">f_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConditionalProbability1D1D.deproject"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.deproject">[docs]</a>    <span class="k">def</span> <span class="nf">deproject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fep</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_output_class</span><span class="o">=</span><span class="n">FreeEnergySurface2D</span><span class="p">,</span> <span class="n">error_distribution</span><span class="o">=</span><span class="n">MultiGaussianDistribution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Deproject the provided 1D FEP F(q) to a 2D FES F(q,v) using the current conditional probability according to the formula</span>

<span class="sd">            .. math:: F(q_1,q_2) &amp;= F(q_2)-kT \\ln\\left(p(q_1|q_2)\\right)</span>

<span class="sd">            :param fep: the free energy profile F(q_2) which will be transformed</span>
<span class="sd">            :type fep: (child of) BaseFreeEnergyProfile</span>

<span class="sd">            :param f_output_unit: the unit of the deprojected free energy profile to be used in plotting and printing of energies. If None, the f_output_unit of the original 1D free energy profile will be used.</span>
<span class="sd">            :type f_output_unit: str, optional, default=None</span>

<span class="sd">            :param f_label: the label of the deprojected free energy profile to be used in plotting and printing. If None, the f_label of the original 1D free energy profile will be used.</span>
<span class="sd">            :type f_label: str, optional, default=None</span>

<span class="sd">            :param f_output_class: the class of the output free energy profile, defaults to FreeEnergySurface2D</span>
<span class="sd">            :type f_output_class: class, optional</span>

<span class="sd">            :param error_distribution: the model for the error distribution of Q profile</span>
<span class="sd">            :type error_distribution: class from :py:mod:`error &lt;thermolib.error&gt;` module, optional, default= :py:class:`MultiGaussianDistribution &lt;thermolib.error.MultiGaussianDistribution&gt;`</span>

<span class="sd">            :raises AssertionError: if the conditional probability has not been finished yetµ</span>
<span class="sd">            :raises AssertionError: if the fep argument is not a :py:class:`BaseFreeEnergyProfile &lt;thermolib.thermodynamics.fep.BaseFreeEnergyProfile&gt;`</span>
<span class="sd">            :raises AssertionError: if the cv grids in self.cvs[0] and fep.cvs are not consistent</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#consistency checks and initalization</span>
        <span class="n">qs</span><span class="p">,</span> <span class="n">cvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Conditional probability needs to be finished before applying at in transformations.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fep</span><span class="p">,</span> <span class="n">BaseFreeEnergyProfile</span><span class="p">),</span> <span class="s1">&#39;Input argument should be instance of (child of) BaseFreeEnergyProfile, instead received </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">fep</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">),</span> <span class="s1">&#39;Dimension of collective variable v in conditional probability p(q|v) inconsistent with collective variable in 1D FEP&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="o">-</span><span class="n">cvs</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Values of collective variable v in conditional probability p(q|v) not identical to those of collective variable in 1D FEP&#39;</span>
        <span class="k">if</span> <span class="n">f_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_label</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_label</span>
        <span class="k">if</span> <span class="n">f_output_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_output_unit</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_output_unit</span>
        <span class="c1"># Construct 2D FES</span>
        <span class="n">kT</span> <span class="o">=</span> <span class="n">boltzmann</span><span class="o">*</span><span class="n">fep</span><span class="o">.</span><span class="n">T</span>
        <span class="k">def</span> <span class="nf">deproject</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">):</span>
            <span class="n">fs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">)],</span> <span class="nb">float</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">icv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">)):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pconds</span><span class="p">[:,</span><span class="n">icv</span><span class="p">])</span>
                <span class="n">pconds</span><span class="p">[:,</span><span class="n">icv</span><span class="p">]</span> <span class="o">/=</span> <span class="n">pconds</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1">#assert pcond is proparly normalized (in case it was sampled from error distribution)</span>
                <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">fs_new</span><span class="p">[</span><span class="n">icv</span><span class="p">,</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="n">icv</span><span class="p">]</span> <span class="o">-</span> <span class="n">kT</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="n">icv</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">fs_new</span>
        <span class="k">if</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="n">ncycles_default</span><span class="p">)</span>
            <span class="n">flattener</span> <span class="o">=</span> <span class="n">Flattener</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">deproject</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">deproj1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">fs</span><span class="p">:</span> <span class="n">deproject</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">deproj1</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">deproj2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">pconds</span><span class="p">:</span> <span class="n">deproject</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">)</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">deproj2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">deproject</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">f_output_class</span><span class="p">(</span><span class="n">cvs</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">cv1_output_unit</span><span class="o">=</span><span class="n">fep</span><span class="o">.</span><span class="n">cv_output_unit</span><span class="p">,</span> <span class="n">cv2_output_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="n">f_output_unit</span><span class="p">,</span> <span class="n">cv1_label</span><span class="o">=</span><span class="n">fep</span><span class="o">.</span><span class="n">cv_label</span><span class="p">,</span> <span class="n">cv2_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_label</span><span class="o">=</span><span class="n">f_label</span><span class="p">)</span></div></div>




<div class="viewcode-block" id="ConditionalProbability1D2D"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D">[docs]</a><span class="k">class</span> <span class="nc">ConditionalProbability1D2D</span><span class="p">(</span><span class="n">ConditionalProbability</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Class to store and compute conditional probabilities of the form :math:`p(q_1,q_2|cv)` which can be used to transform a 1D free energy profile in terms of the collective variable :math:`cv` towards a 2D free energy surface in terms of the collective variables :math:`q_1` and :math:`q_2`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q1_label</span><span class="o">=</span><span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="n">q2_label</span><span class="o">=</span><span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="n">cv_label</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">q1_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">q2_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param q1_label: label for Q1 used for plotting/logging</span>
<span class="sd">            :type q1_label: str, optional, default=&#39;Q1&#39;</span>

<span class="sd">            :param q2_label: label for Q2 used for plotting/logging</span>
<span class="sd">            :type q2_label: str, optional, default=&#39;Q2&#39;</span>
<span class="sd">            </span>
<span class="sd">            :param cv_label: label for Q used for plotting/logging</span>
<span class="sd">            :type cv_label: str, optional, default=&#39;CV&#39;</span>

<span class="sd">            :param verbose: set to True to increase verbosity of TrajectoryReaders used to compute the various CV samples along an XYZ trajectory</span>
<span class="sd">            :type verbose: bool, optional, default=False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ConditionalProbability</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q_labels</span><span class="o">=</span><span class="p">[</span><span class="n">q1_label</span><span class="p">,</span><span class="n">q2_label</span><span class="p">],</span> <span class="n">cv_labels</span><span class="o">=</span><span class="p">[</span><span class="n">cv_label</span><span class="p">],</span> <span class="n">q_units</span><span class="o">=</span><span class="p">[</span><span class="n">q1_output_unit</span><span class="p">,</span><span class="n">q2_output_unit</span><span class="p">],</span> <span class="n">cv_units</span><span class="o">=</span><span class="p">[</span><span class="n">cv_output_unit</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="ConditionalProbability1D2D.process_trajectory_xyz"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D.process_trajectory_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">process_trajectory_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">,</span> <span class="n">CV</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Included for backwards compatibility, this routine will call the more general process_trajectory routine of the parent class.</span>

<span class="sd">            Extract Q1, Q2 and CV samples from the given XYZ trajectories. These samples will later be utilized by the finish routine to construct the conditional probability. The trajectory files may also contain data from simulations that are biased in CV space (not Q1/Q2 space!!).</span>

<span class="sd">            :param fns: file name (or list of file names) which contain trajectories that are used to compute the conditional probability.</span>
<span class="sd">            :type fns: str or list(str)</span>

<span class="sd">            :param Q1: collective variable used to compute the Q1 value from a trajectory file</span>
<span class="sd">            :type Q1: :py:class:`CollectiveVariable &lt;thermolib.thermodynamics.cv.CollectiveVariable&gt;`</span>

<span class="sd">            :param Q2: collective variable used to compute the Q2 value from a trajectory file</span>
<span class="sd">            :type Q2: :py:class:`CollectiveVariable &lt;thermolib.thermodynamics.cv.CollectiveVariable&gt;`</span>

<span class="sd">            :param CV: collective variable used to compute the CV value from a trajectory file</span>
<span class="sd">            :type CV: :py:class:`CollectiveVariable &lt;thermolib.thermodynamics.cv.CollectiveVariable&gt;`</span>

<span class="sd">            :param sub: python slice instance to subsample the trajectory</span>
<span class="sd">            :type sub: slice, optional, default=slice(None, None, None)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cv_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">CV</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">q1_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">Q1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">q2_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">Q2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_simulation</span><span class="p">([(</span><span class="n">fn</span><span class="p">,</span><span class="n">q1_reader</span><span class="p">),</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">q2_reader</span><span class="p">)],</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span><span class="n">cv_reader</span><span class="p">)])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D2D.process_trajectory_cvs"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D.process_trajectory_cvs">[docs]</a>    <span class="k">def</span> <span class="nf">process_trajectory_cvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">col_q1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">col_q2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">col_cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">unit_q1</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">unit_q2</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">unit_cv</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Included for backwards compatibility, this routine will call the more general process_trajectory routine of the parent class.</span>

<span class="sd">            Extract Q and CV samples from the given COLVAR trajectories. These samples will later be utilized by the finish routine to construct the conditional probability. The trajectory files may also contain data from simulations that are biased in CV space (not Q space!!). Each CV trajectory file contains rows of the form</span>

<span class="sd">                time q1 q2 cv</span>

<span class="sd">            If the trajectory file contains this data in a different order, it can be accounted for using the col_xx keyword arguments.</span>

<span class="sd">            :param fns: file name (or list of file names) of colvar files with the above formatting containing the trajectory data.</span>
<span class="sd">            :type fns: str or list(str)</span>

<span class="sd">            :param col_q1: column index of the collective variable Q1 in the given input file</span>
<span class="sd">            :type col_q1: int, optional, default=1</span>

<span class="sd">            :param col_q2: column index of the collective variable Q2 in the given input file</span>
<span class="sd">            :type col_q2: int, optional, defaults=2</span>

<span class="sd">            :param col_cv: column index of the collective variable CV in the given input file</span>
<span class="sd">            :type col_cv: int, optional, default=3</span>

<span class="sd">            :param unit_q1: unit in which the q1 values are stored in the file</span>
<span class="sd">            :type unit_q1: str, optional, default=&#39;au&#39;</span>

<span class="sd">            :param unit_q2: unit in which the q2 values are stored in the file</span>
<span class="sd">            :type unit_q2: str, optional, default=&#39;au&#39;</span>

<span class="sd">            :param unit_cv: unit in which the cv values are stored in the file</span>
<span class="sd">            :type unit_cv: str, optional, default=&#39;au&#39;</span>
<span class="sd">            </span>
<span class="sd">            :param sub: python slice instance to subsample the trajectory</span>
<span class="sd">            :type sub: slice, optional, default=slice(None, None, None)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">q1_reader</span>  <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_q1</span><span class="p">]</span> <span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_q1</span><span class="p">]</span> <span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Q1&#39;</span> <span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">q2_reader</span>  <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_q2</span><span class="p">]</span> <span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_q2</span><span class="p">]</span> <span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Q2&#39;</span> <span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">cv_reader</span> <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_cv</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_cv</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_simulation</span><span class="p">([(</span><span class="n">fn</span><span class="p">,</span><span class="n">q1_reader</span><span class="p">),</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">q2_reader</span><span class="p">)],</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span><span class="n">cv_reader</span><span class="p">)])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D2D.deproject"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D.deproject">[docs]</a>    <span class="k">def</span> <span class="nf">deproject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fep</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_output_class</span><span class="o">=</span><span class="n">FreeEnergySurface2D</span><span class="p">,</span> <span class="n">error_distribution</span><span class="o">=</span><span class="n">MultiGaussianDistribution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Transform the provided 1D FEP to a 2D FES using the current conditional probability according to the formula</span>

<span class="sd">            .. math:: F(q_1,q_2) &amp;= -kT\cdot\\ln\\left(\\int p(q_1,q_2|v)\\cdot e^{-\\beta F(v)}dv\\right)</span>

<span class="sd">            :param fep: the input free energy profile F(cv) which will be transformed towards F(q)</span>
<span class="sd">            :type fep: BaseFreeEnergyProfile or child classes</span>

<span class="sd">            :param f_output_unit: the unit of the deprojected free energy profile to be used in plotting and printing of energies. If None, the f_output_unit of the original 1D free energy profile will be used.</span>
<span class="sd">            :type f_output_unit: str, optional, default=None</span>

<span class="sd">            :param f_label: the label of the deprojected free energy profile to be used in plotting and printing. If None, the f_label of the original 1D free energy profile will be used.</span>
<span class="sd">            :type f_label: str, optional, default=None</span>

<span class="sd">            :param f_output_class: the class of the output free energy profile, defaults to FreeEnergySurface2D</span>
<span class="sd">            :type f_output_class: class, optional</span>

<span class="sd">            :param error_distribution: the model for the error distribution of Q profile</span>
<span class="sd">            :type error_distribution: class from :py:mod:`error &lt;thermolib.error&gt;` module, optional, default= :py:class:`MultiGaussianDistribution &lt;thermolib.error.MultiGaussianDistribution&gt;`</span>

<span class="sd">            :raises AssertionError: if the conditional probability has not been finished yetµ</span>
<span class="sd">            :raises AssertionError: if the fep argument is not a :py:class:`BaseFreeEnergyProfile &lt;thermolib.thermodynamics.fep.BaseFreeEnergyProfile&gt;`</span>
<span class="sd">            :raises AssertionError: if the cv grids in self.cvs[0] and fep.cvs are not consistent</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#consistency checks and initalization</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Conditional probability needs to be finished before applying at in transformations.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fep</span><span class="p">,</span> <span class="n">BaseFreeEnergyProfile</span><span class="p">),</span> <span class="s1">&#39;Input argument should be instance of (child of) BaseFreeEnergyProfile, instead received </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">fep</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;Dimension of 1D CV in conditional probability inconsistent with 1D FEP&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Values of 1D CV in conditional probability not identical to those of 1D FEP&#39;</span>
        <span class="k">if</span> <span class="n">f_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_label</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_label</span>
        <span class="k">if</span> <span class="n">f_output_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_output_unit</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_output_unit</span>
        <span class="c1">#construct 2D FES</span>
        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pconds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fep</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="n">fs</span><span class="p">[</span><span class="n">mask</span><span class="p">]),</span> <span class="n">x</span><span class="o">=</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">ps</span> <span class="o">/=</span> <span class="n">integrate2d</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">fs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">fs_new</span><span class="p">[</span><span class="n">ps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">ps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">fep</span><span class="o">.</span><span class="n">beta</span>
            <span class="k">return</span> <span class="n">fs_new</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="n">ncycles_default</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transf1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">fs</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transf1</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="n">ncycles_default</span><span class="p">)</span>
            <span class="n">transf2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">pconds</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transf2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f_output_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">cv1_output_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cv2_output_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="n">f_output_unit</span><span class="p">,</span> <span class="n">cv1_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cv2_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f_label</span><span class="o">=</span><span class="n">f_label</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Louis Vanduyfhuys.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>