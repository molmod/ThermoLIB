<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>thermolib.tools &mdash; ThermoLIB v1.7.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=131c94de"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ThermoLIB
              <img src="../../_static/logo_thermolib_light.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ig.html">Installation Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ig.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ig.html#download-and-install-thermolib">Download and install ThermoLIB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ig.html#direct-install-using-pip">Direct install using pip</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ig.html#developers-download">Developers download</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ig.html#update-thermolib">Update ThermoLIB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ig.html#test-installation">Test installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../ug.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ug_1DFEP.html">Constructing 1D histograms &amp; free energy profiles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_1DFEP.html#construct-a-1d-histrogam">Construct a 1D histrogam …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#from-a-single-simulation">… from a single simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#from-multiple-simulations-using-wham">… from multiple simulations using WHAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_1DFEP.html#constructing-a-1d-free-energy-profile">Constructing a 1D free energy profile …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#using-the-constructor">… using the constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#reading-from-a-text-file">… reading from a text file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_1DFEP.html#from-a-histogram">… from a histogram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_2DFES.html">Constructing 2D histograms &amp; free energy surfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_2DFES.html#constructing-a-2d-histogram">Constructing a 2D histogram …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#from-single-simulation">… from single simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#from-multiple-simulations-using-wham">… from multiple simulations using WHAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_2DFES.html#constructing-a-2d-free-energy-surface">Constructing a 2D free energy surface …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#using-the-constructor">… using the constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#reading-from-a-text-file">… reading from a text file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_2DFES.html#from-a-histogram">… from a histogram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_corrtime.html">Computing the correlation time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_corrtime.html#fit-to-autocorrelation-function-for-single-trajectory">Fit to autocorrelation function for single trajectory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_corrtime.html#compute-correlation-time-for-trajectory-series">Compute correlation time for trajectory series</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_error.html">Error estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_error.html#without-correlations">Without correlations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_error.html#with-correlations">With correlations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_plotting.html">Plotting histograms and FEP/FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_plotting.html#d-histograms-free-energy-profile">1D Histograms &amp; free energy profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_plotting.html#d-histograms-free-energy-surfaces">2D Histograms &amp; free energy surfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_micromacro.html">Extracting micro- and macrostate free energy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_kinetics.html">Computing the reaction rate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_transformation.html">Transformations of the FEP/FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_transformation.html#deterministic-transformation">Deterministic transformation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../ug_transformation.html#dimensional">1 dimensional</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../ug_transformation.html#id1">2 dimensional</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_transformation.html#probabilistic-transformation">Probabilistic transformation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ug_projection.html">(De)projections of the FEP/FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ug_projection.html#projecting-2d-fes-to-1d-fep">Projecting 2D FES to 1D FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ug_projection.html#deprojecting-1d-fep-to-2d-fes">Deprojecting 1D FEP to 2D FES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tut/basic_wham1d.html">Tutorial 1 - Construction of 1D free energy profile using WHAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham1d.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham1d.html#WHAM-without-error-estimation">WHAM without error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham1d.html#WHAM-with-error-estimation">WHAM with error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham1d.html#Defining-macrostates-and-microstates">Defining macrostates and microstates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/basic_kinetics.html">Tutorial 2 - Extracting kinetic reaction rates in 1D</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_kinetics.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_kinetics.html#Construct-free-energy-profile">Construct free energy profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_kinetics.html#Compute-rate-prefactor">Compute rate prefactor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_kinetics.html#Add-kinetic-information-to-FEP-plot">Add kinetic information to FEP plot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/basic_wham2d.html">Tutorial 3 - Construction of 2D free energy surface using WHAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham2d.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham2d.html#2D-WHAM-without-error-estimation">2D WHAM without error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham2d.html#2D-WHAM-with-error-estimate">2D WHAM with error estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/basic_wham2d.html#Alternative-plotting">Alternative plotting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_error_estimation.html">Tutorial 4 - Advanced techniques in error estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Impact-correlation-between-samples-on-FEP">Impact correlation between samples on FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Estimating-the-autocorrelation-time">Estimating the autocorrelation time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Constructing-the-FEP-with-correlated-error-estimate">Constructing the FEP with correlated error estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Evaluating-the-correlated-error-estimate">Evaluating the correlated error estimate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Delayed-strided-WHAM-profiles">Delayed-strided WHAM profiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Blocked-WHAM-profile">Blocked WHAM profile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Bootstrapped-WHAM-profiles">Bootstrapped WHAM profiles</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Covariance-between-different-points-on-FEP">Covariance between different points on FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_error_estimation.html#Error-propagation">Error propagation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_projection.html">Tutorial 5 - Projection of 2D FES to 1D FEP with error propagation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_projection.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_projection.html#Constructing-2D-FES">Constructing 2D FES</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_projection.html#Projection-onto-1D-profile">Projection onto 1D profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_projection.html#Along-predefined-direction">Along predefined direction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_projection.html#Along-any-custom-direction">Along any custom direction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_projection.html#Error-propagation">Error propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_projection.html#Deal-with-the-unsufficiently-sampled-edges-of-phase-space-in-FES-projection">Deal with the unsufficiently sampled edges of phase space in FES projection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_deprojection.html">Tutorial 6 - Deprojecting 1D FEP to 2D FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_deprojection.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_deprojection.html#Construct-1D-FEP">Construct 1D FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_deprojection.html#Deproject-to-2D-FES">Deproject to 2D FES</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#Direct-route---2D-WHAM">Direct route - 2D WHAM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#Indirect-route---deproject-1D-FEP">Indirect route - deproject 1D FEP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#CONSISTENCY-CHECK:-project-2D-FES-to-1D-FEP">CONSISTENCY CHECK: project 2D FES to 1D FEP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_deprojection.html#U(CV)-profile">U(CV) profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#Method-1---from-2D-FES">Method 1 - from 2D FES</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#Method-2---from-conditional-probability">Method 2 - from conditional probability</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tut/advanced_deprojection.html#comparison">comparison</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_transformations.html">Tutorial 7 - Transformations of 1D FEP and kinetics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations.html#FEP-and-rate-with-original-CV">FEP and rate with original CV</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations.html#FEP-and-rate-in-terms-of-alternative-CV">FEP and rate in terms of alternative CV</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tut/advanced_transformations_2D.html">Tutorial 8 - Transformation of 2D free energy surfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations_2D.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations_2D.html#Construction-of-original-2D-FES">Construction of original 2D FES</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations_2D.html#Transformation-to-new-CVs">Transformation to new CVs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tut/advanced_transformations_2D.html#Projection-comparison">Projection comparison</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../rg.html">Reference Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../rg_thermo.html">Thermodynamics – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.fep">Free energy profiles – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.fep</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.BaseFreeEnergyProfile"><code class="docutils literal notranslate"><span class="pre">BaseFreeEnergyProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.BaseProfile"><code class="docutils literal notranslate"><span class="pre">BaseProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.FreeEnergySurface2D"><code class="docutils literal notranslate"><span class="pre">FreeEnergySurface2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.SimpleFreeEnergyProfile"><code class="docutils literal notranslate"><span class="pre">SimpleFreeEnergyProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.fep.plot_profiles"><code class="docutils literal notranslate"><span class="pre">plot_profiles()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.histogram">Histograms – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.histogram</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.histogram.Histogram1D"><code class="docutils literal notranslate"><span class="pre">Histogram1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.histogram.Histogram2D"><code class="docutils literal notranslate"><span class="pre">Histogram2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.histogram.plot_histograms"><code class="docutils literal notranslate"><span class="pre">plot_histograms()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.trajectory">Trajectory readers – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.trajectory</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.trajectory.ASEExtendedXYZReader"><code class="docutils literal notranslate"><span class="pre">ASEExtendedXYZReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.trajectory.CVComputer"><code class="docutils literal notranslate"><span class="pre">CVComputer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.trajectory.ColVarReader"><code class="docutils literal notranslate"><span class="pre">ColVarReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.trajectory.HDF5Reader"><code class="docutils literal notranslate"><span class="pre">HDF5Reader</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.bias">Bias potentials – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.bias</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.BiasPotential1D"><code class="docutils literal notranslate"><span class="pre">BiasPotential1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.BiasPotential2D"><code class="docutils literal notranslate"><span class="pre">BiasPotential2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.MultipleBiasses1D"><code class="docutils literal notranslate"><span class="pre">MultipleBiasses1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.Parabola1D"><code class="docutils literal notranslate"><span class="pre">Parabola1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.Parabola2D"><code class="docutils literal notranslate"><span class="pre">Parabola2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.PlumedSplinePotential1D"><code class="docutils literal notranslate"><span class="pre">PlumedSplinePotential1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.bias.Polynomial1D"><code class="docutils literal notranslate"><span class="pre">Polynomial1D</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.cv">Collective variables – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.cv</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.Average"><code class="docutils literal notranslate"><span class="pre">Average</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.CenterOfMass"><code class="docutils literal notranslate"><span class="pre">CenterOfMass</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.CenterOfPosition"><code class="docutils literal notranslate"><span class="pre">CenterOfPosition</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.CoordinationNumber"><code class="docutils literal notranslate"><span class="pre">CoordinationNumber</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.Difference"><code class="docutils literal notranslate"><span class="pre">Difference</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.DistOrthProjOrig"><code class="docutils literal notranslate"><span class="pre">DistOrthProjOrig</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.Distance"><code class="docutils literal notranslate"><span class="pre">Distance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.DistanceCOP"><code class="docutils literal notranslate"><span class="pre">DistanceCOP</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.DotProduct"><code class="docutils literal notranslate"><span class="pre">DotProduct</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.LinearCombination"><code class="docutils literal notranslate"><span class="pre">LinearCombination</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.Minimum"><code class="docutils literal notranslate"><span class="pre">Minimum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.NormalToPlane"><code class="docutils literal notranslate"><span class="pre">NormalToPlane</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.NormalizedAxis"><code class="docutils literal notranslate"><span class="pre">NormalizedAxis</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.cv.OrthogonalDistanceToPore"><code class="docutils literal notranslate"><span class="pre">OrthogonalDistanceToPore</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.state">State – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.state</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.state.Integrate"><code class="docutils literal notranslate"><span class="pre">Integrate</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.state.Maximum"><code class="docutils literal notranslate"><span class="pre">Maximum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.state.Minimum"><code class="docutils literal notranslate"><span class="pre">Minimum</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_thermo.html#module-thermolib.thermodynamics.condprob">Conditional probability – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.condprob</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D"><code class="docutils literal notranslate"><span class="pre">ConditionalProbability1D1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D"><code class="docutils literal notranslate"><span class="pre">ConditionalProbability1D2D</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rg_kin.html">Kinetics – <code class="docutils literal notranslate"><span class="pre">thermolib.kinetics</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_kin.html#module-thermolib.kinetics.rate">Rate constant – <code class="docutils literal notranslate"><span class="pre">thermolib.kinetics.rate</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_kin.html#thermolib.kinetics.rate.BaseRateFactor"><code class="docutils literal notranslate"><span class="pre">BaseRateFactor</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_kin.html#thermolib.kinetics.rate.RateFactorEquilibrium"><code class="docutils literal notranslate"><span class="pre">RateFactorEquilibrium</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rg_error.html">Error distributions – <code class="docutils literal notranslate"><span class="pre">thermolib.error</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray"><code class="docutils literal notranslate"><span class="pre">ErrorArray</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray.mean"><code class="docutils literal notranslate"><span class="pre">ErrorArray.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">ErrorArray.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray.sample"><code class="docutils literal notranslate"><span class="pre">ErrorArray.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.ErrorArray.std"><code class="docutils literal notranslate"><span class="pre">ErrorArray.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.copy"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.log_from_loggaussian"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.log_from_loggaussian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.mean"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.print"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.print()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.sample"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.set_ref"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.set_ref()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.shift"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.shift()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.GaussianDistribution.std"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.copy"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.exp_from_gaussian"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.exp_from_gaussian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.mean"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.sample"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.set_ref"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.set_ref()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.shift"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.shift()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.LogGaussianDistribution.std"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiDistribution"><code class="docutils literal notranslate"><span class="pre">MultiDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiDistribution.corr"><code class="docutils literal notranslate"><span class="pre">MultiDistribution.corr()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.copy"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.cov"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.cov()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.log_from_loggaussian"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.log_from_loggaussian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.mean"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.plot_corr_matrix"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.plot_corr_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.sample"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.set_ref"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.set_ref()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiGaussianDistribution.std"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.copy"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.cov"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.cov()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.exp_from_gaussian"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.exp_from_gaussian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.mean"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.nsigma_conf_int"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.nsigma_conf_int()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.plot_corr_matrix"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.plot_corr_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.sample"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.std"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.std()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator"><code class="docutils literal notranslate"><span class="pre">Propagator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator.calc_fun_values"><code class="docutils literal notranslate"><span class="pre">Propagator.calc_fun_values()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator.gen_args_samples"><code class="docutils literal notranslate"><span class="pre">Propagator.gen_args_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator.get_distribution"><code class="docutils literal notranslate"><span class="pre">Propagator.get_distribution()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.Propagator.reset"><code class="docutils literal notranslate"><span class="pre">Propagator.reset()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution"><code class="docutils literal notranslate"><span class="pre">SampleDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.from_samples()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.mean"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.mean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.sample"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.sample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.set_ref"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.set_ref()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.shift"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.shift()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../rg_error.html#thermolib.error.SampleDistribution.std"><code class="docutils literal notranslate"><span class="pre">SampleDistribution.std()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rg_tools.html">Tools – <code class="docutils literal notranslate"><span class="pre">thermolib.tools</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.blav"><code class="docutils literal notranslate"><span class="pre">blav()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.corrtime_from_acf"><code class="docutils literal notranslate"><span class="pre">corrtime_from_acf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.decorrelate"><code class="docutils literal notranslate"><span class="pre">decorrelate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.extract_polynomial_bias_info"><code class="docutils literal notranslate"><span class="pre">extract_polynomial_bias_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.fisher_matrix_mle_probdens"><code class="docutils literal notranslate"><span class="pre">fisher_matrix_mle_probdens()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.format_scientific"><code class="docutils literal notranslate"><span class="pre">format_scientific()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.h5_read_dataset"><code class="docutils literal notranslate"><span class="pre">h5_read_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.integrate"><code class="docutils literal notranslate"><span class="pre">integrate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.integrate2d"><code class="docutils literal notranslate"><span class="pre">integrate2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.interpolate_surface_2d"><code class="docutils literal notranslate"><span class="pre">interpolate_surface_2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.invert_fisher_to_covariance"><code class="docutils literal notranslate"><span class="pre">invert_fisher_to_covariance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.multivariate_normal"><code class="docutils literal notranslate"><span class="pre">multivariate_normal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.plot_histograms_1d"><code class="docutils literal notranslate"><span class="pre">plot_histograms_1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.plot_histograms_overlap_1d"><code class="docutils literal notranslate"><span class="pre">plot_histograms_overlap_1d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.read_wham_input"><code class="docutils literal notranslate"><span class="pre">read_wham_input()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_tools.html#thermolib.tools.rolling_average"><code class="docutils literal notranslate"><span class="pre">rolling_average()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../rg_ext.html">Extensions – <code class="docutils literal notranslate"><span class="pre">thermolib.ext</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham1d_bias"><code class="docutils literal notranslate"><span class="pre">wham1d_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham1d_error"><code class="docutils literal notranslate"><span class="pre">wham1d_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham1d_hs"><code class="docutils literal notranslate"><span class="pre">wham1d_hs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham1d_scf"><code class="docutils literal notranslate"><span class="pre">wham1d_scf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham2d_bias"><code class="docutils literal notranslate"><span class="pre">wham2d_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham2d_error"><code class="docutils literal notranslate"><span class="pre">wham2d_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham2d_hs"><code class="docutils literal notranslate"><span class="pre">wham2d_hs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rg_ext.html#thermolib.ext.wham2d_scf"><code class="docutils literal notranslate"><span class="pre">wham2d_scf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ThermoLIB</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">thermolib.tools</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for thermolib.tools</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2019 - 2024 Louis Vanduyfhuys &lt;Louis.Vanduyfhuys@UGent.be&gt;</span>
<span class="c1"># Center for Molecular Modeling (CMM), Ghent University, Ghent, Belgium;</span>
<span class="c1"># all rights reserved unless otherwise stated.</span>
<span class="c1">#</span>
<span class="c1"># This file is part of a library developed by Louis Vanduyfhuys at</span>
<span class="c1"># the Center for Molecular Modeling under supervision of prof. Veronique</span>
<span class="c1"># Van Speybroeck. Usage of this package should be authorized by prof. Van</span>
<span class="c1"># Vanduyfhuys or prof. Van Speybroeck.</span>


<span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">I</span>
<span class="kn">from</span> <span class="nn">molmod.units</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molmod.constants</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molmod.io.xyz</span> <span class="kn">import</span> <span class="n">XYZReader</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">h5py</span> <span class="k">as</span> <span class="nn">h5</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;format_scientific&#39;</span><span class="p">,</span> <span class="s1">&#39;h5_read_dataset&#39;</span><span class="p">,</span>
    <span class="s1">&#39;integrate&#39;</span><span class="p">,</span> <span class="s1">&#39;integrate2d&#39;</span><span class="p">,</span> <span class="s1">&#39;interpolate_surface_2d&#39;</span><span class="p">,</span> <span class="s1">&#39;recollect_surface_2d&#39;</span><span class="p">,</span> <span class="s1">&#39;rolling_average&#39;</span><span class="p">,</span>
    <span class="s1">&#39;read_wham_input&#39;</span><span class="p">,</span> <span class="s1">&#39;extract_polynomial_bias_info&#39;</span><span class="p">,</span> <span class="s1">&#39;plot_histograms_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;plot_histograms_overlap_1d&#39;</span><span class="p">,</span>
    <span class="s1">&#39;blav&#39;</span><span class="p">,</span> <span class="s1">&#39;corrtime_from_acf&#39;</span><span class="p">,</span> <span class="s1">&#39;decorrelate&#39;</span><span class="p">,</span> <span class="s1">&#39;multivariate_normal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;invert_fisher_to_covariance&#39;</span><span class="p">,</span> <span class="s1">&#39;fisher_matrix_mle_probdens&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1">#Miscellaneous utility routines</span>

<div class="viewcode-block" id="format_scientific"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.format_scientific">[docs]</a><span class="k">def</span> <span class="nf">format_scientific</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Format a numerical value in scientific notation with optional precision and LaTeX formatting.</span>

<span class="sd">        :param x: The numerical value to be formatted in scientific notation.</span>
<span class="sd">        :type x: float</span>

<span class="sd">        :param prec: (optional, default=3) The precision of the scientific notation, i.e., the number of decimal places to be displayed.</span>
<span class="sd">        :type prec: int</span>

<span class="sd">        :param latex: (optional, default=True) If set to ``True``, the function will return a LaTeX-formatted string; otherwise, it will return a regular string.</span>
<span class="sd">        :type latex: bool</span>

<span class="sd">        :returns: A formatted string representing the input value in scientific notation.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;nan&#39;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;{:.</span><span class="si">%i</span><span class="s1">E}&#39;</span> <span class="o">%</span><span class="n">prec</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s1">&#39;$</span><span class="si">%s</span><span class="s1">\cdot 10^{</span><span class="si">%s</span><span class="s1">}$&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> 10^</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="h5_read_dataset"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.h5_read_dataset">[docs]</a><span class="k">def</span> <span class="nf">h5_read_dataset</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">dset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a dataset from an HDF5 file and return the data as a NumPy array.</span>

<span class="sd">        :param fn: The filename (including the path) of the HDF5 file.</span>
<span class="sd">        :type fn: str</span>

<span class="sd">        :param dset: The name of the dataset within the HDF5 file to be read.</span>
<span class="sd">        :type dset: str</span>

<span class="sd">        :returns: A NumPy array containing the data from the specified dataset.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">h5</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">dset</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">data</span></div>

<span class="c1">#Routines related to integration, interpolation and recollection</span>

<div class="viewcode-block" id="integrate"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.integrate">[docs]</a><span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">yerrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Perform numerical integration of a dataset using the trapezoidal rule and return the integrated value. Optionally, analytically compute the error in the integration if uncertainties (`yerrs`) are provided (uncorrelated error bars are assumed).</span>

<span class="sd">        :param xs: A list or NumPy array representing the x-values of the dataset.</span>
<span class="sd">        :type xs: list or numpy.ndarray</span>

<span class="sd">        :param ys: A list or NumPy array representing the y-values of the dataset.</span>
<span class="sd">        :type ys: list or numpy.ndarray</span>

<span class="sd">        :param yerrs: (optional) A list or NumPy array representing the uncertainties in the y-values. If not provided (default), only the integration result is returned.</span>
<span class="sd">        :type yerrs: list or numpy.ndarray</span>

<span class="sd">        :returns: If `yerrs` is not provided, the integrated value of the dataset using the trapezoidal rule. If `yerrs` is provided, a tuple containing the integrated value and the error in the integration.</span>
<span class="sd">        :rtype: float or tuple</span>
<span class="sd">        &#39;&#39;&#39;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">if</span> <span class="n">yerrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">error2</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">y</span><span class="o">*</span><span class="n">dx</span>
        <span class="k">if</span> <span class="n">yerrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">yerrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">yerrs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">tmp</span><span class="p">):</span>
                <span class="n">error2</span> <span class="o">+=</span> <span class="n">tmp</span>
    <span class="k">if</span> <span class="n">yerrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error2</span><span class="p">)</span></div>

<div class="viewcode-block" id="integrate2d"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.integrate2d">[docs]</a><span class="k">def</span> <span class="nf">integrate2d</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dx</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">dy</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Perform numerical integration of a regularly spaced two-dimensional dataset using the midpoint rule and return the integrated value. The function allows the specification of grid spacings (`dx` and `dy`) or infers them from the provided coordinate arrays (`x` and `y`).</span>

<span class="sd">        :param z: A two-dimensional array representing the values of the dataset.</span>
<span class="sd">        :type z: numpy.ndarray</span>

<span class="sd">        :param x: (optional) The x-coordinate array. If provided, the function will infer the grid spacing `dx`.</span>
<span class="sd">        :type x: numpy.ndarray or None</span>

<span class="sd">        :param y: (optional) The y-coordinate array. If provided, the function will infer the grid spacing `dy`.</span>
<span class="sd">        :type y: numpy.ndarray or None</span>

<span class="sd">        :param dx: (optional, default=1.0) The grid spacing in the x-direction. Ignored if `x` is provided.</span>
<span class="sd">        :type dx: float</span>

<span class="sd">        :param dy: (optional, default=1.0) The grid spacing in the y-direction. Ignored if `y` is provided.</span>
<span class="sd">        :type dy: float</span>

<span class="sd">        :returns: The integrated value of the two-dimensional dataset using the midpoint rule.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">dx</span><span class="o">*</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">s2</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">s3</span><span class="p">)</span></div>

<div class="viewcode-block" id="rolling_average"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.rolling_average">[docs]</a><span class="k">def</span> <span class="nf">rolling_average</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">yerrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a rolling average of a given dataset, optionally accompanied by error bars. The rolling average is calculated by dividing the dataset into windows of a specified width and averaging the values within each window. Optionally also compute the error bar on the rolling average if the input ``yerrs`` is provided.</span>

<span class="sd">        :param ys: The input dataset for which the rolling average is calculated.</span>
<span class="sd">        :type ys: list or numpy.ndarray</span>

<span class="sd">        :param width: The width of the rolling average window. Must be an integer, and at least 2.</span>
<span class="sd">        :type width: int</span>

<span class="sd">        :param yerrs: (optional) Error bars associated with the input dataset. If provided, the function will compute corresponding error bars for the rolling averages using standard error propagation.</span>
<span class="sd">        :type yerrs: list or numpy.ndarray or None</span>

<span class="sd">        :returns: If `yerrs` is not provided, a NumPy array containing the rolling averages of the input dataset. If `yerrs` is provided, a tuple containing a NumPy array with the rolling averages and a NumPy array with the corresponding error bars.</span>
<span class="sd">        :rtype: numpy.ndarray or tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;Rolling average width needs to be an integer&quot;</span>
    <span class="k">assert</span> <span class="n">width</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Rolling average width needs to be at least 2&quot;</span>
    <span class="k">if</span> <span class="n">yerrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">yerrs</span><span class="p">),</span> <span class="s2">&quot;ys and its corresponding error bars yerrs should be of same length&quot;</span>
    <span class="n">newN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span><span class="o">/</span><span class="n">width</span><span class="p">))</span>
    <span class="n">new_ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newN</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">yerrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_yerrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newN</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">newN</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">new_ys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">width</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">width</span>
        <span class="k">if</span> <span class="n">yerrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_yerrs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">yerrs</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">width</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">/</span><span class="n">width</span> 
    <span class="n">new_ys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[(</span><span class="n">newN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">yerrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">yerrs</span><span class="p">[(</span><span class="n">newN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">:]</span>
        <span class="n">new_yerrs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">vals</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_ys</span><span class="p">,</span> <span class="n">new_yerrs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_ys</span></div>

<span class="k">def</span> <span class="nf">interpolate_between_points_2D</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">evalpoint</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SVDLinear&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Routine to perform a 2D interpolation to estimate the z-value at the given evalpoint :math:`(x,y)` based on the given datapoints :math:`[(x_0,y_0,z_0),(x_1,y_1,z_1),...]`. Currently only one method of interpolation is supported: ``SVDLinear``, which is described in detail below:</span>

<span class="sd">        **SVDLinear**</span>

<span class="sd">        Solve the set of equations </span>
<span class="sd">        </span>
<span class="sd">        .. math:</span>
<span class="sd">        </span>
<span class="sd">            z_0 &amp;= a_0*x_0 + a_1*y_0 + a_2 \\\\</span>
<span class="sd">            z_1 &amp;= a_0*x_1 + a_1*y_1 + a_2 \\\\</span>
<span class="sd">            z_2 &amp;= a_0*x_2 + a_1*y_2 + a_2 \\\\</span>
<span class="sd">            \\ldots</span>
<span class="sd">        </span>
<span class="sd">        Herein, :math:`(x_i,y_i,z_i)` are the datapoints given in the input arguments. In matrix notation this becomes:</span>

<span class="sd">        .. math:</span>

<span class="sd">            \\boldsymbol Z = \\boldsymbol X \\cdot \\boldsymbol A</span>
<span class="sd">        </span>
<span class="sd">        with:</span>
<span class="sd">        </span>
<span class="sd">        .. math:</span>

<span class="sd">            Z &amp;= \\left(\\begin{array}{c}</span>
<span class="sd">                z_0 \\\\</span>
<span class="sd">                z_1 \\\\</span>
<span class="sd">                z_2 \\\\</span>
<span class="sd">                \\vdots</span>
<span class="sd">            \\end{array}\\right) \\\\</span>
<span class="sd">            X &amp;= \\left(\\begin{array}{ccc}</span>
<span class="sd">                x_0 &amp; y_0 &amp; 1 \\\\</span>
<span class="sd">                x_1 &amp; y_1 &amp; 1 \\\\</span>
<span class="sd">                x_2 &amp; y_2 &amp; 1 \\\\</span>
<span class="sd">                \\vdots &amp; \\vdots &amp; \\vdtos \\\\</span>
<span class="sd">            \\end{array}\\right)\\\\</span>
<span class="sd">            A &amp;= \\left(\\begin{array}{c}</span>
<span class="sd">                a_0 \\\\</span>
<span class="sd">                a_1 \\\\</span>
<span class="sd">                a_2 \\\\</span>
<span class="sd">            \\end{array}\\right)</span>

<span class="sd">        The fitting is performed in a Least-Squares way using Singular Value Decomposition using the numpy.linalg.lstsq routine.</span>

<span class="sd">        :param datapoints: array containing the data points in the form [(x0,y0,z0),(x1,y1,z1),...]. If method is QuasiLinear, there should be 4 points (i.e. n=4).</span>
<span class="sd">        :type datapoints: np.ndarray[shape=(n,3)]</span>

<span class="sd">        :param evalpoint: (x,y) value of the point at which we want to interpolate the z-value</span>
<span class="sd">        :type evalpoint: np.ndarray[shape=(2,)]</span>

<span class="sd">        :param method: Specify which method to use for interpolation. Should be either &#39;QuasiLinear&#39; or &#39;SVDLinear&#39;. See documentation above for more details.</span>
<span class="sd">        :type method: str, optional, default=&#39;SVDLinear&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;quasilinear&#39;</span><span class="p">:</span>
        <span class="c1">#construct the matrixed D, X and Z</span>
        <span class="c1">#D = np.diag([1,1,1,0,0,0]) #not really required as it is easily encoded in F directly below</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">datapoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">X</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">X</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">X</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1">#construct block matrices E and F</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>
        <span class="c1">#E[:6,:6] = D #encoded directly in expression above</span>
        <span class="n">E</span><span class="p">[:</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">:]</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
        <span class="n">E</span><span class="p">[</span><span class="mi">6</span><span class="p">:,:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">F</span><span class="p">[</span><span class="mi">6</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Z</span>
        <span class="c1">#solve E*P=F for P</span>
        <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">E</span><span class="p">))</span><span class="o">&gt;</span><span class="mf">1e-12</span><span class="p">,</span> <span class="s1">&#39;Could not interpolate, determinant of matrix E (=</span><span class="si">%.3e</span><span class="s1">) is to small!&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">F</span><span class="p">)</span>
        <span class="c1">#check if solution satifies the datapoints</span>
        <span class="n">dev</span> <span class="o">=</span> <span class="n">Z</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="p">[:</span><span class="mi">6</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-12</span><span class="p">,</span> <span class="s1">&#39;Obtained solution did not satisfy datapoint </span><span class="si">%i</span><span class="s1">: zi-f(xi,yi)=</span><span class="si">%.3e</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">dev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1">#define function to compute z value of interpolation at given evalpoint</span>
        <span class="k">def</span> <span class="nf">interpol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">P</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;svdlinear&#39;</span><span class="p">:</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">datapoints</span><span class="p">),</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">datapoints</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">svals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span>
        <span class="c1">#define function to compute z value of interpolation at given evalpoint</span>
        <span class="k">def</span> <span class="nf">interpol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Interpolation method </span><span class="si">%s</span><span class="s2"> not supported, should be either &#39;QuasiLinear&#39; or &#39;SVDLinear&#39;.&quot;</span> <span class="o">%</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interpol</span><span class="p">(</span><span class="n">evalpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">evalpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<div class="viewcode-block" id="interpolate_surface_2d"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.interpolate_surface_2d">[docs]</a><span class="k">def</span> <span class="nf">interpolate_surface_2d</span><span class="p">(</span><span class="n">cv1s</span><span class="p">,</span> <span class="n">cv2s</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">interpolation_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Routine to perform interpolation of F(CV1,CV2) defined by cv1s,cv2,fs grid. For all grid points where fs is np.nan, do interpolation using its right/left/up/down neighbors that are not np.nan. This routine will detect which grid points have fs=np.nan, search for neighbours valid for interpolation, collect there f value and parse to the :py:meth:`interpolate_between_points_2D &lt;thermolib.tools.interpolate_between_points_2D&gt;`` routine to do the actual interpolation.</span>

<span class="sd">        :param interpolation_depth: when interpolating at a certain bin from the neighbouring bins, go at max a number of neighbours far equal to interpolation_depth in each direction to try and find free energy data that is not np.nan</span>
<span class="sd">        :type interpolation_depth: int, optional, default=3</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#some init</span>
    <span class="n">fs_new</span> <span class="o">=</span> <span class="n">fs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">interpolated</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">not_found</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#find np.nans in fs and compute interpolated values</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">),</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="n">left</span><span class="p">,</span><span class="n">l</span><span class="p">]):</span>
                <span class="n">left</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">left</span><span class="o">&lt;</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">interpolation_depth</span><span class="p">):</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="n">right</span><span class="p">,</span><span class="n">l</span><span class="p">]):</span>
                <span class="n">right</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="n">interpolation_depth</span><span class="p">)</span><span class="o">&lt;</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span>
            <span class="n">down</span> <span class="o">=</span> <span class="n">l</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">down</span><span class="p">]):</span>
                <span class="n">down</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">down</span><span class="o">&lt;</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">l</span><span class="o">-</span><span class="n">interpolation_depth</span><span class="p">):</span>
                    <span class="n">down</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span>
            <span class="n">up</span> <span class="o">=</span> <span class="n">l</span>
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">up</span><span class="p">]):</span>
                <span class="n">up</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">fs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="n">interpolation_depth</span><span class="p">)</span><span class="o">&lt;</span><span class="n">up</span><span class="p">:</span>
                    <span class="n">up</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">up</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">down</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">datapoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">cv1s</span><span class="p">[</span><span class="n">left</span> <span class="p">],</span> <span class="n">cv2s</span><span class="p">[</span><span class="n">l</span>   <span class="p">],</span> <span class="n">fs</span><span class="p">[</span><span class="n">left</span> <span class="p">,</span><span class="n">l</span>   <span class="p">]],</span> <span class="c1">#left point</span>
                    <span class="p">[</span><span class="n">cv1s</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">cv2s</span><span class="p">[</span><span class="n">l</span>   <span class="p">],</span> <span class="n">fs</span><span class="p">[</span><span class="n">right</span><span class="p">,</span><span class="n">l</span>   <span class="p">]],</span> <span class="c1">#right point</span>
                    <span class="p">[</span><span class="n">cv1s</span><span class="p">[</span><span class="n">k</span>    <span class="p">],</span> <span class="n">cv2s</span><span class="p">[</span><span class="n">down</span><span class="p">],</span> <span class="n">fs</span><span class="p">[</span><span class="n">k</span>    <span class="p">,</span><span class="n">down</span><span class="p">]],</span> <span class="c1">#down point</span>
                    <span class="p">[</span><span class="n">cv1s</span><span class="p">[</span><span class="n">k</span>    <span class="p">],</span> <span class="n">cv2s</span><span class="p">[</span>  <span class="n">up</span><span class="p">],</span> <span class="n">fs</span><span class="p">[</span><span class="n">k</span>    <span class="p">,</span>  <span class="n">up</span><span class="p">]],</span> <span class="c1">#up point</span>
                <span class="p">])</span>
                <span class="n">evalpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cv1s</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">cv2s</span><span class="p">[</span><span class="n">l</span><span class="p">]])</span>
                <span class="n">f_int</span> <span class="o">=</span> <span class="n">interpolate_between_points_2D</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">evalpoint</span><span class="p">)</span>
                <span class="n">interpolated</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">f_int</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: could not interpolate for (Q1[</span><span class="si">%i</span><span class="s1">],Q2[</span><span class="si">%i</span><span class="s1">]) as no left/right/up/down bound was found for interpolation&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">))</span>
                <span class="n">not_found</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">))</span>
    <span class="c1">#set interpolated values in fs_new (needs to be done afterwards to avoid interpolated values affecting the interpolation of the next bins)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">f_int</span> <span class="ow">in</span> <span class="n">interpolated</span><span class="p">:</span>
        <span class="n">fs_new</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_int</span>
    <span class="k">return</span> <span class="n">fs_new</span></div>

<span class="k">def</span> <span class="nf">recollect_surface_2d</span><span class="p">(</span><span class="n">cv1s_old</span><span class="p">,</span> <span class="n">cv2s_old</span><span class="p">,</span> <span class="n">fs_old</span><span class="p">,</span> <span class="n">q1s_new</span><span class="p">,</span> <span class="n">q2s_new</span><span class="p">):</span>
    <span class="n">CV1s</span><span class="p">,</span> <span class="n">CV2s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">cv1s_old</span><span class="p">,</span> <span class="n">cv2s_old</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">fs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">q1s_new</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">q2s_new</span><span class="p">)])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q1s_new</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">lower1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">upper1</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q1s_new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">q1s_new</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q1s_new</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">lower1</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q1s_new</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">q1s_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">upper1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower1</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q1s_new</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">q1s_new</span><span class="p">[</span><span class="n">k</span>  <span class="p">])</span>
            <span class="n">upper1</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q1s_new</span><span class="p">[</span><span class="n">k</span>  <span class="p">]</span><span class="o">+</span><span class="n">q1s_new</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q2s_new</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">lower2</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">upper2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q2s_new</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">q2s_new</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">l</span><span class="o">==</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q2s_new</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">lower2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q2s_new</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">q2s_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">upper2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lower2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q2s_new</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">q2s_new</span><span class="p">[</span><span class="n">l</span>  <span class="p">])</span>
                <span class="n">upper2</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">q2s_new</span><span class="p">[</span><span class="n">l</span>  <span class="p">]</span><span class="o">+</span><span class="n">q2s_new</span><span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">Is</span><span class="p">,</span> <span class="n">Js</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">lower1</span><span class="o">&lt;=</span><span class="n">CV1s</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">CV1s</span><span class="o">&lt;</span><span class="n">upper1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">lower2</span><span class="o">&lt;=</span><span class="n">CV2s</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">CV2s</span><span class="o">&lt;</span><span class="n">upper2</span><span class="p">))</span>
            <span class="n">num</span><span class="p">,</span> <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Is</span><span class="p">,</span> <span class="n">Js</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs_old</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]):</span>
                    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">fs_old</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">num</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">fs_new</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="o">/</span><span class="n">num</span>
    <span class="k">return</span> <span class="n">fs_new</span>


<span class="c1">#Routines for reading WHAM input</span>

<div class="viewcode-block" id="read_wham_input"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.read_wham_input">[docs]</a><span class="k">def</span> <span class="nf">read_wham_input</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trajectory_readers</span><span class="p">,</span> <span class="n">trajectory_path_templates</span><span class="p">,</span> <span class="n">bias_potential</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">q01_unit</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">kappa1_unit</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">q02_unit</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">kappa2_unit</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">inverse_cv1</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inverse_cv2</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">additional_bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_bias_dimension</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;cv1&#39;</span><span class="p">,</span> <span class="n">skip_bias_names</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read a WHAM input file (metadata file) to read the simulation temperature, trajectories (CV samples) and bias potentials.</span>

<span class="sd">        :param fn: The path to the WHAM input file, i.e. the metadata file. This file should be in the following format:</span>

<span class="sd">            .. code-block:: python</span>

<span class="sd">                T = XXXK</span>
<span class="sd">                NAME_1 Q0_1_1 KAPPA_1_1 [Q0_2_1 KAPPA_2_1 [...]]</span>
<span class="sd">                NAME_2 Q0_1_2 KAPPA_1_2 [Q0_2_2 KAPPA_2_2 [...]]</span>
<span class="sd">                NAME_3 Q0_1_3 KAPPA_1_3 [Q0_2_3 KAPPA_2_3 [...]]</span>
<span class="sd">                ...</span>
<span class="sd">            </span>
<span class="sd">            where NAME_i is a label for the i-th simulation that will be used to identify the location of its trajectory file (see parameter ``trajectory_path_templates`` below), (Q0_j_i, KAPPA_j_i) is the Q0 and KAPPA value of the j-th CV in the i-th bias potential (.i.e. of the i-th biased simulation). As a first example, a line ``W0 0.5 100`` would indicate a simulation labeled W0 with a bias applied along a single CV (1D bias) centered around CV=0.5 and with force constant 100 (the units of which can be further specified in the ``q01_unit`` and ``kappa1_unit`` arguments). As a second example, a line ``sim3 0.5 100 -1.0 150`` would indicate a simulation labeled sim3 with a bias applied along two CVs (2D bias) centered around (CV1,CV2)=(0.5,-1.0) and with force constant 100 along CV1 and 150 along CV2.</span>

<span class="sd">        :type fn: str</span>

<span class="sd">        :param trajectory_readers: implements how to read the CV values from the trajectory file of a simulation. If a list of readers is given, each reader should have its corresponding trajectory_path_template defined in the list of trajectory_path_templates. For information on how these trajectory files are determined, see description of the parameter ``trajectory_path_templates``.</span>
<span class="sd">        :type trajectory_readers: instance (or list of instances) of the :py:class:`CVComputer &lt;thermolib.thermodynamics.trajectory.CVComputer&gt;`, :py:class:`HDF5Reader &lt;thermolib.thermodynamics.trajectory.HDF5Reader&gt;`, :py:class:`ColVarReader &lt;thermolib.thermodynamics.trajectory.ColVarReader&gt;`, :py:class:`ASEExtendedXYZReader &lt;thermolib.thermodynamics.trajectory.ASEExtendedXYZReader&gt;` classes</span>

<span class="sd">        :param trajectory_path_templates: template (or list of templates) for defining the path (relative to the directory containing ``fn``) to the trajectory file corresponding to each simulation. Such template argument should be a string containing a single &#39;%s&#39; substring which gets replaced with the label of the simulation defined in fn (i.e. NAME_j in the code block above). For example, if trajectory_path_templates is given by ``trajectories/%s/colvar``, then the trajectory for the simulation labeled NAME_2 in fn is located at ``trajectories/NAME_2/colvar`` relative to the directory containing fn. If a list of templates is given, each template corresponds to a given trajectory reader defined in the ``trajectory_readers`` argument.</span>
<span class="sd">        :type trajectory_path_templates: str or list of strings, optional, default=&#39;%s&#39;</span>

<span class="sd">        :param bias_potential: The type of bias potential, currently allowed values are &#39;Parabola1D&#39;, &#39;Parabola2D&#39;, or &#39;None&#39;.</span>

<span class="sd">                * **Parabola1D** -- harmonic bias of the form 0.5*kappa1*(q1-q01)**2</span>
<span class="sd">                * **Parabola2D** -- harmonic bias of the form 0.5*kappa1*(q1-q01)**2 + 0.5*kappa2*(q2-q02)**2</span>

<span class="sd">        :type bias_potential: str, optional, allowed_values=[&#39;Parabola1D&#39;,&#39;Parabola2D&#39;,&#39;None&#39;], default=&#39;None&#39;</span>

<span class="sd">        :param q01_unit: The unit for the q01 value for each bias potential, q01 corresponds to the minimum in CV (or CV1 in case of a 2D bias) of the harmonic bias potential.</span>
<span class="sd">        :type q01_unit: str, optional, default=&#39;au&#39;</span>

<span class="sd">        :param kappa1_unit: The unit for kappa1 value for each bias potential, kappa1 corresponds to the force constant along CV (or CV1 in case of a 2D bias) of the harmonic bias potential.</span>
<span class="sd">        :type kappa1_unit: str, optional, default=&#39;au&#39;</span>

<span class="sd">        :param q02_unit: The unit for the q02 value for each bias potential, q02 corresponds to the minimum in CV2 of the SD harmonic bias potential. This argument is ignored in case of a 1D bias.</span>
<span class="sd">        :type q02_unit: str, optional, default=&#39;au&#39;</span>

<span class="sd">        :param kappa2_unit: The unit for kappa2 value for each bias potential, kappa2 corresponds to the force constant along CV2 of the harmonic bias potential. This argument is ignored in case of a 1D bias.</span>
<span class="sd">        :type kappa2_unit: str, optional, default=&#39;au&#39;</span>

<span class="sd">        :param inverse_cv1: If `True`, the CV1-axis will be inverted prior to bias evaluation. WARNING: the rest value parameter q01 of the potential will not be multiplied with -1!</span>
<span class="sd">        :type inverse_cv1: bool, optional, default=False</span>

<span class="sd">        :param inverse_cv2: If `True`, the CV2-axis will be inverted prior to bias evaluation. WARNING: the rest value parameter q01 of the potential will not be multiplied with -1! This argument is ignored in case of a 2D bias.</span>
<span class="sd">        :type inverse_cv2: bool, optional, default=False</span>

<span class="sd">        :param additional_bias: Additional bias potential to be added for each simulation on top of the  bias potential defined in fn</span>
<span class="sd">        :type additional_bias: object or None, optional, default=None</span>

<span class="sd">        :param additional_bias_dimension: The dimension in which the additional bias potential operates (&#39;cv1&#39;/&#39;q1&#39; or &#39;cv2&#39;/&#39;q2&#39;).</span>
<span class="sd">        :type additional_bias_dimension: str, optional, default=&#39;cv1&#39;</span>

<span class="sd">        :param skip_bias_names: A list of bias names to be skipped during processing.</span>
<span class="sd">        :type skip_bias_names: list, optional, default=[]</span>

<span class="sd">        :param verbose: If `True`, print additional information during the reading process.</span>
<span class="sd">        :type verbose: bool, optional, default=False</span>

<span class="sd">        :returns: A tuple containing temperature, a list of bias potentials, and a list of trajectories.</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">thermolib.thermodynamics.bias</span> <span class="kn">import</span> <span class="n">Parabola1D</span><span class="p">,</span> <span class="n">Parabola2D</span><span class="p">,</span> <span class="n">MultipleBiasses1D</span><span class="p">,</span> <span class="n">MultipleBiasses2D</span>
    <span class="c1">#some argument dressing</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trajectory_readers</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trajectory_path_templates</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">trajectory_readers</span> <span class="o">=</span> <span class="p">[</span><span class="n">trajectory_readers</span><span class="p">]</span>
        <span class="n">trajectory_path_templates</span> <span class="o">=</span> <span class="p">[</span><span class="n">trajectory_path_templates</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectory_readers</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">trajectory_path_templates</span><span class="p">),</span> <span class="s1">&#39;Trajectory_readers and trajectory_path_templates need to be lists of matching length!&#39;</span>
    <span class="c1">#initialize the three properties we need to extract</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">biasses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">trajectories</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#determine number of CVS to be extracted</span>
    <span class="n">ncvs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">reader</span><span class="o">.</span><span class="n">ncvs</span> <span class="k">for</span> <span class="n">reader</span> <span class="ow">in</span> <span class="n">trajectory_readers</span><span class="p">])</span>
    <span class="c1">#iterate over lines in fn and extract temp, biasses and trajectories</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fn</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">iline</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">skip_bias_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">skip_bias_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Line </span><span class="si">%i</span><span class="s1"> (corresponding to bias </span><span class="si">%s</span><span class="s1">) skipped in wham input file by user specification of skip_bias_names&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">iline</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Temperature set at </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">temp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="c1">#1D bias</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">q0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">q01_unit</span><span class="p">)</span>
                <span class="n">kappa</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">kappa1_unit</span><span class="p">)</span>
                <span class="c1">#read trajectory cv data</span>
                <span class="n">icv</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">nsamples</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">trajectory_reader</span><span class="p">,</span> <span class="n">trajectory_path_template</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trajectory_readers</span><span class="p">,</span> <span class="n">trajectory_path_templates</span><span class="p">):</span>
                    <span class="n">fn_traj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">trajectory_path_template</span> <span class="o">%</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn_traj</span><span class="p">):</span>
                        <span class="c1">#TODO: check this part, if you only give a single trajectory reader and a certain umbrella does not have a valid trajectory (because e.g. simulation failed), it will now add the trajectory of the previous umbrella assuming the current umbrella is still valid (which is obviously WRONG)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: could not read trajectory file </span><span class="si">%s</span><span class="s2">, SKIPPING!&quot;</span> <span class="o">%</span><span class="n">fn_traj</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">trajectory_reader</span><span class="p">(</span><span class="n">fn_traj</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                            <span class="n">trajdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">ncvs</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="n">nsamples</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s1">&#39;Various readers do not have consistent number of samples: </span><span class="si">%i</span><span class="s1">&lt;==&gt;</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">trajectory_reader</span><span class="o">.</span><span class="n">ncvs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">trajdata</span><span class="p">[:,</span><span class="n">icv</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">trajdata</span><span class="p">[:,</span><span class="n">icv</span><span class="p">:</span><span class="n">icv</span><span class="o">+</span><span class="n">trajectory_reader</span><span class="o">.</span><span class="n">ncvs</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                        <span class="n">icv</span> <span class="o">+=</span> <span class="n">trajectory_reader</span><span class="o">.</span><span class="n">ncvs</span>
                <span class="k">if</span> <span class="n">ncvs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajdata</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajdata</span><span class="p">)</span>
                <span class="c1">#set bias</span>
                <span class="k">if</span> <span class="n">bias_potential</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;parabola1d&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">]:</span>
                    <span class="n">bias</span> <span class="o">=</span> <span class="n">Parabola1D</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">inverse_cv</span><span class="o">=</span><span class="n">inverse_cv1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">additional_bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">bias</span> <span class="o">=</span> <span class="n">MultipleBiasses1D</span><span class="p">([</span><span class="n">bias</span><span class="p">,</span> <span class="n">additional_bias</span><span class="p">])</span>
                    <span class="n">biasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Added bias </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">bias</span><span class="o">.</span><span class="n">print</span><span class="p">())</span>
                <span class="k">elif</span> <span class="n">bias_potential</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;parabola2d&#39;</span><span class="p">]:</span>
                    <span class="c1">#this is usefull in the case one want to perform 2D WHAM (for 2D FES) but when only 1D bias potentials were applied in terms of the first CV</span>
                    <span class="n">bias</span> <span class="o">=</span> <span class="n">Parabola2D</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">inverse_cv1</span><span class="o">=</span><span class="n">inverse_cv1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">additional_bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">bias</span> <span class="o">=</span> <span class="n">MultipleBiasses2D</span><span class="p">([</span><span class="n">bias</span><span class="p">,</span> <span class="n">additional_bias</span><span class="p">],</span> <span class="n">additional_bias_dimension</span><span class="o">=</span><span class="n">additional_bias_dimension</span><span class="p">)</span>
                    <span class="n">biasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Added bias </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">bias</span><span class="o">.</span><span class="n">print</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39; The 1D bias was redefined in 2D, the force constant in the second CV was set to zero.&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Bias potential of type </span><span class="si">%s</span><span class="s1"> not implemented.&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">bias_potential</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span><span class="o">==</span><span class="mi">5</span><span class="p">:</span> <span class="c1">#2D bias</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">q01</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">q01_unit</span><span class="p">)</span>
                <span class="n">q02</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">q02_unit</span><span class="p">)</span>
                <span class="n">kappa1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">kappa1_unit</span><span class="p">)</span>
                <span class="n">kappa2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">kappa2_unit</span><span class="p">)</span>
                <span class="c1">#read trajectory cv data</span>
                <span class="n">icv</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">nsamples</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">trajectory_reader</span><span class="p">,</span> <span class="n">trajectory_path_template</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trajectory_readers</span><span class="p">,</span> <span class="n">trajectory_path_templates</span><span class="p">):</span>
                    <span class="n">fn_traj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">trajectory_path_template</span> <span class="o">%</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fn_traj</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: could not read trajectory file </span><span class="si">%s</span><span class="s2">, SKIPPING!&quot;</span> <span class="o">%</span><span class="n">fn_traj</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">trajectory_reader</span><span class="p">(</span><span class="n">fn_traj</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">nsamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                            <span class="n">trajdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nsamples</span><span class="p">,</span> <span class="n">ncvs</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="n">nsamples</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s1">&#39;Various readers do not have consistent number of samples: </span><span class="si">%i</span><span class="s1">&lt;==&gt;</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">nsamples</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">trajectory_reader</span><span class="o">.</span><span class="n">ncvs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="n">trajdata</span><span class="p">[:,</span><span class="n">icv</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">trajdata</span><span class="p">[:,</span><span class="n">icv</span><span class="p">:</span><span class="n">icv</span><span class="o">+</span><span class="n">trajectory_reader</span><span class="o">.</span><span class="n">ncvs</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                        <span class="n">icv</span> <span class="o">+=</span> <span class="n">trajectory_reader</span><span class="o">.</span><span class="n">ncvs</span>
                <span class="k">if</span> <span class="n">ncvs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajdata</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajdata</span><span class="p">)</span>
                <span class="c1">#set bias</span>
                <span class="k">if</span> <span class="n">bias_potential</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;parabola2d&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">]:</span>
                    <span class="n">bias</span> <span class="o">=</span> <span class="n">Parabola2D</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">q01</span><span class="p">,</span> <span class="n">q02</span><span class="p">,</span> <span class="n">kappa1</span><span class="p">,</span> <span class="n">kappa2</span><span class="p">,</span> <span class="n">inverse_cv1</span><span class="o">=</span><span class="n">inverse_cv1</span><span class="p">,</span> <span class="n">inverse_cv2</span><span class="o">=</span><span class="n">inverse_cv2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">additional_bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">bias</span> <span class="o">=</span> <span class="n">MultipleBiasses2D</span><span class="p">([</span><span class="n">bias</span><span class="p">,</span> <span class="n">additional_bias</span><span class="p">],</span> <span class="n">additional_bias_dimension</span><span class="o">=</span><span class="n">additional_bias_dimension</span><span class="p">)</span>
                    <span class="n">biasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Added bias </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">bias</span><span class="o">.</span><span class="n">print</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Bias potential of type </span><span class="si">%s</span><span class="s1"> not implemented.&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">bias_potential</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not process line </span><span class="si">%i</span><span class="s1"> in </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">iline</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
            <span class="n">iline</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">temp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: temperature could not be read from </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">temp</span><span class="p">,</span> <span class="n">biasses</span><span class="p">,</span> <span class="n">trajectories</span></div>

<div class="viewcode-block" id="extract_polynomial_bias_info"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.extract_polynomial_bias_info">[docs]</a><span class="k">def</span> <span class="nf">extract_polynomial_bias_info</span><span class="p">(</span><span class="n">fn_plumed</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;plumed.dat&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Extracts polynomial bias coefficients from a PLUMED input file.</span>

<span class="sd">        :param fn_plumed: The filename of the PLUMED input file.</span>
<span class="sd">        :type fn_plumed: str, optional, default=&#39;plumed.dat&#39;</span>

<span class="sd">        :return: A list of polynomial coefficients for the bias potential.</span>
<span class="sd">        :rtype: list of float</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn_plumed</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">plumed</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">plumed</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;COEFFICIENTS&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span><span class="o">+=</span><span class="mi">13</span> <span class="c1">#13 len of the string</span>
                <span class="n">idx_end</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;POWERS&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">short_line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx_end</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                <span class="n">split_line</span> <span class="o">=</span> <span class="n">short_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                <span class="n">poly_coef</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">split_line</span><span class="p">]</span> <span class="c1">#remark that -float is needed to get the resulting fe.</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">poly_coef</span></div>

<div class="viewcode-block" id="plot_histograms_1d"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.plot_histograms_1d">[docs]</a><span class="k">def</span> <span class="nf">plot_histograms_1d</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Routine to plot 1d histograms of all trajectories to check overlap. This is usefull to check the choice of umbrellas in an umbrella simulation.</span>

<span class="sd">        :param trajs: List of all trajectories for which the histogram needs to be plotted.</span>
<span class="sd">        :type trajs: list(np.ndarray)</span>

<span class="sd">        :param bins: Specification of the bins for histograming. Can either be an integer specifying the number of bins over all CV range of all simulations or a numpy array explicitly defining all bins. Either bins or width needs to be specified, but not both.</span>
<span class="sd">        :type bins: int or np.ndarray, optional, default=200</span>

<span class="sd">        :param width: Specification of the width of the bins to be used in the histogramming. Either bins or width needs to be specified, but not both.</span>
<span class="sd">        :type width: float, optional, default=None</span>

<span class="sd">        :param cv_unit: unit of the CV to be used in the plot</span>
<span class="sd">        :type cv_unit: str, optional, default=&#39;au&#39;</span>

<span class="sd">        :param alpha: transparancy value of each histogram to allow visualizing overlap</span>
<span class="sd">        :type alpha: float, optional, default=0.8</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#process bins argument</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;One out of the two arguments bins and width must be specified!&#39;</span>
    <span class="k">assert</span> <span class="n">bins</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Only one out of the two arguments bins and width can be specified!&#39;</span>
    <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;Invalid type for argument bins, should be integer (representing number of bins) or np.ndarray representing all bin edges&#39;</span>
        <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="c1">#construct and plot all histograms</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current_bins</span> <span class="o">=</span> <span class="n">bins</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">/</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="n">width</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">/</span><span class="n">width</span><span class="p">)</span><span class="o">*</span><span class="n">width</span>
            <span class="n">current_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">current_bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bin_centers</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">cv_unit</span><span class="p">),</span> <span class="n">hist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;CV [</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span><span class="n">cv_unit</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Prob [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span></div>

<div class="viewcode-block" id="plot_histograms_overlap_1d"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.plot_histograms_overlap_1d">[docs]</a><span class="k">def</span> <span class="nf">plot_histograms_overlap_1d</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Routine to compute and plot overlap between all pairs of given trajectories. The overlap metric used is the one suggested by Borgmans et al. [J. Chem. Theory Comput. 2023, 19, 9032-9048], which expressed overlap :math:`O_{ij}` between probability distribution :math:`p_i` and :math:`p_j` as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            O_{ij} = \\int_{-\\infty}^{+\\infty} \\min(p_i(q),p_j(q))dq</span>
<span class="sd">        </span>
<span class="sd">        Three plots will be generated: </span>

<span class="sd">            * **left**   -- CV mean for each trajectory. This should be monotonically increasing in order to adequately interpret the right pane. If this is not the case, set sort=True</span>
<span class="sd">            * **center** -- matrix of overlap between each pair of trajectories. In a well sorted set, this matrix should be dominant along the diagonal. All diagonal values are 1, as those elements represent overlap of a trajectory with itself.</span>
<span class="sd">            * **right** -- Overlap of each simulation with its right neighbor (as well as right second neighbor). In a good umbrella simulation set, this line should be consistingly high (e.g. above 0.33 as suggested by Borgmans et al. [J. Chem. Theory Comput. 2023, 19, 9032-9048]).</span>


<span class="sd">        :param trajs: List of all trajectories for which the histogram needs to be plotted.</span>
<span class="sd">        :type trajs: list(np.ndarray)</span>

<span class="sd">        :param bins: Specification of the bins in order to construct the probability distributions through histogramming. Can either be an integer specifying the number of bins over all CV range of all simulations or a numpy array explicitly defining all bins.</span>
<span class="sd">        :type bins: int or np.ndarray, optional, default=200</span>

<span class="sd">        :param sort: If set to True and it is detected that the trajectories are not sorted according to increasing mean, the routine will first do so. This is crucial in order to properly interpret the &#39;overlap with right neighbor&#39; plot generated by this routine.</span>
<span class="sd">        :type sort: bool, optional, default=False</span>

<span class="sd">        :param fn: File name to write plot to. Plot will not be saved to file if fn=None</span>
<span class="sd">        :type fn: str, optional, default=None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajs</span><span class="p">)</span>
    <span class="c1">#process bins argument</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;Invalid type for argument bins, should be integer (representing number of bins) or np.ndarray representing all bin edges&#39;</span>
    <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="c1">#construct and plot all histograms</span>
    <span class="n">O</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">histograms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">:</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">histograms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">mean</span><span class="o">=</span><span class="p">(</span><span class="n">hist</span><span class="o">*</span><span class="n">bin_centers</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="n">width</span>
        <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>
    <span class="c1">#sort trajectories according to mean</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sort</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Trajectories were not sorting according to increasing mean, to do so use sort=True&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Trajectories were not sorting according to increasing mean, resorting as follows:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">histograms</span> <span class="o">=</span> <span class="p">[</span><span class="n">histograms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
            <span class="n">means</span>      <span class="o">=</span> <span class="p">[</span><span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="c1">#compte overlap</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Hi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">histograms</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">Hj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">histograms</span><span class="p">):</span>
            <span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">Hi</span><span class="p">,</span><span class="n">Hj</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="n">width</span>
    <span class="n">Oright</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
    <span class="n">Oright2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
    <span class="c1">#make plot</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="s1">&#39;bo-&#39;</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Simulation&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;CV mean [a.u.]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Trajectory means&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">O</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Greys&#39;</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Trajectory index&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Trajectory index&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Overlap matrix&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Oright</span><span class="p">,</span> <span class="s1">&#39;r&gt;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;with neighbor&#39;</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">Oright2</span><span class="p">,</span> <span class="s1">&#39;b&gt;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;with second neighbor&#39;</span><span class="p">)</span>
    <span class="c1">#axs[2].axhline(0.5, color=&#39;k&#39;, linestyle=&#39;--&#39;, label=&#39;0.50 threshold&#39;)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;0.33 threshold&#39;</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Trajectory index&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Overlap&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Overlap of each trajectory with right neighbor&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">([</span><span class="mi">24</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span></div>


<span class="c1">#Routines related to (de)correlation</span>

<span class="k">def</span> <span class="nf">_next_pow_two</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Utility routine required in _acf routine to find the clostest power of two that is larger than the argument n.</span>
<span class="sd">        (Taken from https://dfm.io/posts/autocorr/)</span>

<span class="sd">        :param n: lower bound for the sought after power of two</span>
<span class="sd">        :type n: float</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="k">def</span> <span class="nf">_hl_envelopes_idx</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility routine required in acf routine to determine upper and lower envolopes.</span>
<span class="sd">        Taken from https://stackoverflow.com/questions/34235530/how-to-get-high-and-low-envelope-of-a-signal</span>

<span class="sd">        :param s: data signal from which to extract high and low envelopes</span>
<span class="sd">        :type s: 1D numpy array</span>

<span class="sd">        :param dmin: minimum size of chunks, use this if the size of the input signal is too big</span>
<span class="sd">        :type dmin: int, optional, default=1</span>

<span class="sd">        :param dmax: maximum size of chunks, use this if the size of the input signal is too big</span>
<span class="sd">        :type dmax:nt, optional, default=1</span>

<span class="sd">        :param split: if True, split the signal in half along its mean, might help to generate the envelope in some cases</span>
<span class="sd">        :type split: bool, optional, default=False</span>

<span class="sd">        :return: high/low envelope idx of input signal s</span>
<span class="sd">        :rtype: two lists of indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># locals min      </span>
    <span class="n">lmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="c1"># locals max</span>
    <span class="n">lmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="k">if</span> <span class="n">split</span><span class="p">:</span>
        <span class="c1"># s_mid is zero if s centered around x-axis or more generally mean of signal</span>
        <span class="n">s_mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> 
        <span class="c1"># pre-sorting of locals min based on relative position with respect to s_mid </span>
        <span class="n">lmin</span> <span class="o">=</span> <span class="n">lmin</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">lmin</span><span class="p">]</span><span class="o">&lt;</span><span class="n">s_mid</span><span class="p">]</span>
        <span class="c1"># pre-sorting of local max based on relative position with respect to s_mid </span>
        <span class="n">lmax</span> <span class="o">=</span> <span class="n">lmax</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">lmax</span><span class="p">]</span><span class="o">&gt;</span><span class="n">s_mid</span><span class="p">]</span>
    <span class="c1"># global min of dmin-chunks of locals min </span>
    <span class="n">lmin</span> <span class="o">=</span> <span class="n">lmin</span><span class="p">[[</span><span class="n">i</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">lmin</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">dmin</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">lmin</span><span class="p">),</span><span class="n">dmin</span><span class="p">)]]</span>
    <span class="c1"># global max of dmax-chunks of locals max </span>
    <span class="n">lmax</span> <span class="o">=</span> <span class="n">lmax</span><span class="p">[[</span><span class="n">i</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">lmax</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">dmax</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">lmax</span><span class="p">),</span><span class="n">dmax</span><span class="p">)]]</span>
    <span class="k">return</span> <span class="n">lmin</span><span class="p">,</span><span class="n">lmax</span>

<span class="k">def</span> <span class="nf">_blav</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">blocksizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fitrange</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">model_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Routine to implement block averaging in order to estimate the correlated error bar on the average of the data series as well as the corresponding integrated correlation time. This proceeds as follows:</span>

<span class="sd">        * Block the data in groups of a given blocksize B and compute the average for each block. These are denoted as the block averages.</span>
<span class="sd">        * Estimate the original data total average as the average of block averages, as well as the &#39;naive&#39; error on this total average, i.e., assuming the block averages are uncorrelated.</span>
<span class="sd">        * This naive error bar is, in fact, not the true error because of correlations. However, upon increasing the block size, the correlations will diminish, and hence the naive error will converge towards the true error. Therefore, we vary the block size and fit a mathematical model on the naive error bars as a function of the block size. This model is defined by the argument ``model_function``.</span>

<span class="sd">        :param data: 1D array representing the data to be analyzed</span>
<span class="sd">        :type data: np.ndarray</span>

<span class="sd">        :param blocksizes: array of block sizes</span>
<span class="sd">        :type blocksizes: np.ndarray, optional, default=np.arange(1, len(data)+1, 1)</span>

<span class="sd">        :param fitrange: range of blocksizes to which the fit will be performed</span>
<span class="sd">        :type fitrange: list, optional, default=[1,np.inf]</span>

<span class="sd">        :param model_function: mathematical model for the naive error on block averages as a function of the block size. Should be a callable with as the first argument the block size and as the remaining arguments the model parameters to be fitted. The default model is given by:</span>

<span class="sd">        \[</span>
<span class="sd">        \Delta(B;\Delta_{\text{true}},\tau_{\text{int}}) = \Delta_{\text{true}} \cdot \sqrt{\frac{B}{B + \tau_{\text{int}} - 1}}</span>
<span class="sd">        \]</span>

<span class="sd">        :type model_function: callable, optional, default: see description</span>

<span class="sd">        :returns:</span>
<span class="sd">            - **errors** (*np.ndarray*) - The correlated error bars as a function of block sizes.</span>
<span class="sd">            - **true_error** (*float*) - The uncorrelated error on the sample mean.</span>
<span class="sd">            - **corrtime** (*float*) - The correlation time (in units of the timestep) of the original sample data.</span>
<span class="sd">            - **model_pars** (*list*) - Additional fitted parameters of the mathematical model for the naive error bars if any.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#define model function for naive errors if not specified</span>
    <span class="k">if</span> <span class="n">model_function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">model_function</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">TE</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TE</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="o">/</span><span class="p">(</span><span class="n">B</span><span class="o">+</span><span class="n">tau</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1">#compute naive errors (=errors) on block averages</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocksizes</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocksize</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">blocksizes</span><span class="p">):</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="n">blocksize</span>
        <span class="n">blavs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iblock</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">):</span>
            <span class="n">blavs</span><span class="p">[</span><span class="n">iblock</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">iblock</span><span class="o">*</span><span class="n">blocksize</span><span class="p">:(</span><span class="n">iblock</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">blocksize</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="c1">#the unbiased estimate on the variance of the block averages</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">blavs</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#the naive error on the mean of block averages </span>
        <span class="n">errors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)</span>
    <span class="c1">#fit the given mathematical model</span>
    <span class="n">nparams</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">model_function</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">lbounds</span><span class="p">,</span> <span class="n">ubounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,]</span><span class="o">*</span><span class="n">nparams</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,]</span><span class="o">*</span><span class="n">nparams</span>
    <span class="n">lbounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1">#lower bound of true error</span>
    <span class="n">lbounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1">#lower bound of correlation time</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">fitrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">blocksizes</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksizes</span><span class="o">&lt;=</span><span class="n">fitrange</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pars</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">model_function</span><span class="p">,</span> <span class="n">blocksizes</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">errors</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lbounds</span><span class="p">,</span><span class="n">ubounds</span><span class="p">))</span>
    <span class="n">true_error</span><span class="p">,</span> <span class="n">corrtime</span> <span class="o">=</span> <span class="n">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">model_fitted</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">B</span><span class="p">:</span> <span class="n">model_function</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">pars</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">errors</span><span class="p">,</span> <span class="n">true_error</span><span class="p">,</span> <span class="n">corrtime</span><span class="p">,</span> <span class="n">model_fitted</span>

<div class="viewcode-block" id="blav"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.blav">[docs]</a><span class="k">def</span> <span class="nf">blav</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">blocksizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fitrange</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">model_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fn_plot</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_ylims</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">blav_kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Wrapper routine around `_blav` to apply block averaging and estimate the correlated error bar as well as the corresponding integrated correlation time on the average of the given data series. For more details on the procedure as well as the meaning of the arguments `data`, `blocksizes`, `fitrange`, and `model_function`, see documentation of the routine :py:meth:`_wrap &lt;thermolib.tools._blav&gt;`.</span>

<span class="sd">        :param plot: If True, a plot of the samples and error estimates will be generated. Ignored if fn_plot is not None. Defaults to False.</span>
<span class="sd">        :type plot: bool, optional, default=False</span>

<span class="sd">        :param fn_plot: file name to which to write the plot. If None is given, either no plot is made (if plot=False) or the plot is not saved (if plot=True)</span>
<span class="sd">        :type fn_plot: str or None, optional, default=None</span>

<span class="sd">        :param plot_ylims: Limits for the y-axis in the error plot.</span>
<span class="sd">        :type plot_ylims: list or None, optional, default=None</span>

<span class="sd">        :param unit: unit in which to plot the data</span>
<span class="sd">        :type unit: str, optional, default=&#39;au&#39;</span>

<span class="sd">        :returns: </span>
<span class="sd">            - **mean** (*float*)- the sample mean.</span>
<span class="sd">            - **error** (*float*) - the error on the sample mean.</span>
<span class="sd">            - **corrtime** (*float*) - the correlation time (in units of the timestep) of the original sample data.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#define blocksizes if not specified</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;I will not apply block averaging on data series with only 100 or less samples&#39;</span>
    <span class="k">if</span> <span class="n">blocksizes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">blocksizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">errors</span><span class="p">,</span> <span class="n">true_error</span><span class="p">,</span> <span class="n">corrtime</span><span class="p">,</span> <span class="n">model_fitted</span> <span class="o">=</span> <span class="n">_blav</span><span class="p">(</span><span class="n">data</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="n">blocksizes</span><span class="p">,</span> <span class="n">fitrange</span><span class="p">,</span> <span class="n">model_function</span><span class="o">=</span><span class="n">model_function</span><span class="p">,</span> <span class="o">**</span><span class="n">blav_kwargs</span><span class="p">)</span>
    <span class="c1">#make plot</span>
    <span class="k">if</span> <span class="n">plot</span> <span class="ow">or</span> <span class="n">fn_plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Samples&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [timestep]&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Sample [</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span><span class="n">unit</span><span class="p">)</span>          
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">blocksizes</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">blocksizes</span><span class="p">,</span> <span class="n">model_fitted</span><span class="p">(</span><span class="n">blocksizes</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#axs[0,1].axhline(y=true_error/parse_unit(unit), color=&#39;k&#39;, linestyle=&#39;--&#39;, linewidth=1)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Error of the estimate on the sample mean&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Block size [timestep]&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Error [</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plot_ylims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">plot_ylims</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">fn_plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn_plot</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">true_error</span><span class="o">*</span><span class="n">parse_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">),</span> <span class="n">corrtime</span></div>

<span class="k">def</span> <span class="nf">_acf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Compute autocorrelation function (taken from https://dfm.io/posts/autocorr/)</span>

<span class="sd">        :param data: time series for which to construct autocorrelation function</span>
<span class="sd">        :type data: np.ndarray</span>

<span class="sd">        :param norm: if True, the acf will be normalized such that acf(0)=1</span>
<span class="sd">        :type norm: boolean, optional, default=True</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid dimensions for 1D autocorrelation function&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">_next_pow_two</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="c1">#Compute the FFT and then (from that) the auto-correlation function</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
    <span class="n">acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">f</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">f</span><span class="p">))[:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">real</span>
    <span class="n">acf</span> <span class="o">/=</span> <span class="mi">4</span><span class="o">*</span><span class="n">n</span>
    <span class="c1">#Normalize using the variance (i.e. autocorrelation with zero time lag)</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">acf</span> <span class="o">/=</span> <span class="n">acf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">acf</span>

<div class="viewcode-block" id="corrtime_from_acf"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.corrtime_from_acf">[docs]</a><span class="k">def</span> <span class="nf">corrtime_from_acf</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nblocks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fn_plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xlims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylims</span><span class="p">:</span> <span class="nb">list</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">],</span> <span class="n">n_nested_envelopes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">curve_fit_kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Routine to compute the integrated autocorrelation time as follows:</span>

<span class="sd">        - Compute the autocorrelation function (possibly after blocking data for noise suppression) using the routine :py:meth:`_acf &lt;thermolib.tools._acf&gt;`.</span>
<span class="sd">        - Optionally extract the upper envelope of the autocorrelation function to eliminate short time oscillations (when n_nested_envelopes&gt;1).</span>
<span class="sd">        - Fit a single decaying exponential function of the form :math:`\\exp(-\\frac{t}{\\tau_exp})` to the acf (or its upper envelope) to extract the exponential correlation time.</span>
<span class="sd">        - Translate the exponential correlation time to the integrated correlation time as: :math:`\\tau_\\text{int} = 2\\tau_\\text{exp}`.</span>

<span class="sd">        :param data: 1D array representing the time series for which the correlation time needs to be computed</span>
<span class="sd">        :type data: np.ndarray</span>

<span class="sd">        :param nblocks: If not None, the data will be blocked (in a number of blocks given to nblocks) prior to constructing the acf. This is usefull for surpressing noise.</span>
<span class="sd">        :type nblocks: int or None, optional, default=None</span>

<span class="sd">        :param norm: If True, normalize the autocorrelation function such that acf(0)=1</span>
<span class="sd">        :type norm: bool, optional, default=True</span>

<span class="sd">        :param plot: If True, generate a plot of the acf and resulting fit. This parameter is ignored if fn_plot is not None.</span>
<span class="sd">        :type plot: bool, optional, default=False</span>

<span class="sd">        :param fn_plot: If not None, a plot will be made of the acf and resulting fit and stored to a file with the given file name</span>
<span class="sd">        :type fn_plot: str or None, optional, default=None</span>

<span class="sd">        :param xlims: Limits for the x-axis in the plot.</span>
<span class="sd">        :type xlims: list or None, optional, default=None</span>

<span class="sd">        :param ylims: Limits for the y-axis in the plot.</span>
<span class="sd">        :type ylims: list, optional, default=[-0.25, 1.05]</span>

<span class="sd">        :return: The integrated autocorrelation time</span>
<span class="sd">        :rtype: float</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">acfs</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">nblocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="n">nblocks</span><span class="p">)</span>
        <span class="n">acfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nblocks</span><span class="p">,</span> <span class="n">bsize</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">iblock</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">):</span>
            <span class="n">acfs</span><span class="p">[</span><span class="n">iblock</span><span class="p">,:]</span><span class="o">=</span> <span class="n">_acf</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">iblock</span><span class="o">*</span><span class="n">bsize</span><span class="p">:(</span><span class="n">iblock</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bsize</span><span class="p">],</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)[:</span><span class="n">bsize</span><span class="p">]</span>
        <span class="n">acf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">acfs</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">acf</span> <span class="o">=</span> <span class="n">_acf</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1">#get envelope</span>
    <span class="n">i_nested_envelope</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">upper_envelope_values</span> <span class="o">=</span> <span class="n">acf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">upper_envelope_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">acf</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">i_nested_envelope</span><span class="o">&lt;</span><span class="n">n_nested_envelopes</span><span class="p">:</span>
        <span class="n">indices_lower</span><span class="p">,</span> <span class="n">indices_upper</span> <span class="o">=</span> <span class="n">_hl_envelopes_idx</span><span class="p">(</span><span class="n">upper_envelope_values</span><span class="p">,</span> <span class="n">dmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indices_upper</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">indices_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span><span class="n">indices_upper</span><span class="p">)</span>
        <span class="n">upper_envelope_values</span> <span class="o">=</span> <span class="n">upper_envelope_values</span><span class="p">[</span><span class="n">indices_upper</span><span class="p">]</span>
        <span class="n">upper_envelope_indices</span> <span class="o">=</span> <span class="n">upper_envelope_indices</span><span class="p">[</span><span class="n">indices_upper</span><span class="p">]</span>
        <span class="n">i_nested_envelope</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1">#fit exponential to upper_envelope and extract integrated correlation time</span>
    <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tau</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">pars</span><span class="p">,</span> <span class="n">pcovs</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">upper_envelope_indices</span><span class="p">,</span> <span class="n">upper_envelope_values</span><span class="p">,</span> <span class="o">**</span><span class="n">curve_fit_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fitted_exp</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">corrtime</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#pars[0] is the exp correlation time, corrtime is the integrated correlation time</span>
    <span class="c1">#Plot</span>
    <span class="k">if</span> <span class="n">plot</span> <span class="ow">or</span> <span class="n">fn_plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#print(&#39;Fitted following function to ACF upper envoloppe: f(t)= shift + exp(-t/tau) with shift = %.3e and tau = %.3e&#39; %(pars[1],pars[0]))</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">acfs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">acfs</span><span class="p">):</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;iblock=</span><span class="si">%i</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">i</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">acf</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;acf&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_nested_envelopes</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">upper_envelope_indices</span><span class="p">,</span> <span class="n">upper_envelope_values</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;acf - envelope&#39;</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">upper_envelope_indices</span><span class="p">,</span> <span class="n">fitted_exp</span><span class="p">(</span><span class="n">upper_envelope_indices</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;Fit exp ($2\tau$=</span><span class="si">%.1f</span><span class="s2">)&quot;</span> <span class="o">%</span><span class="n">corrtime</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Autocorrelation function&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Time delay t&quot;</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;acf(t)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xlims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">pp</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">xlims</span><span class="p">)</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">legend</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fn_plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn_plot</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">corrtime</span></div>

<div class="viewcode-block" id="decorrelate"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.decorrelate">[docs]</a><span class="k">def</span> <span class="nf">decorrelate</span><span class="p">(</span><span class="n">trajectories</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;acf&#39;</span><span class="p">,</span> <span class="n">decorrelate_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fn_plot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_decorrelated_trajectories</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">method_kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Function to compute correlation times for a list of trajectories and optionally decorrelate the trajectories by averaging over a number of samples equal to the correlation time.</span>

<span class="sd">        :param trajectories: List of trajectories to be decorrelated.</span>
<span class="sd">        :type trajectories: list</span>

<span class="sd">        :param method: Method to compute correlation time, either &#39;acf&#39; for fit to autocorrelation function or &#39;blav&#39; for block averaging. Keyword arguments specific to the chosen method can be parsed to that method by specifyinng them at the end of the argument list. For example ``decorrelate(traj, method=&#39;acf&#39;, plot=True, n_nested_enveloppes=2, p0=[1000])`` will correctly parse the ``n_nested_enveloppes`` and ``p0`` parameters to the ``corrtime_from_acf`` routine.</span>
<span class="sd">        :type method: str, optional, default=&#39;acf&#39;</span>

<span class="sd">        :param decorrelate_only: Index of the collective variable (CV) to be used for decorrelation when multiple CVs are present in the trajectories. If set to None, all CVs will be decorrelated simultaneously which generally leads to higher correlation times.</span>
<span class="sd">        :type decorrelate_only: int or None, optional, default=None</span>

<span class="sd">        :param plot: If True, generate a plot showing the correlation times for each trajectory and collective variable. Ignored if fn_plot is not None.</span>
<span class="sd">        :type plot: bool, optional, default=False</span>

<span class="sd">        :param fn_plot: File name to which to write the plot, defaults to None which means no plot is made (if plot=False) or the plot is not saved (if plot=True).</span>
<span class="sd">        :type fn_plot: str or None, optional</span>

<span class="sd">        :param verbose: If True, print additional information during computation.</span>
<span class="sd">        :type verbose: bool, optional, default=False</span>

<span class="sd">        :param return_decorrelated_trajectories: If True, also return the decorrelated trajectories which have been block averaged with a block size given by the correlation time</span>
<span class="sd">        :type return_decorrelated_trajectories: bool, optional, default=False</span>

<span class="sd">        :return: correlation time, optionally (if ``return_decorrelated_trajectories=True``) also the decorrelated trajectories are returned</span>
<span class="sd">        :rtype: np.ndarray or (if ``return_decorrelated_trajectories=True``) [np.ndarray, list]</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#determine the number of trajectories as well as cvs present in trajectory data</span>
    <span class="n">ntrajs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">ncvs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ncvs</span> <span class="o">=</span> <span class="n">trajectories</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#set default function to compute correlation time to blav</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s1">&#39;Method argument should be string, either acf or blav&#39;</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;acf&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">method_correlation_time</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">corrtime</span> <span class="o">=</span> <span class="n">corrtime_from_acf</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">method_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">corrtime</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Trajectory had corrtime smaller than 1, was set to 1!&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">corrtime</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">==</span><span class="s1">&#39;blav&#39;</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">method_correlation_time</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">corrtime</span> <span class="o">=</span> <span class="n">blav</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">method_kwargs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">corrtime</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Trajectory had corrtime smaller than 1, was set to 1!&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">corrtime</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Method argument should be string, either acf or blav&#39;</span><span class="p">)</span>
    <span class="c1">#compute correlation times</span>
    <span class="n">corrtimes_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">ntrajs</span><span class="p">,</span><span class="n">ncvs</span><span class="p">])</span>
    <span class="n">corrtimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">ntrajs</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">itraj</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectories</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ncvs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">corrtimes_all</span><span class="p">[</span><span class="n">itraj</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">method_correlation_time</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncvs</span><span class="p">):</span>
                <span class="n">corrtimes_all</span><span class="p">[</span><span class="n">itraj</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span> <span class="o">=</span> <span class="n">method_correlation_time</span><span class="p">(</span><span class="n">traj</span><span class="p">[:,</span><span class="n">icv</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">decorrelate_only</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corrtimes</span><span class="p">[</span><span class="n">itraj</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrtimes_all</span><span class="p">[</span><span class="n">itraj</span><span class="p">,:]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corrtimes</span><span class="p">[</span><span class="n">itraj</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrtimes_all</span><span class="p">[</span><span class="n">itraj</span><span class="p">,</span><span class="n">decorrelate_only</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">Nuncor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">corrtimes</span><span class="p">[</span><span class="n">itraj</span><span class="p">])))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processing trajectory </span><span class="si">%i</span><span class="s1">/</span><span class="si">%i</span><span class="s1">: </span><span class="si">%i</span><span class="s1"> samples, corr time = </span><span class="si">%.1f</span><span class="s1"> ==&gt; </span><span class="si">%i</span><span class="s1"> uncorrelated samples&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">itraj</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ntrajs</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">traj</span><span class="p">),</span><span class="n">corrtimes</span><span class="p">[</span><span class="n">itraj</span><span class="p">],</span><span class="n">Nuncor</span><span class="p">))</span>
    <span class="c1">#plot correlation times</span>
    <span class="k">if</span> <span class="n">plot</span> <span class="ow">or</span> <span class="n">fn_plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">ncvs</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">icv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncvs</span><span class="p">):</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">corrtimes_all</span><span class="p">[:,</span><span class="n">icv</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Correlation time [-]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Trajectory number [-]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Correlation time for </span><span class="si">%i</span><span class="s1">-th CV&#39;</span> <span class="o">%</span><span class="n">icv</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">([</span><span class="mi">8</span><span class="o">*</span><span class="n">ncvs</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">fn_plot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn_plot</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">return_decorrelated_trajectories</span><span class="p">:</span>
        <span class="c1">#decorrelate trajectory by averaging over a number of samples equal to the correlation time</span>
        <span class="n">trajectories_decor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectories</span><span class="p">):</span>
            <span class="n">bsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">corrtimes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">bsize</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">bsize</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  estimated correlation time was smaller than 1, set blocksize to 1&#39;</span><span class="p">)</span>
            <span class="n">nblocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span><span class="o">//</span><span class="n">bsize</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">new_traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nblocks</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">iblock</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">):</span>
                    <span class="n">new_traj</span><span class="p">[</span><span class="n">iblock</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="n">iblock</span><span class="o">*</span><span class="n">bsize</span><span class="p">:(</span><span class="n">iblock</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bsize</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">trajectories_decor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_traj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nblocks</span><span class="p">,</span><span class="n">traj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">iblock</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nblocks</span><span class="p">):</span>
                        <span class="n">new_traj</span><span class="p">[</span><span class="n">iblock</span><span class="p">,</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="n">iblock</span><span class="o">*</span><span class="n">bsize</span><span class="p">:(</span><span class="n">iblock</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bsize</span><span class="p">,</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">trajectories_decor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_traj</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_traj</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: trajectory of simulation nr </span><span class="si">%i</span><span class="s1"> has less then 1 uncorrelated simulation step!&#39;</span> <span class="o">%</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">corrtimes</span><span class="p">,</span> <span class="n">trajectories_decor</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">corrtimes</span></div>

<div class="viewcode-block" id="multivariate_normal"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.multivariate_normal">[docs]</a><span class="k">def</span> <span class="nf">multivariate_normal</span><span class="p">(</span><span class="n">means</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">covariance</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Wrapper around `numpy.random.multivariate_normal &lt;https://numpy.org/doc/stable/reference/random/generated/numpy.random.multivariate_normal.html&gt;`_ to handle `np.nan` columns in the covariance matrix. It also enforces symmetry on the covariance matrix to filter out non-symmetric noise. To generate the samples, Iit will first try the cholesky method in np.random.multivariate_normal as it is much faster. If that fails, the function tries again with the eigh setting and informs the user.</span>

<span class="sd">        :param means: Means of the multivariate normal distribution.</span>
<span class="sd">        :type means: np.ndarray</span>

<span class="sd">        :param covariance: Covariance matrix of the multivariate normal distribution.</span>
<span class="sd">        :type covariance: np.ndarray</span>

<span class="sd">        :param size: Number of samples to generate. If None, a single sample is generated</span>
<span class="sd">        :type size: int, list, np.ndarray or None, optional, default=None</span>

<span class="sd">        :return: the generated samples from the multivariate normal distribution</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#wrapper around np.random.multivariate_normal to deal with np.nan columns in the covariance matrix</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="c1">#loop over diagonal elements of cov matrix and if it is nan, check if entire row and column is nan and remove it</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">covariance</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">val</span><span class="p">):</span> <span class="c1">#the std_tol criterium is to assure that the covariance matrix will be positive definit (i.e. hass no zero eigenvalues)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">covariance</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Upon filtering np.nans from covariance matrix, found diagonal element </span><span class="si">%i</span><span class="s1"> that is nan, but not the entire row&#39;</span> <span class="o">%</span><span class="n">i</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">covariance</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Upon filtering np.nans from covariance matrix, found diagonal element </span><span class="si">%i</span><span class="s1"> that is nan, but not the entire column&#39;</span> <span class="o">%</span><span class="n">i</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mus</span> <span class="o">=</span> <span class="n">means</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">covariance</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">mask</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()])</span>
    <span class="c1">#enforce symmetric covariance matrix (filters out non-symmetric noise)</span>
    <span class="n">cov</span> <span class="o">+=</span> <span class="n">cov</span><span class="o">.</span><span class="n">T</span>
    <span class="n">cov</span> <span class="o">*=</span> <span class="mf">0.5</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">samples_cropped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cholesky&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: multivariate normal sampling failed using Cholesky decomposition, switching to method eigh.&#39;</span><span class="p">)</span>
        <span class="n">samples_cropped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mus</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;eigh&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">samples</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_cropped</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">size</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="p">)])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">samples</span><span class="p">[:,</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_cropped</span>
    <span class="k">return</span> <span class="n">samples</span></div>

<span class="c1"># Routines related to computing and inverting the fisher information matrix</span>

<div class="viewcode-block" id="invert_fisher_to_covariance"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.invert_fisher_to_covariance">[docs]</a><span class="k">def</span> <span class="nf">invert_fisher_to_covariance</span><span class="p">(</span><span class="n">F</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ps</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Inverts the Fisher information matrix to obtain the covariance matrix, handling specified thresholds.</span>

<span class="sd">        :param F: Fisher information matrix.</span>
<span class="sd">        :type F: np.ndarray</span>

<span class="sd">        :param ps: Array of probabilities used to apply the threshold.</span>
<span class="sd">        :type ps: np.ndarray</span>

<span class="sd">        :param threshold: Threshold value for removing columns and rows corresponding with a probability lower than the threshold from the Fisher information matrix.</span>
<span class="sd">        :type threshold: float, optional, default=0.0</span>

<span class="sd">        :param verbose: If `True`, print information about removed columns and rows.</span>
<span class="sd">        :type verbose: bool, optional, default=False</span>

<span class="sd">        :returns: Covariance matrix obtained by inverting the Fisher information matrix.</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="ow">or</span> <span class="n">ps</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">threshold</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;      ps[</span><span class="si">%i</span><span class="s1">]=</span><span class="si">%.3e</span><span class="s1">: removed column and row&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">ps</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">index</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">mask</span><span class="p">[:,</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N_mask2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N_mask2</span><span class="p">))</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N_mask2</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span> <span class="c1">#consistency check, sqrt(N_mask2) should be integer valued</span>
    <span class="n">N_mask</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N_mask2</span><span class="p">))</span>
    <span class="n">F_mask</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">N_mask</span><span class="p">,</span><span class="n">N_mask</span><span class="p">])</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">cov</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">F_mask</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N_mask2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cov</span></div>

<div class="viewcode-block" id="fisher_matrix_mle_probdens"><a class="viewcode-back" href="../../rg_tools.html#thermolib.tools.fisher_matrix_mle_probdens">[docs]</a><span class="k">def</span> <span class="nf">fisher_matrix_mle_probdens</span><span class="p">(</span><span class="n">ps</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;mle_f&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Computes the Fisher information matrix for the maximum likelihood estimation (MLE) of probability distribution parameters given in argument ps.</span>

<span class="sd">        :param ps: Probability histogram values</span>
<span class="sd">        :type ps: np.ndarray</span>

<span class="sd">        :param method: Method used for computing the Fisher information matrix. Options include &#39;mle_p&#39;, &#39;mle_p_cov&#39;, &#39;mle_f&#39;, and &#39;mle_f_cov&#39;.</span>
<span class="sd">        :type method: str, optional, default=&#39;mle_f&#39;</span>

<span class="sd">        :param verbose: If `True`, prints additional information when no Fisher information is found.</span>
<span class="sd">        :type verbose: bool, optional, default=False</span>

<span class="sd">        :return: Fisher information matrix computed for the maximum likelihood estimation of probability distribution parameters.</span>
<span class="sd">        :rtype: np.ndarray</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_p&#39;</span><span class="p">,</span> <span class="s1">&#39;mle_p_cov&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">F</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">p</span>
                    <span class="n">F</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_f&#39;</span><span class="p">,</span> <span class="s1">&#39;mle_f_cov&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">):</span>
                <span class="n">F</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">F</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span>
                <span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">p</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Error estimation method </span><span class="si">%s</span><span class="s1"> not supported to compute Fisher matrix of mle of probability distribution!&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;      No Fisher information found!&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F</span></div>

<span class="c1">#Set of old depricated routines that are only kept in ThermoLIB for backward compatibility. These routines will be removed in the near future, please use read_wham_input routine.</span>

<span class="k">def</span> <span class="nf">trajectory_xyz_to_CV</span><span class="p">(</span><span class="n">fns</span><span class="p">,</span> <span class="n">CV</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. deprecated:: 1.7</span>
<span class="sd">        </span>
<span class="sd">            Use :py:class:`CVComputer &lt;thermolib.trajectory.CVComputer&gt;` class instead. This old function is still included for backward compatibility, but it will be removed in the near future.</span>
<span class="sd">        </span>
<span class="sd">        Compute the CV along an XYZ trajectory. The XYZ trajectory is assumed to be defined in a (list of subsequent) XYZ file(s).</span>

<span class="sd">        :param fns: (list of) names of XYZ trajectory file(s) containing the xyz coordinates of the system</span>
<span class="sd">        :type fns: str or list(str)</span>

<span class="sd">        :param CV: collective variable defining how to compute the collective variable along the trajectory</span>
<span class="sd">        :type CV: one from thermolib.thermodynamics.cv.__all__</span>

<span class="sd">        :return: array containing the CV value along the trajectory</span>
<span class="sd">        :rtype: np.ndarray(flt)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cvs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">XYZReader</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">title</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">xyz</span><span class="p">:</span>
            <span class="n">cv</span> <span class="o">=</span> <span class="n">CV</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">cvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">xyz</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cvs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">read_wham_input_old</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">path_template_colvar_fns</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">colvar_cv_column_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kappa_unit</span><span class="o">=</span><span class="s1">&#39;kjmol&#39;</span><span class="p">,</span> <span class="n">q0_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias_potential</span><span class="o">=</span><span class="s1">&#39;Parabola1D&#39;</span><span class="p">,</span> <span class="n">additional_bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inverse_cv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. deprecated:: 1.7</span>
<span class="sd">        </span>
<span class="sd">            Use :py:meth:`read_wham_input &lt;thermolib.tools.read_wham_input&gt;` instead. This old function is still included for backward compatibility, but it will be removed in the near future.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">thermolib.thermodynamics.trajectory</span> <span class="kn">import</span> <span class="n">ColVarReader</span>
    <span class="n">trajectory_reader</span> <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">colvar_cv_column_index</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;au&#39;</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">read_wham_input</span><span class="p">(</span>
        <span class="n">fn</span><span class="p">,</span> 
        <span class="n">trajectory_reader</span><span class="p">,</span> <span class="n">trajectory_path_template</span><span class="o">=</span><span class="n">path_template_colvar_fns</span><span class="p">,</span> 
        <span class="n">bias_potential</span><span class="o">=</span><span class="n">bias_potential</span><span class="p">,</span> <span class="n">q01_unit</span><span class="o">=</span><span class="n">q0_unit</span><span class="p">,</span> <span class="n">kappa1_unit</span><span class="o">=</span><span class="n">kappa_unit</span><span class="p">,</span> <span class="n">inverse_cv1</span><span class="o">=</span><span class="n">inverse_cv</span><span class="p">,</span> 
        <span class="n">additional_bias</span><span class="o">=</span><span class="n">additional_bias</span><span class="p">,</span> 
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">read_wham_input_h5_old</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">h5_cv_path</span><span class="p">,</span> <span class="n">path_template_h5_fns</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">kappa_unit</span><span class="o">=</span><span class="s1">&#39;kjmol&#39;</span><span class="p">,</span> <span class="n">q0_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">cv_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias_potential</span><span class="o">=</span><span class="s1">&#39;Parabola1D&#39;</span><span class="p">,</span> <span class="n">additional_bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inverse_cv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. deprecated:: 1.7</span>
<span class="sd">        </span>
<span class="sd">            Use :py:meth:`read_wham_input &lt;thermolib.tools.read_wham_input&gt;` instead. This old function is still included for backward compatibility, but it will be removed in the near future.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">thermolib.thermodynamics.trajectory</span> <span class="kn">import</span> <span class="n">HDF5Reader</span>
    <span class="n">trajectory_reader</span> <span class="o">=</span> <span class="n">HDF5Reader</span><span class="p">([</span><span class="n">h5_cv_path</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">cv_unit</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">read_wham_input</span><span class="p">(</span>
        <span class="n">fn</span><span class="p">,</span> 
        <span class="n">trajectory_reader</span><span class="p">,</span> <span class="n">trajectory_path_template</span><span class="o">=</span><span class="n">path_template_h5_fns</span><span class="p">,</span> 
        <span class="n">bias_potential</span><span class="o">=</span><span class="n">bias_potential</span><span class="p">,</span> <span class="n">q01_unit</span><span class="o">=</span><span class="n">q0_unit</span><span class="p">,</span> <span class="n">kappa1_unit</span><span class="o">=</span><span class="n">kappa_unit</span><span class="p">,</span> <span class="n">inverse_cv1</span><span class="o">=</span><span class="n">inverse_cv</span><span class="p">,</span> 
        <span class="n">additional_bias</span><span class="o">=</span><span class="n">additional_bias</span><span class="p">,</span> 
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">read_wham_input_2D_old</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">path_template_colvar_fns</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">colvar_cv1_column_index</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">colvar_cv2_column_index</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">kappa1_unit</span><span class="o">=</span><span class="s1">&#39;kjmol&#39;</span><span class="p">,</span> <span class="n">kappa2_unit</span><span class="o">=</span><span class="s1">&#39;kjmol&#39;</span><span class="p">,</span> <span class="n">q01_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">q02_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias_potential</span><span class="o">=</span><span class="s1">&#39;Parabola2D&#39;</span><span class="p">,</span><span class="n">additional_bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">additional_bias_dimension</span><span class="o">=</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span><span class="n">inverse_cv1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">inverse_cv2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. deprecated:: 1.7</span>
<span class="sd">        </span>
<span class="sd">            Use :py:meth:`read_wham_input &lt;thermolib.tools.read_wham_input&gt;` instead. This old function is still included for backward compatibility, but it will be removed in the near future.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">thermolib.thermodynamics.trajectory</span> <span class="kn">import</span> <span class="n">ColVarReader</span>
    <span class="n">trajectory_reader</span> <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">colvar_cv1_column_index</span><span class="p">,</span> <span class="n">colvar_cv2_column_index</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;au&#39;</span><span class="p">,</span><span class="s1">&#39;au&#39;</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">read_wham_input</span><span class="p">(</span>
        <span class="n">fn</span><span class="p">,</span> 
        <span class="n">trajectory_reader</span><span class="p">,</span> <span class="n">trajectory_path_template</span><span class="o">=</span><span class="n">path_template_colvar_fns</span><span class="p">,</span> 
        <span class="n">bias_potential</span><span class="o">=</span><span class="n">bias_potential</span><span class="p">,</span> <span class="n">q01_unit</span><span class="o">=</span><span class="n">q01_unit</span><span class="p">,</span> <span class="n">q02_unit</span><span class="o">=</span><span class="n">q02_unit</span><span class="p">,</span> <span class="n">kappa1_unit</span><span class="o">=</span><span class="n">kappa1_unit</span><span class="p">,</span> <span class="n">kappa2_unit</span><span class="o">=</span><span class="n">kappa2_unit</span><span class="p">,</span> 
        <span class="n">inverse_cv1</span><span class="o">=</span><span class="n">inverse_cv1</span><span class="p">,</span> <span class="n">inverse_cv2</span><span class="o">=</span><span class="n">inverse_cv2</span><span class="p">,</span>
        <span class="n">additional_bias</span><span class="o">=</span><span class="n">additional_bias</span><span class="p">,</span> <span class="n">additional_bias_dimension</span><span class="o">=</span><span class="n">additional_bias_dimension</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">read_wham_input_2D_h5_old</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">h5_cv1_path</span><span class="p">,</span> <span class="n">h5_cv2_path</span><span class="p">,</span> <span class="n">path_template_h5_fns</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">kappa1_unit</span><span class="o">=</span><span class="s1">&#39;kjmol&#39;</span><span class="p">,</span> <span class="n">kappa2_unit</span><span class="o">=</span><span class="s1">&#39;kjmol&#39;</span><span class="p">,</span> <span class="n">q01_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">q02_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">cv1_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">cv2_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias_potential</span><span class="o">=</span><span class="s1">&#39;Parabola2D&#39;</span><span class="p">,</span> <span class="n">additional_bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">additional_bias_dimension</span><span class="o">=</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="n">inverse_cv1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inverse_cv2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. deprecated:: 1.7</span>
<span class="sd">        </span>
<span class="sd">            Use :py:meth:`read_wham_input &lt;thermolib.tools.read_wham_input&gt;` instead. This old function is still included for backward compatibility, but it will be removed in the near future.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">thermolib.thermodynamics.trajectory</span> <span class="kn">import</span> <span class="n">HDF5Reader</span>
    <span class="n">trajectory_reader</span> <span class="o">=</span> <span class="n">HDF5Reader</span><span class="p">([</span><span class="n">h5_cv1_path</span><span class="p">,</span> <span class="n">h5_cv2_path</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">cv1_unit</span><span class="p">,</span><span class="n">cv2_unit</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">read_wham_input</span><span class="p">(</span>
        <span class="n">fn</span><span class="p">,</span> 
        <span class="n">trajectory_reader</span><span class="p">,</span> <span class="n">trajectory_path_template</span><span class="o">=</span><span class="n">path_template_h5_fns</span><span class="p">,</span> 
        <span class="n">bias_potential</span><span class="o">=</span><span class="n">bias_potential</span><span class="p">,</span> <span class="n">q01_unit</span><span class="o">=</span><span class="n">q01_unit</span><span class="p">,</span> <span class="n">q02_unit</span><span class="o">=</span><span class="n">q02_unit</span><span class="p">,</span> <span class="n">kappa1_unit</span><span class="o">=</span><span class="n">kappa1_unit</span><span class="p">,</span> <span class="n">kappa2_unit</span><span class="o">=</span><span class="n">kappa2_unit</span><span class="p">,</span> 
        <span class="n">inverse_cv1</span><span class="o">=</span><span class="n">inverse_cv1</span><span class="p">,</span> <span class="n">inverse_cv2</span><span class="o">=</span><span class="n">inverse_cv2</span><span class="p">,</span>
        <span class="n">additional_bias</span><span class="o">=</span><span class="n">additional_bias</span><span class="p">,</span> <span class="n">additional_bias_dimension</span><span class="o">=</span><span class="n">additional_bias_dimension</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
    <span class="p">)</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Louis Vanduyfhuys.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>