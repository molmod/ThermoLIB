<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>thermolib.thermodynamics.condprob &mdash; ThermoLIB v1.7.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=131c94de"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ThermoLIB
              <img src="../../../_static/logo_thermolib_light.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.7
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../ig.html">Installation Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ig.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ig.html#download-and-install-thermolib">Download and install ThermoLIB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ig.html#direct-install-using-pip">Direct install using pip</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ig.html#developers-download">Developers download</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ig.html#test-installation">Test installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../ug.html">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_1DFEP.html">Constructing 1D histograms &amp; free energy profiles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_1DFEP.html#construct-a-1d-histrogam">Construct a 1D histrogam …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#from-a-single-simulation">… from a single simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#from-multiple-simulations-using-wham">… from multiple simulations using WHAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_1DFEP.html#constructing-a-1d-free-energy-profile">Constructing a 1D free energy profile …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#using-the-constructor">… using the constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#reading-from-a-text-file">… reading from a text file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_1DFEP.html#from-a-histogram">… from a histogram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_2DFES.html">Constructing 2D histograms &amp; free energy surfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_2DFES.html#constructing-a-2d-histogram">Constructing a 2D histogram …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#from-single-simulation">… from single simulation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#from-multiple-simulations-using-wham">… from multiple simulations using WHAM</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_2DFES.html#constructing-a-2d-free-energy-surface">Constructing a 2D free energy surface …</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#using-the-constructor">… using the constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#reading-from-a-text-file">… reading from a text file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../ug_2DFES.html#from-a-histogram">… from a histogram</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_corrtime.html">Computing the correlation time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_corrtime.html#fit-to-autocorrelation-function-for-single-trajectory">Fit to autocorrelation function for single trajectory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_corrtime.html#compute-correlation-time-for-trajectory-series">Compute correlation time for trajectory series</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_error.html">Error estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_error.html#without-correlations">Without correlations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_error.html#with-correlations">With correlations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_plotting.html">Plotting histograms and FEP/FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_plotting.html#d-histograms-free-energy-profile">1D Histograms &amp; free energy profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_plotting.html#d-histograms-free-energy-surfaces">2D Histograms &amp; free energy surfaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_micromacro.html">Extracting micro- and macrostate free energy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_kinetics.html">Computing the reaction rate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_transformation.html">Transformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_transformation.html#deterministic-transformation">Deterministic transformation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_transformation.html#probabilistic-transformation">Probabilistic transformation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../ug_projection.html">(De)projections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_projection.html#projecting-2d-fes-to-1d-fep">Projecting 2D FES to 1D FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../ug_projection.html#deprojecting-1d-fep-to-2d-fes">Deprojecting 1D FEP to 2D FES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/basic_wham1d.html">Tutorial 1 - Construction of 1D free energy profile using WHAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham1d.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham1d.html#WHAM-without-error-estimation">WHAM without error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham1d.html#WHAM-with-error-estimation">WHAM with error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham1d.html#Defining-macrostates-and-microstates">Defining macrostates and microstates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/basic_kinetics.html">Tutorial 2 - Extracting kinetic reaction rates in 1D</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_kinetics.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_kinetics.html#Construct-free-energy-profile">Construct free energy profile</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_kinetics.html#Compute-rate-prefactor">Compute rate prefactor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_kinetics.html#Add-kinetic-information-to-FEP-plot">Add kinetic information to FEP plot</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/basic_wham2d.html">Tutorial 3 - Construction of 2D free energy surface using WHAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham2d.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham2d.html#2D-WHAM-without-error-estimation">2D WHAM without error estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham2d.html#2D-WHAM-with-error-estimate">2D WHAM with error estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/basic_wham2d.html#Alternative-plotting">Alternative plotting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/advanced_error_estimation.html">Tutorial 4 - Advanced techniques in error estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Impact-correlation-between-samples-on-FEP">Impact correlation between samples on FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Estimating-the-autocorrelation-time">Estimating the autocorrelation time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Constructing-the-FEP-with-correlated-error-estimate">Constructing the FEP with correlated error estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Evaluating-the-correlated-error-estimate">Evaluating the correlated error estimate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Delayed-strided-WHAM-profiles">Delayed-strided WHAM profiles</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Blocked-WHAM-profile">Blocked WHAM profile</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Bootstrapped-WHAM-profiles">Bootstrapped WHAM profiles</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Covariance-between-different-points-on-FEP">Covariance between different points on FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_error_estimation.html#Error-propagation">Error propagation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/advanced_projection.html">Tutorial 5 - Projection of 2D FES to 1D FEP with error propagation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_projection.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_projection.html#Constructing-2D-FES">Constructing 2D FES</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_projection.html#Projection-onto-1D-profile">Projection onto 1D profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_projection.html#Along-predefined-direction">Along predefined direction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_projection.html#Along-any-custom-direction">Along any custom direction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_projection.html#Error-propagation">Error propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_projection.html#Deal-with-the-unsufficiently-sampled-edges-of-phase-space-in-FES-projection">Deal with the unsufficiently sampled edges of phase space in FES projection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/advanced_deprojection.html">Tutorial 6 - Deprojecting 1D FEP to 2D FES</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Construct-1D-FEP">Construct 1D FEP</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Deproject-to-2D-FES">Deproject to 2D FES</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Direct-route---2D-WHAM">Direct route - 2D WHAM</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Indirect-route---deproject-1D-FEP">Indirect route - deproject 1D FEP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#CONSISTENCY-CHECK:-project-2D-FES-to-1D-FEP">CONSISTENCY CHECK: project 2D FES to 1D FEP</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_deprojection.html#U(CV)-profile">U(CV) profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Method-1---from-2D-FES">Method 1 - from 2D FES</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#Method-2---from-conditional-probability">Method 2 - from conditional probability</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../tut/advanced_deprojection.html#comparison">comparison</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../tut/advanced_transformations.html">Tutorial 7 - Transformations of 1D FEP and kinetics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_transformations.html#Introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_transformations.html#FEP-and-rate-with-original-CV">FEP and rate with original CV</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tut/advanced_transformations.html#FEP-and-rate-in-terms-of-alternative-CV">FEP and rate in terms of alternative CV</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../rg.html">Reference Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_thermo.html">Thermodynamics – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.fep">Free energy profiles – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.fep</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.BaseFreeEnergyProfile"><code class="docutils literal notranslate"><span class="pre">BaseFreeEnergyProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.BaseProfile"><code class="docutils literal notranslate"><span class="pre">BaseProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.FreeEnergySurface2D"><code class="docutils literal notranslate"><span class="pre">FreeEnergySurface2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.SimpleFreeEnergyProfile"><code class="docutils literal notranslate"><span class="pre">SimpleFreeEnergyProfile</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.fep.plot_profiles"><code class="docutils literal notranslate"><span class="pre">plot_profiles()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.histogram">Histograms – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.histogram</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.histogram.Histogram1D"><code class="docutils literal notranslate"><span class="pre">Histogram1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.histogram.Histogram2D"><code class="docutils literal notranslate"><span class="pre">Histogram2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.histogram.plot_histograms"><code class="docutils literal notranslate"><span class="pre">plot_histograms()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.trajectory">Trajectory readers – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.trajectory</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.trajectory.ASEExtendedXYZReader"><code class="docutils literal notranslate"><span class="pre">ASEExtendedXYZReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.trajectory.CVComputer"><code class="docutils literal notranslate"><span class="pre">CVComputer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.trajectory.ColVarReader"><code class="docutils literal notranslate"><span class="pre">ColVarReader</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.trajectory.HDF5Reader"><code class="docutils literal notranslate"><span class="pre">HDF5Reader</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.bias">Bias potentials – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.bias</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.BiasPotential1D"><code class="docutils literal notranslate"><span class="pre">BiasPotential1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.BiasPotential2D"><code class="docutils literal notranslate"><span class="pre">BiasPotential2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.MultipleBiasses1D"><code class="docutils literal notranslate"><span class="pre">MultipleBiasses1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.Parabola1D"><code class="docutils literal notranslate"><span class="pre">Parabola1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.Parabola2D"><code class="docutils literal notranslate"><span class="pre">Parabola2D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.PlumedSplinePotential1D"><code class="docutils literal notranslate"><span class="pre">PlumedSplinePotential1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.bias.Polynomial1D"><code class="docutils literal notranslate"><span class="pre">Polynomial1D</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.cv">Collective variables – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.cv</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.Average"><code class="docutils literal notranslate"><span class="pre">Average</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.CoordinationNumber"><code class="docutils literal notranslate"><span class="pre">CoordinationNumber</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.Difference"><code class="docutils literal notranslate"><span class="pre">Difference</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.DistOrthProjOrig"><code class="docutils literal notranslate"><span class="pre">DistOrthProjOrig</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.Distance"><code class="docutils literal notranslate"><span class="pre">Distance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.DistanceCOP"><code class="docutils literal notranslate"><span class="pre">DistanceCOP</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.DotProduct"><code class="docutils literal notranslate"><span class="pre">DotProduct</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.LinearCombination"><code class="docutils literal notranslate"><span class="pre">LinearCombination</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.Minimum"><code class="docutils literal notranslate"><span class="pre">Minimum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.NormalizedAxis"><code class="docutils literal notranslate"><span class="pre">NormalizedAxis</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.cv.OrthogonalDistanceToPore"><code class="docutils literal notranslate"><span class="pre">OrthogonalDistanceToPore</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.state">State – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.state</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.state.Integrate"><code class="docutils literal notranslate"><span class="pre">Integrate</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.state.Maximum"><code class="docutils literal notranslate"><span class="pre">Maximum</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.state.Minimum"><code class="docutils literal notranslate"><span class="pre">Minimum</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_thermo.html#module-thermolib.thermodynamics.condprob">Conditional probability – <code class="docutils literal notranslate"><span class="pre">thermolib.thermodynamics.condprob</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D"><code class="docutils literal notranslate"><span class="pre">ConditionalProbability1D1D</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D"><code class="docutils literal notranslate"><span class="pre">ConditionalProbability1D2D</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_kin.html">Kinetics – <code class="docutils literal notranslate"><span class="pre">thermolib.kinetics</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_kin.html#module-thermolib.kinetics.rate">Rate constant – <code class="docutils literal notranslate"><span class="pre">thermolib.kinetics.rate</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_kin.html#thermolib.kinetics.rate.RateFactorEquilibrium"><code class="docutils literal notranslate"><span class="pre">RateFactorEquilibrium</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_error.html">Error distributions – <code class="docutils literal notranslate"><span class="pre">thermolib.error</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.Distribution"><code class="docutils literal notranslate"><span class="pre">Distribution</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.GaussianDistribution"><code class="docutils literal notranslate"><span class="pre">GaussianDistribution</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.LogGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">LogGaussianDistribution</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.MultiGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_error.html#thermolib.error.MultiGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">MultiGaussianDistribution.from_samples()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.MultiLogGaussianDistribution"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../rg_error.html#thermolib.error.MultiLogGaussianDistribution.from_samples"><code class="docutils literal notranslate"><span class="pre">MultiLogGaussianDistribution.from_samples()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.Propagator"><code class="docutils literal notranslate"><span class="pre">Propagator</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_error.html#thermolib.error.SampleDistribution"><code class="docutils literal notranslate"><span class="pre">SampleDistribution</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_tools.html">Tools – <code class="docutils literal notranslate"><span class="pre">thermolib.tools</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.blav"><code class="docutils literal notranslate"><span class="pre">blav()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.corrtime_from_acf"><code class="docutils literal notranslate"><span class="pre">corrtime_from_acf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.decorrelate"><code class="docutils literal notranslate"><span class="pre">decorrelate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.extract_polynomial_bias_info"><code class="docutils literal notranslate"><span class="pre">extract_polynomial_bias_info()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.fisher_matrix_mle_probdens"><code class="docutils literal notranslate"><span class="pre">fisher_matrix_mle_probdens()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.format_scientific"><code class="docutils literal notranslate"><span class="pre">format_scientific()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.h5_read_dataset"><code class="docutils literal notranslate"><span class="pre">h5_read_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.integrate"><code class="docutils literal notranslate"><span class="pre">integrate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.integrate2d"><code class="docutils literal notranslate"><span class="pre">integrate2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.invert_fisher_to_covariance"><code class="docutils literal notranslate"><span class="pre">invert_fisher_to_covariance()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.multivariate_normal"><code class="docutils literal notranslate"><span class="pre">multivariate_normal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.read_wham_input"><code class="docutils literal notranslate"><span class="pre">read_wham_input()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_tools.html#thermolib.tools.rolling_average"><code class="docutils literal notranslate"><span class="pre">rolling_average()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../rg_ext.html">Extensions – <code class="docutils literal notranslate"><span class="pre">thermolib.ext</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham1d_bias"><code class="docutils literal notranslate"><span class="pre">wham1d_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham1d_error"><code class="docutils literal notranslate"><span class="pre">wham1d_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham1d_hs"><code class="docutils literal notranslate"><span class="pre">wham1d_hs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham1d_scf"><code class="docutils literal notranslate"><span class="pre">wham1d_scf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham2d_bias"><code class="docutils literal notranslate"><span class="pre">wham2d_bias()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham2d_error"><code class="docutils literal notranslate"><span class="pre">wham2d_error()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham2d_hs"><code class="docutils literal notranslate"><span class="pre">wham2d_hs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rg_ext.html#thermolib.ext.wham2d_scf"><code class="docutils literal notranslate"><span class="pre">wham2d_scf()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ThermoLIB</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">thermolib.thermodynamics.condprob</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for thermolib.thermodynamics.condprob</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2019 - 2024 Louis Vanduyfhuys &lt;Louis.Vanduyfhuys@UGent.be&gt;</span>
<span class="c1"># Center for Molecular Modeling (CMM), Ghent University, Ghent, Belgium;</span>
<span class="c1"># all rights reserved unless otherwise stated.</span>
<span class="c1">#</span>
<span class="c1"># This file is part of a library developed by Louis Vanduyfhuys at</span>
<span class="c1"># the Center for Molecular Modeling under supervision of prof. Veronique</span>
<span class="c1"># Van Speybroeck. Usage of this package should be authorized by prof. Van</span>
<span class="c1"># Vanduyfhuys or prof. Van Speybroeck.</span>

<span class="kn">from</span> <span class="nn">molmod.units</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molmod.constants</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">molmod.io.xyz</span> <span class="kn">import</span> <span class="n">XYZReader</span>

<span class="kn">from</span> <span class="nn">ase.io</span> <span class="kn">import</span> <span class="n">read</span>

<span class="kn">from</span> <span class="nn">..tools</span> <span class="kn">import</span> <span class="n">integrate2d</span><span class="p">,</span> <span class="n">invert_fisher_to_covariance</span><span class="p">,</span> <span class="n">fisher_matrix_mle_probdens</span>
<span class="kn">from</span> <span class="nn">.fep</span> <span class="kn">import</span> <span class="n">BaseProfile</span><span class="p">,</span> <span class="n">BaseFreeEnergyProfile</span><span class="p">,</span> <span class="n">FreeEnergySurface2D</span>
<span class="kn">from</span> <span class="nn">..error</span> <span class="kn">import</span> <span class="n">ncycles_default</span><span class="p">,</span> <span class="n">Propagator</span><span class="p">,</span> <span class="n">GaussianDistribution</span><span class="p">,</span> <span class="n">LogGaussianDistribution</span><span class="p">,</span> <span class="n">MultiGaussianDistribution</span><span class="p">,</span> <span class="n">MultiLogGaussianDistribution</span><span class="p">,</span> <span class="n">ErrorArray</span>
<span class="kn">from</span> <span class="nn">.trajectory</span> <span class="kn">import</span> <span class="n">CVComputer</span><span class="p">,</span> <span class="n">ColVarReader</span>
<span class="kn">from</span> <span class="nn">..flatten</span> <span class="kn">import</span> <span class="n">Flattener</span>
<span class="c1">#from thermolib.ext import fisher_matrix_mle_probdens, invert_fisher_to_covariance</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">rc</span>
<span class="n">rc</span><span class="p">(</span><span class="s1">&#39;font&#39;</span><span class="p">,</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;family&#39;</span><span class="p">:</span><span class="s1">&#39;sans-serif&#39;</span><span class="p">,</span><span class="s1">&#39;sans-serif&#39;</span><span class="p">:[</span><span class="s1">&#39;Helvetica&#39;</span><span class="p">]})</span>
<span class="n">rc</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ConditionalProbability1D1D&#39;</span><span class="p">,</span> <span class="s1">&#39;ConditionalProbability1D2D&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ConditionalProbability</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Class to compute conditional probabilities of the form :math:`p([qs]|[cvs])`, i.e. probability of finding states characterized with collective variables qs, on the condition that the states are also characterized by collective variables cvs. Such conditional probabiliy allows to convert a free energy surface (or profile if only one cv is given) in terms of the collective variables :math:`cvs` to a free energy surface (or profile if only one q is given) in terms of the collective variables :math:`qs`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nq</span><span class="p">,</span> <span class="n">ncv</span><span class="p">,</span> <span class="n">q_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param nq: dimension of q-space</span>
<span class="sd">            :type nq: int</span>

<span class="sd">            :param ncv: dimension of cv-space</span>
<span class="sd">            :type ncv: int</span>

<span class="sd">            :param q_labels: list of labels (one for each q) to be used in plots or prints, defaults to [&#39;Q1&#39;, [&#39;Q2&#39;, [...]]]</span>
<span class="sd">            :type q_labels: list of strings, optional</span>

<span class="sd">            :param cv_labels: list of labels (one for each cv) to be used in plots or prints, defaults to [&#39;CV1&#39;, [&#39;CV2&#39;, [...]]]</span>
<span class="sd">            :type cv_labels: list of strings, optional</span>

<span class="sd">            :param q_units: list of units (one for each q) to be used in plots or prints, defaults to [&#39;au&#39;, [&#39;au&#39;, [...]]]</span>
<span class="sd">            :type q_units: list of strings, optional</span>

<span class="sd">            :param cv_labels: list of units (one for each cv) to be used in plots or prints, defaults to [&#39;au&#39;, [&#39;au&#39;, [...]]]</span>
<span class="sd">            :type cv_labels: list of strings, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">=</span> <span class="n">nq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span> <span class="o">=</span> <span class="n">ncv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">if</span> <span class="n">q_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Q</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nq</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span> <span class="o">=</span> <span class="n">q_labels</span>
        <span class="k">if</span> <span class="n">cv_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CV</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncv</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span> <span class="o">=</span> <span class="n">cv_labels</span>
        <span class="k">if</span> <span class="n">q_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;au&#39;</span><span class="p">,]</span><span class="o">*</span><span class="n">nq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_units</span> <span class="o">=</span> <span class="n">q_units</span>
        <span class="k">if</span> <span class="n">cv_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;au&#39;</span><span class="p">,]</span><span class="o">*</span><span class="n">ncv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span> <span class="o">=</span> <span class="n">cv_units</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#correlation time in q samples in each simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples_persim</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#number of samples in each simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># number of simulations</span>

    <span class="k">def</span> <span class="nf">init_bins_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_bins</span><span class="p">,</span> <span class="n">cv_bins</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param q_bins: list of numpy arrays, each array corresponding to the bin edges for one of the Qs. Alternatively, a single numpy array can be given which is then interpreted as the bin edges for all of the Qs.</span>
<span class="sd">            :type q_bins: list or numpy array, optional</span>

<span class="sd">            :param cv_bins: list of numpy arrays, each array corresponding to the bin edges for one of the CVs. Alternatively, a single numpy array can be given which is then interpreted as the bin edges for all of the CVs.</span>
<span class="sd">            :type cv_bins: list or numpy array, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initializing grids for CV and Q ...&#39;</span><span class="p">)</span>
        <span class="c1">#type checking and storing of input arguments</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_bins</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">q_bins</span><span class="p">)</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">,</span> <span class="s1">&#39;When q_bins is a list, it should contain a number of arrays equal to the number of Qs (=</span><span class="si">%i</span><span class="s1">) corresponding to the edges for each Q, but instead got a list of length </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">q_bins</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">q_bins</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;When q_bins is a list, all its elements should be a numpy array containing the bin edges of the corresponding Q.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;Argument q_bins should be a list of numpy arrays, one array for each Q, or a single numpy array valid for each Q&#39;</span>
            <span class="n">q_bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">q_bins</span><span class="p">,]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_bins</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cv_bins</span><span class="p">)</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="s1">&#39;When cv_bins is a list, it should contain a number of arrays equal to the number of CVs (=</span><span class="si">%i</span><span class="s1">) corresponding to the edges for each CV, but instead got a list of length </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cv_bins</span><span class="p">))</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cv_bins</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;When cv_bins is a list, all its elements should be a numpy array containing the bin edges of the corresponding CV.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;Argument cv_bins should be a list of numpy arrays, one array for each CV, or a single numpy array valid for each CV&#39;</span>
            <span class="n">cv_bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv_bins</span><span class="p">,]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span> <span class="o">=</span> <span class="n">q_bins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span> <span class="o">=</span> <span class="n">cv_bins</span>
        <span class="c1">#construct grids for q, cv and q+cv, useful for iterating over later</span>
        <span class="c1">#self.qs is just a list of the bin centers for each q</span>
        <span class="c1">#self.q_grid is a meshgrid of the bin centers</span>
        <span class="c1">#same for cv</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="c1">#self.q_grid = self.qs[0]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qs</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="c1">#self.cv_grid = self.cvs[0]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span> <span class="o">=</span> <span class="p">[</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">b</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_q_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_q</span><span class="p">,</span> <span class="n">input_cv</span><span class="p">,</span> <span class="n">corr_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            extracting data samples of CVs and QS from given files that later will be histogrammed per value of CVs.</span>

<span class="sd">            :param input_q: list of tuples of the form (fn, reader), one for each Q to be included, with fn the file name of the trajectory from which reader will extract the q-values</span>
<span class="sd">            :type input_q: list of tuples</span>

<span class="sd">            :param input_cv: list of tuples of the form (fn, reader), one for each CV to be included, with fn the file name of the trajectory from which reader will extract the cv-values</span>
<span class="sd">            :type input_cv: list of tuples</span>

<span class="sd">            :param finish: set this to True if the given file name(s) are the only relevant trajectories and hence the conditional probability should be computed from only these trajectories. Setting it to True will therefore trigger propper normalisation of the conditional probability. Set this to False if you intend to call the routine *process_trajectory_xyz* again later on with additional trajectory files.</span>
<span class="sd">            :type finish: bool, optional, default=True</span>
<span class="sd">            </span>
<span class="sd">            :param corr_times: only relevant if error estimation is also desired, in which case corr_time represent the correlation time within the Q samples which will be used for more accurate error estimation.</span>
<span class="sd">            :type corr_times_q: float, optional, default=1.0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#init</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot read additional XYZ trajectory because current conditional probability has already been finished.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processing simulation </span><span class="si">%i</span><span class="s1">  &#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">))</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">q_samples</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cv_samples</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1">#extracting Q samples</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reader</span> <span class="ow">in</span> <span class="n">input_q</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  reading samples for </span><span class="si">%s</span><span class="s1"> from file </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">q_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">q_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q_samples</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="n">num_samples</span><span class="p">,</span> <span class="s1">&#39;Each Q reader should detect equal number of samples for the same simulation!&#39;</span>
            <span class="c1">#estimating number of independent Q-samples</span>

        <span class="c1">#extracting CV samples</span>
        <span class="k">for</span> <span class="n">fn</span><span class="p">,</span> <span class="n">reader</span> <span class="ow">in</span> <span class="n">input_cv</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  reading samples for </span><span class="si">%s</span><span class="s1"> from file </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="n">num_samples</span><span class="p">,</span> <span class="s1">&#39;Each CV reader should detect equal number of samples as all other Qs and CVs for the same simulation!&#39;</span>
            <span class="k">if</span> <span class="n">cv_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cv_samples</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cv_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_samples</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#some final bookkeeping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_time</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  detected </span><span class="si">%i</span><span class="s1"> samples, from which </span><span class="si">%i</span><span class="s1"> independent (correlation time = </span><span class="si">%i</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">/</span><span class="n">corr_time</span><span class="p">,</span> <span class="n">corr_time</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cv_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Set the reference value of the Q and/or CV samples.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#set q references</span>
        <span class="k">if</span> <span class="n">q_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting Q reference&#39;</span><span class="p">)</span>
            <span class="c1">#check and init q_indices</span>
            <span class="k">if</span> <span class="n">q_index</span><span class="o">==</span><span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">q_index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">q_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">q_index</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_index</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">q_index</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;q_index should be integer, list of integers or &#39;all&#39;. Received </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q_index</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q_index should be integer, list of integers or &#39;all&#39;. Received </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q_index</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="n">q_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  of Q</span><span class="si">%i</span><span class="s1"> to </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">iq</span><span class="p">,</span><span class="n">q_ref</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="c1">#check and init reference value</span>
                <span class="k">if</span> <span class="n">q_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;global_minimum&#39;</span><span class="p">]:</span>
                    <span class="n">q_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                        <span class="n">q_ref</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">q_ref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">iq</span><span class="p">])])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;which is </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">q_ref</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">q_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;minimum_average&#39;</span><span class="p">]:</span>
                    <span class="n">q_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                        <span class="n">q_ref</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">q_ref</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">iq</span><span class="p">])])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;which is </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">q_ref</span><span class="p">))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">q_ref</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q_ref should be either &#39;global_minimum&#39;, &#39;minimum_average&#39; or a float value&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="c1">#set ref</span>
                <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">iq</span><span class="p">]</span> <span class="o">-=</span> <span class="n">q_ref</span>
        <span class="c1">#set q references</span>
        <span class="k">if</span> <span class="n">cv_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting CV reference&#39;</span><span class="p">)</span>
            <span class="c1">#check and init cv_indices</span>
            <span class="k">if</span> <span class="n">cv_index</span><span class="o">==</span><span class="s1">&#39;all&#39;</span><span class="p">:</span>
                <span class="n">cv_index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">cv_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_index</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">cv_index</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;cv_index should be integer, list of integers or &#39;all&#39;. Received </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cv_index</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cv_index should be integer, list of integers or &#39;all&#39;. Received </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cv_index</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">icv</span> <span class="ow">in</span> <span class="n">cv_index</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  of CV</span><span class="si">%i</span><span class="s1"> to </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">icv</span><span class="p">,</span><span class="n">cv_ref</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="c1">#check and init reference value</span>
                <span class="k">if</span> <span class="n">cv_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;global_minimum&#39;</span><span class="p">]:</span>
                    <span class="n">cv_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                        <span class="n">cv_ref</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">cv_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;which is </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">cv_ref</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">cv_ref</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;minimum_average&#39;</span><span class="p">]:</span>
                    <span class="n">cv_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                        <span class="n">cv_ref</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">cv_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;which is </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">cv_ref</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cv_ref</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cv_ref should be either &#39;global_minimum&#39;, &#39;minimum_average&#39; or a float value&quot;</span><span class="p">)</span>
                <span class="c1">#set ref</span>
                <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">icv</span><span class="p">]</span> <span class="o">-=</span> <span class="n">cv_ref</span>
    
    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_bins</span><span class="p">,</span> <span class="n">cv_bins</span><span class="p">,</span> <span class="n">error_estimate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">error_p_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param q_bins: see init_bins_grids</span>
<span class="sd">            :type q_bins: see init_bins_grids</span>

<span class="sd">            :param cv_bins: see init_bins_grids</span>
<span class="sd">            :type cv_bins: see init_bins_grids</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t finish current conditional probability as it has already been finished.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finishing conditional probability&#39;</span><span class="p">)</span>
        <span class="c1">#init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconds_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">histcounts_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">histnorms_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fishers_persim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#set grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_bins_grids</span><span class="p">(</span><span class="n">q_bins</span><span class="p">,</span> <span class="n">cv_bins</span><span class="p">)</span>

        <span class="c1">#loop over each simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span><span class="p">)</span>
        <span class="n">Htot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_q_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">Ntot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  constructing histograms for all simulations&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
            <span class="c1">#compute and store histograms from current simulations</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">H</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_bins</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span><span class="p">)</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">cv_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_samples_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_bins</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">histcounts_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">histnorms_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="c1">#add histograms to global histogram</span>
            <span class="n">Ntot</span> <span class="o">+=</span> <span class="n">N</span>
            <span class="n">Htot</span> <span class="o">+=</span> <span class="n">H</span>
            <span class="c1">#compute and store corresponding conditional probability from current simulation</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">cv_index</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">cv_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span>
                    <span class="n">Ncurrent</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">invNcurrent</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncurrent</span>
                    <span class="k">else</span><span class="p">:</span>          <span class="n">invNcurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Ncurrent</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
                    <span class="n">invNcurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ncurrent</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">invNcurrent</span><span class="p">[</span><span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncurrent</span><span class="p">[</span><span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ps</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">+</span> <span class="n">cv_index</span> <span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">+</span> <span class="n">cv_index</span> <span class="p">]</span><span class="o">*</span><span class="n">invNcurrent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pconds_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  constructing global conditional probability&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Htot</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">cv_index</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">cv_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span>
                <span class="n">Ncurrent</span> <span class="o">=</span> <span class="n">Ntot</span><span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">invNcurrent</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncurrent</span>
                <span class="k">else</span><span class="p">:</span>          <span class="n">invNcurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Ncurrent</span> <span class="o">=</span> <span class="n">Ntot</span><span class="p">[</span><span class="n">cv_index</span><span class="p">]</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">Ncurrent</span><span class="o">&gt;</span><span class="mi">0</span>
                <span class="n">invNcurrent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Ncurrent</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">invNcurrent</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">Ncurrent</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">+</span> <span class="n">cv_index</span> <span class="p">]</span> <span class="o">=</span> <span class="n">Htot</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">+</span> <span class="n">cv_index</span> <span class="p">]</span><span class="o">*</span><span class="n">invNcurrent</span>

        <span class="c1">#define error bars based on Fisher matrix is implemented in inheriting classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">error_estimate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finish_error</span><span class="p">(</span><span class="n">error_estimate</span><span class="p">,</span> <span class="n">error_p_threshold</span><span class="o">=</span><span class="n">error_p_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span> <span class="o">=</span> <span class="kc">True</span>
        
    <span class="k">def</span> <span class="nf">finish_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_estimate</span><span class="p">,</span> <span class="n">error_p_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Error estimation not yet implemented for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slicer</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obss</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">linestyles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ylims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">croplims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;rainbow&#39;</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Plot self.pconds[slicer], where slicer needs to be chosen such that self.pconds[slice] is 1D or 2D. The resulting graph will respectively by a regular 1D plot or 2D contourplot.</span>

<span class="sd">            :param fn: name of the file to store graph in, defaults to &#39;condprob.png&#39;</span>
<span class="sd">            :type fn: str, optional</span>

<span class="sd">            :param x_unit: unit to be used for the cv/q on the x-axis, defaults to &#39;au&#39;</span>
<span class="sd">            :type x_unit: str, optional</span>

<span class="sd">            :param y_unit: unit to be used for the cv/q on the y-axis, only relevant when 2D contourplot is made, defaults to &#39;au&#39;</span>
<span class="sd">            :type y_unit: str, optional</span>

<span class="sd">            :param x_label: label to be used for the cv/q on the x-axis, defaults to &#39;Q&#39;/&#39;Q1&#39; for q-data or &#39;CV&#39;/&#39;CV1&#39; for cv-data</span>
<span class="sd">            :type x_label: str, optional</span>

<span class="sd">            :param y_label: label to be used for the cv/q on the x-axis, defaults to &#39;Q&#39;/&#39;Q2&#39; for q-data or &#39;CV&#39;/&#39;CV2&#39; for cv-data</span>
<span class="sd">            :type y_label: str, optional</span>

<span class="sd">            :param logscale: applying log scale to y-axis (in case of 1D plot) or color axis (in case of 2D plot), defaults to False</span>
<span class="sd">            :type logscale: bool, optional</span>

<span class="sd">            :param cmap: color map to be used, only relevant in case of 2D contourplot, defaults to pp.get_cmap(&#39;rainbow&#39;)</span>
<span class="sd">            :type cmap: color map from matplotlib, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#preprocess</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Conditional probability needs to be finished before plotting it.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slicer</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slicer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span> <span class="s1">&#39;slicer should be list or array, instead got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">slicer</span><span class="p">)</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="s1">&#39;slicer should be list of length equal to sum of number of Qs (whic is </span><span class="si">%i</span><span class="s1">) and number of CVs (which is </span><span class="si">%i</span><span class="s1">), instead got list of length </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">slicer</span><span class="p">))</span>
        <span class="c1">#read q slicer</span>
        <span class="n">iqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">qstring</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">):</span>
            <span class="n">qslicer</span> <span class="o">=</span> <span class="n">slicer</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qslicer</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">iqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iq</span><span class="p">)</span>
                <span class="n">qstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="n">iq</span><span class="p">])</span>
                <span class="n">q_label</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> [</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iq</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qslicer</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">qstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;q=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iq</span><span class="p">][</span><span class="n">qslicer</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Slicer list elements should be of type Slice or integer, instead got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">qslicer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">qstring</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">qstring</span><span class="p">)</span>
        <span class="c1">#read q slicer</span>
        <span class="n">icvs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cvstring</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cv_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">icv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncv</span><span class="p">):</span>
            <span class="n">cvslicer</span> <span class="o">=</span> <span class="n">slicer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="o">+</span><span class="n">icv</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cvslicer</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">icvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">icv</span><span class="p">)</span>
                <span class="n">cvstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="n">icv</span><span class="p">])</span>
                <span class="n">cv_label</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> [</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="n">icv</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icv</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cvslicer</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">cvstring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;cv=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icv</span><span class="p">][</span><span class="n">cvslicer</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Slicer list elements should be of type Slice or integer, instead got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">cvslicer</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="n">cvstring</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cvstring</span><span class="p">)</span>
        <span class="c1">#print(&#39;Q-slicer: &#39;, qstring)</span>
        <span class="c1">#print(&#39;CV-slicer: &#39;, cvstring)</span>

        <span class="c1">#read data </span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">obss</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()[</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lower&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;upper&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sample&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">sample</span><span class="p">()[</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">obs</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Observable </span><span class="si">%s</span><span class="s1"> can only be plotted if error is defined!&#39;</span> <span class="o">%</span><span class="n">obs</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">slicer</span><span class="p">]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="n">slicer</span><span class="p">]</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not interpret observable </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">obs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ndim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">ndim</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="s1">&#39;Various observable data has inconsistent dimensions!&#39;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">),</span> <span class="s1">&#39;Inconsistency in sliced observable data for </span><span class="si">%s</span><span class="s1"> and detected number of Qs and CVs&#39;</span> <span class="o">%</span><span class="n">obs</span>
            <span class="c1">#crop if required</span>
            <span class="k">if</span> <span class="n">croplims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xs</span><span class="p">[</span><span class="n">xs</span><span class="o">&lt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">xs</span><span class="p">[</span><span class="n">xs</span><span class="o">&gt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1">#transform to logscale if required</span>
            <span class="k">if</span> <span class="n">logscale</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
            <span class="c1">#print(&#39;Retrieved data for %s with dimensions: %s&#39; %(obs, xs.shape))</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">nsigma_conf_int</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">lower</span><span class="p">[</span><span class="n">slicer</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">croplims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lower</span><span class="p">[</span><span class="n">lower</span><span class="o">&lt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">lower</span><span class="p">[</span><span class="n">lower</span><span class="o">&gt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">upper</span><span class="p">[</span><span class="n">upper</span><span class="o">&lt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">upper</span><span class="p">[</span><span class="n">upper</span><span class="o">&gt;</span><span class="n">croplims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">logscale</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linestyles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1">#make plot</span>
        <span class="c1">#print(&#39;Making %i-dimensional plot (icvs=%i,iqs=%i)&#39; %(ndim,len(icvs),len(iqs)))</span>
        <span class="n">pp</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Inconsistency in shape of sliced q and cv data!&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">ys</span><span class="p">,</span><span class="n">label</span><span class="p">,</span><span class="n">linestyle</span><span class="p">,</span><span class="n">linewidth</span><span class="p">,</span><span class="n">color</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">,</span><span class="n">colors</span><span class="p">):</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.33</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">q_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cv_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">q_label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">q_label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cv_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">cv_label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Something went wrong in trying to determine the correct plot labels.&#39;</span><span class="p">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Conditional probability p(</span><span class="si">%s</span><span class="s1">;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">qstring</span><span class="p">,</span><span class="n">cvstring</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ylims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylims</span><span class="p">)</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">do_ij_to_xz_indexing</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">do_ij_to_xz_indexing</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">iqs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">icvs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="n">icvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">/</span><span class="n">parse_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="n">iqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">do_ij_to_xz_indexing</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Inconsistency in shape of sliced q and cv data!&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">8</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">24</span><span class="p">,</span><span class="mi">8</span><span class="o">*</span><span class="n">nrows</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">axs</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">do_ij_to_xz_indexing</span><span class="p">:</span>
                    <span class="n">contourf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span> <span class="c1">#transpose data to convert ij indexing (internal) to xy indexing (for plotting)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">contourf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">cv_label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">q_label</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> p(</span><span class="si">%s</span><span class="s1">;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">qstring</span><span class="p">,</span><span class="n">cvstring</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
                <span class="n">pp</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contourf</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">set_size_inches</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Can only plot 1D or 2D pcond data, but received </span><span class="si">%i</span><span class="s1">-d data. Make sure that the combination of qslice and cvslice results in 1 or 2 dimensional data.&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span>




<div class="viewcode-block" id="ConditionalProbability1D1D"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D">[docs]</a><span class="k">class</span> <span class="nc">ConditionalProbability1D1D</span><span class="p">(</span><span class="n">ConditionalProbability</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Routine to store and compute conditional probabilities of the form :math:`p(q_1|cv)` which allow to convert a free energy profile in terms of the collective variable :math:`cv` to a free energy profile in terms of the collective variable :math:`q_1`.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_label</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="n">cv_label</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">q_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param q_bins: np.histogram argument for defining the bins of Q samples</span>
<span class="sd">            :type q_bins: see np.histogram and np.histogram2d, optional</span>

<span class="sd">            :param cv_bins: np.histogram argument for defining the bins of CV samples</span>
<span class="sd">            :type cv_bins: see np.histogram and np.histogram2d, optional</span>

<span class="sd">            :param q_label: label for Q used for plotting/logging, defaults to &#39;Q&#39;</span>
<span class="sd">            :type q_label: str, optional</span>
<span class="sd">            </span>
<span class="sd">            :param cv_label: label for Q used for plotting/logging, defaults to &#39;CV&#39;</span>
<span class="sd">            :type cv_label: str, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ConditionalProbability</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q_labels</span><span class="o">=</span><span class="p">[</span><span class="n">q_label</span><span class="p">],</span> <span class="n">cv_labels</span><span class="o">=</span><span class="p">[</span><span class="n">cv_label</span><span class="p">],</span> <span class="n">q_units</span><span class="o">=</span><span class="p">[</span><span class="n">q_output_unit</span><span class="p">],</span> <span class="n">cv_units</span><span class="o">=</span><span class="p">[</span><span class="n">cv_output_unit</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="ConditionalProbability1D1D.process_trajectory_xyz"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.process_trajectory_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">process_trajectory_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">CV</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Included for backwards compatibility , this routine will call the more general process_trajectory routine of the parent class. WARNING: it is no longer possible to finishe automatically after processing a trajectory. Finishing must alwasy be done manually by calling the finish routine!</span>

<span class="sd">            Extract Q and CV samples from the given XYZ trajectories. These samples will later be utilized by the finish routine to construct the conditional probability. The trajectory files may also contain data from simulations that are biased in CV space (not Q space!!).</span>

<span class="sd">            :param fns: file name (or list of file names) which contain trajectories that are used to compute the conditional probability.</span>
<span class="sd">            :type fns: str or list(str)</span>

<span class="sd">            :param Q: collective variable used to compute the CV value from a trajectory file</span>
<span class="sd">            :type Q: CollectiveVariable</span>

<span class="sd">            :param CV: collective variable used to compute the CV value from a trajectory file</span>
<span class="sd">            :type CV: CollectiveVariable</span>

<span class="sd">            :param sub: python slice instance to subsample the trajectory, defaults to slice(None, None, None)</span>
<span class="sd">            :type sub: slice, optional</span>

<span class="sd">            :param verbose: set to True to increase verbosity, defaults to False</span>
<span class="sd">            :type verbose: bool, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cv_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">CV</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">q_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">Q</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_simulation</span><span class="p">([(</span><span class="n">fn</span><span class="p">,</span> <span class="n">q_reader</span> <span class="p">)],</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span> <span class="n">cv_reader</span><span class="p">)])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D1D.process_trajectory_cvs"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.process_trajectory_cvs">[docs]</a>    <span class="k">def</span> <span class="nf">process_trajectory_cvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">col_q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">col_cv</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">),</span> <span class="n">unit_q</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">unit_cv</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Included for backwards compatibility, this routine will call the more general process_trajectory routine of the parent class. WARNING: it is no longer possible to finishe automatically after processing a trajectory. Finishing must alwasy be done manually by calling the finish routine!</span>

<span class="sd">            Extract Q and CV samples from the given COLVAR trajectories. These samples will later be utilized by the finish routine to construct the conditional probability. The trajectory files may also contain data from simulations that are biased in CV space (not Q space!!). Each CV trajectory file contains rows of the form</span>

<span class="sd">                time q cv</span>

<span class="sd">            If the trajectory file contains this data in a different order, it can be accounted for using the col_xx keyword arguments.</span>

<span class="sd">            :param fns: file name (or list of file names) of colvar files with the above formatting containing the trajectory data.</span>
<span class="sd">            :type fns: str or list(str)</span>

<span class="sd">            :param col_q: column index of the collective variable Q in the given input file, defaults to 1</span>
<span class="sd">            :type col_q: int, optional</span>

<span class="sd">            :param col_cv: column index of the collective variable CV in the given input file, defaults to 2</span>
<span class="sd">            :type col_cv: int, optional</span>

<span class="sd">            :param unit_q: unit in which the q values are stored in the file, defaults to &#39;au&#39;</span>
<span class="sd">            :type unit_q: str, optional</span>

<span class="sd">            :param unit_cv: unit in which the cv values are stored in the file, defaults to &#39;au&#39;</span>
<span class="sd">            :type unit_cv: str, optional</span>
<span class="sd">            </span>
<span class="sd">            :param sub: python slice instance to subsample the trajectory, defaults to slice(None, None, None)</span>
<span class="sd">            :type sub: slice, optional</span>

<span class="sd">            :param verbose: set to True to increase verbosity, defaults to False</span>
<span class="sd">            :type verbose: bool, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">q_reader</span>  <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_q</span><span class="p">]</span> <span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_q</span><span class="p">]</span> <span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span> <span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">cv_reader</span> <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_cv</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_cv</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_simulation</span><span class="p">([(</span><span class="n">fn</span><span class="p">,</span> <span class="n">q_reader</span> <span class="p">)],</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span> <span class="n">cv_reader</span><span class="p">)])</span></div>

    <span class="k">def</span> <span class="nf">finish_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_estimate</span><span class="p">,</span> <span class="n">error_p_threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  computing Fisher matrices for each simulation&#39;</span><span class="p">)</span>
        <span class="n">Ngrid_q</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1">#extra [0] because only 1 Q and then self.q_grid=[np.ndarray(...)]</span>
        <span class="c1">#loop over each simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fisher</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">for</span> <span class="n">isim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
            <span class="c1">#compute and store contribution to fisher matrix from current simulation as well as add contribution to global fisher matrix</span>
            <span class="n">Is</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cv_index</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1">#if self.verbose: print(&#39;    for simulation %i cv[%s]=%.3f&#39; %(isim,str(cv_index),cv))</span>
                <span class="n">I</span> <span class="o">=</span> <span class="n">fisher_matrix_mle_probdens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pconds_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][:,</span><span class="n">cv_index</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">error_estimate</span><span class="p">)</span>
                <span class="n">Is</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">histnorms_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">][</span><span class="n">cv_index</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">q_corr_time_persim</span><span class="p">[</span><span class="n">isim</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fisher</span><span class="p">[:,:,</span><span class="n">cv_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span><span class="o">*</span><span class="n">I</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fishers_persim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Is</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  extracting error for conditional probability&#39;</span><span class="p">)</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">cv_index</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">[:,</span><span class="n">cv_index</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">invert_fisher_to_covariance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fisher</span><span class="p">[:,:,</span><span class="n">cv_index</span><span class="p">],</span> <span class="n">ps</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">error_p_threshold</span><span class="p">)[:</span><span class="n">Ngrid_q</span><span class="p">,:</span><span class="n">Ngrid_q</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">error_estimate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_p&#39;</span><span class="p">]:</span>
                <span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">GaussianDistribution</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">stds</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">error_estimate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_p_cov&#39;</span><span class="p">]:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">MultiGaussianDistribution</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">error_estimate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_f&#39;</span><span class="p">]:</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
                <span class="n">stds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">LogGaussianDistribution</span><span class="p">(</span><span class="o">-</span><span class="n">fs</span><span class="p">,</span> <span class="n">stds</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">error_estimate</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mle_f_cov&#39;</span><span class="p">]:</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">MultiLogGaussianDistribution</span><span class="p">(</span><span class="o">-</span><span class="n">fs</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Error estimation method </span><span class="si">%s</span><span class="s1"> not supported&#39;</span> <span class="o">%</span><span class="n">error_estimate</span><span class="p">)</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">ErrorArray</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="ConditionalProbability1D1D.average"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.average">[docs]</a>    <span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">MultiGaussianDistribution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Compute the average of Q as function of CV</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">pconds</span><span class="p">):</span>
            <span class="n">qs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,:])</span>
                <span class="n">qs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>   <span class="o">+=</span> <span class="n">q</span><span class="o">*</span><span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="n">mask</span><span class="p">]</span>
                <span class="n">norm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span>   <span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">qs</span><span class="p">[</span><span class="n">norm</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1">#normalization in case pconds would not be normalized along second axis</span>
            <span class="n">qs</span><span class="p">[</span><span class="n">norm</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">[</span><span class="n">norm</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">qs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">()</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">target_distribution</span><span class="p">,</span> <span class="n">samples_are_flattened</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BaseProfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_units</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_units</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cv_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f_label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D1D.transform"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fep</span><span class="p">,</span> <span class="n">q_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_output_class</span><span class="o">=</span><span class="n">BaseFreeEnergyProfile</span><span class="p">,</span> <span class="n">error_distribution</span><span class="o">=</span><span class="n">MultiGaussianDistribution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Transform the provided 1D FES to a different 1D FES using the current conditional probability according to the formula. </span>

<span class="sd">            .. math:: F(q) &amp;= -kT \\ln\\left(\\int p(q|v)\\cdot e^{-\\beta F(v)} dv\\right)</span>
<span class="sd">            </span>
<span class="sd">            :param fep: the input free energy profile F(cv) which will be transformed towards F(q)</span>
<span class="sd">            :type fep: BaseFreeEnergyProfile or child classes</span>

<span class="sd">            :param q_output_unit: the unit of the new collective variable Q to be used in plotting and printing, defaults to &#39;au&#39;</span>
<span class="sd">            :type q_output_unit: str, optional</span>

<span class="sd">            :param f_output_unit: the unit of the the transformed free energy profile to be used in plotting and printing of energies. By default, the f_output_unit of the given free energy profile will be used.</span>
<span class="sd">            :type f_output_unit: str, optional</span>

<span class="sd">            :param f_output_class: the class of the output free energy profile, defaults to BaseFreeEnergyProfile</span>
<span class="sd">            :type f_output_class: class, optional</span>

<span class="sd">            :param q_label: the label of the new collective variable Q to be used in plot labels. This argument is deprecated, the q_labels[0] as defined upon initializing the class instance is used by default.</span>
<span class="sd">            :type cv_label: str, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#consistency checks and initalization</span>
        <span class="n">qs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Conditional probability needs to be finished before applying at in transformations.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fep</span><span class="p">,</span> <span class="n">BaseFreeEnergyProfile</span><span class="p">),</span> <span class="s1">&#39;Input argument should be instance of (child of) BaseFreeEnergyProfile, instead received </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">fep</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">),</span> <span class="s1">&#39;Dimension of 1D CV in conditional probability inconsistent with 1D FEP&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="o">-</span><span class="n">cvs</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Values of 1D CV in conditional probability not identical to those of 1D FEP&#39;</span>
        <span class="k">if</span> <span class="n">q_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">q_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">f_output_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_output_unit</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_output_unit</span>
        <span class="c1"># Construct 1D FEP</span>
        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pconds</span><span class="p">[:,</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fep</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="n">fs</span><span class="p">[</span><span class="n">mask</span><span class="p">]),</span> <span class="n">x</span><span class="o">=</span><span class="n">cvs</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">ps</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">qs</span><span class="p">)</span>
            <span class="n">fs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">)],</span> <span class="nb">float</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">fs_new</span><span class="p">[</span><span class="n">ps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">ps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">fep</span><span class="o">.</span><span class="n">beta</span>
            <span class="k">return</span> <span class="n">fs_new</span>
        <span class="k">if</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">ncycles</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transf1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">fs</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transf1</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="o">.</span><span class="n">ncycles</span><span class="p">)</span>
            <span class="n">transf2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">pconds</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transf2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">f_output_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="n">q_output_unit</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="n">f_output_unit</span><span class="p">,</span> <span class="n">cv_label</span><span class="o">=</span><span class="n">q_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConditionalProbability1D1D.deproject"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D1D.deproject">[docs]</a>    <span class="k">def</span> <span class="nf">deproject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fep</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">q_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_output_class</span><span class="o">=</span><span class="n">FreeEnergySurface2D</span><span class="p">,</span> <span class="n">cv_label</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">q_label</span><span class="o">=</span><span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="n">error_distribution</span><span class="o">=</span><span class="n">MultiGaussianDistribution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Deproject the provided 1D FEP F(q) to a 2D FES F(q,v) using the current conditional probability according to the formula</span>

<span class="sd">            .. math:: F(q_1,q_2) &amp;= F(q_2)-kT \\ln\\left(p(q_1|q_2)\\right)</span>

<span class="sd">            :param fep: the free energy profile F(q_2) which will be transformed</span>
<span class="sd">            :type fep: (child of) BaseFreeEnergyProfile</span>

<span class="sd">            :param q_output_unit: the unit of the new additional collective variable Q to be used in plotting and printing, defaults to &#39;au&#39;</span>
<span class="sd">            :type q_output_unit: str, optional</span>

<span class="sd">            :param cv_output_unit: the unit of the original collective variable CV to be used in plotting and printing, defaults to &#39;au&#39;</span>
<span class="sd">            :type q2_output_unit: str, optional</span>

<span class="sd">            :param f_output_unit: the unit of the the transformed free energy profile to be used in plotting and printing of energies. If set to None, the f_output_unit of the given free energy profile will be use. Defaults to None</span>
<span class="sd">            :type f_output_unit: str, optional</span>

<span class="sd">            :param f_output_class: the class of the output free energy profile, defaults to FreeEnergySurface2D</span>
<span class="sd">            :type f_output_class: class, optional</span>

<span class="sd">            :param q_label: the label of the new additional collective variable Q to be used in plot labels. This argument is deprecated, the q_labels[0] as defined upon initializing the class instance is used by default.</span>
<span class="sd">            :type q_label: str, optional</span>

<span class="sd">            :param cv_label: the label of the oribinal collective variable CV to be used in plot labels. This argument is deprecated, the cv_labels[0] as defined upon initializing the class instance is used by default.</span>
<span class="sd">            :type cv_label: str, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#consistency checks and initalization</span>
        <span class="n">qs</span><span class="p">,</span> <span class="n">cvs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Conditional probability needs to be finished before applying at in transformations.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fep</span><span class="p">,</span> <span class="n">BaseFreeEnergyProfile</span><span class="p">),</span> <span class="s1">&#39;Input argument should be instance of (child of) BaseFreeEnergyProfile, instead received </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">fep</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">),</span> <span class="s1">&#39;Dimension of collective variable v in conditional probability p(q|v) inconsistent with collective variable in 1D FEP&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="o">-</span><span class="n">cvs</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Values of collective variable v in conditional probability p(q|v) not identical to those of collective variable in 1D FEP&#39;</span>
        <span class="k">if</span> <span class="n">q_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">q_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cv_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">cv_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">f_output_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_output_unit</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_output_unit</span>
        <span class="c1"># Construct 2D FES</span>
        <span class="n">kT</span> <span class="o">=</span> <span class="n">boltzmann</span><span class="o">*</span><span class="n">fep</span><span class="o">.</span><span class="n">T</span>
        <span class="k">def</span> <span class="nf">deproject</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">):</span>
            <span class="n">fs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">)],</span> <span class="nb">float</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">icv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">)):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pconds</span><span class="p">[:,</span><span class="n">icv</span><span class="p">])</span>
                <span class="n">pconds</span><span class="p">[:,</span><span class="n">icv</span><span class="p">]</span> <span class="o">/=</span> <span class="n">pconds</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="c1">#assert pcond is proparly normalized (in case it was sampled from error distribution)</span>
                <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="n">icv</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">fs_new</span><span class="p">[</span><span class="n">icv</span><span class="p">,</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="n">icv</span><span class="p">]</span> <span class="o">-</span> <span class="n">kT</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pconds</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="n">icv</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">fs_new</span>
        <span class="k">if</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="n">ncycles_default</span><span class="p">)</span>
            <span class="n">flattener</span> <span class="o">=</span> <span class="n">Flattener</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cvs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">qs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">deproject</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">deproj1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">fs</span><span class="p">:</span> <span class="n">deproject</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">deproj1</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">deproj2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">pconds</span><span class="p">:</span> <span class="n">deproject</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">)</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">deproj2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">error_distribution</span><span class="p">,</span> <span class="n">flattener</span><span class="o">=</span><span class="n">flattener</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">deproject</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">f_output_class</span><span class="p">(</span><span class="n">cvs</span><span class="p">,</span> <span class="n">qs</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">cv1_output_unit</span><span class="o">=</span><span class="n">cv_output_unit</span><span class="p">,</span> <span class="n">cv2_output_unit</span><span class="o">=</span><span class="n">q_output_unit</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="n">f_output_unit</span><span class="p">,</span> <span class="n">cv1_label</span><span class="o">=</span><span class="n">cv_label</span><span class="p">,</span> <span class="n">cv2_label</span><span class="o">=</span><span class="n">q_label</span><span class="p">)</span></div></div>




<div class="viewcode-block" id="ConditionalProbability1D2D"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D">[docs]</a><span class="k">class</span> <span class="nc">ConditionalProbability1D2D</span><span class="p">(</span><span class="n">ConditionalProbability</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Class to store and compute conditional probabilities of the form :math:`p(q_1,q_2|cv)` which can be used to transform a 1D free energy profile in terms of the collective variable :math:`cv` towards a 2D free energy surface in terms of the collective variables :math:`q_1` and :math:`q_2`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q1_label</span><span class="o">=</span><span class="s1">&#39;Q1&#39;</span><span class="p">,</span> <span class="n">q2_label</span><span class="o">=</span><span class="s1">&#39;Q2&#39;</span><span class="p">,</span> <span class="n">cv_label</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">q1_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">q2_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">cv_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            :param q1_bins: np.histogram argument for defining the bins of Q1 samples</span>
<span class="sd">            :type q1_bins: see np.histogram and np.histogram2d, optional</span>

<span class="sd">            :param q2_bins: np.histogram argument for defining the bins of Q2 samples</span>
<span class="sd">            :type q2_bins: see np.histogram and np.histogram2d, optional</span>

<span class="sd">            :param cv_bins: np.histogram argument for defining the bins of CV samples</span>
<span class="sd">            :type cv_bins: see np.histogram and np.histogram2d, optional</span>

<span class="sd">            :param q1_label: label for Q1 used for plotting/logging, defaults to &#39;Q1&#39;</span>
<span class="sd">            :type q1_label: str, optional</span>

<span class="sd">            :param q2_label: label for Q2 used for plotting/logging, defaults to &#39;Q2&#39;</span>
<span class="sd">            :type q2_label: str, optional</span>
<span class="sd">            </span>
<span class="sd">            :param cv_label: label for Q used for plotting/logging, defaults to &#39;CV&#39;</span>
<span class="sd">            :type cv_label: str, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ConditionalProbability</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q_labels</span><span class="o">=</span><span class="p">[</span><span class="n">q1_label</span><span class="p">,</span><span class="n">q2_label</span><span class="p">],</span> <span class="n">cv_labels</span><span class="o">=</span><span class="p">[</span><span class="n">cv_label</span><span class="p">],</span> <span class="n">q_units</span><span class="o">=</span><span class="p">[</span><span class="n">q1_output_unit</span><span class="p">,</span><span class="n">q2_output_unit</span><span class="p">],</span> <span class="n">cv_units</span><span class="o">=</span><span class="p">[</span><span class="n">cv_output_unit</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

<div class="viewcode-block" id="ConditionalProbability1D2D.process_trajectory_xyz"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D.process_trajectory_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">process_trajectory_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">Q1</span><span class="p">,</span> <span class="n">Q2</span><span class="p">,</span> <span class="n">CV</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Included for backwards compatibility, this routine will call the more general process_trajectory routine of the parent class.</span>

<span class="sd">            Extract Q1, Q2 and CV samples from the given XYZ trajectories. These samples will later be utilized by the finish routine to construct the conditional probability. The trajectory files may also contain data from simulations that are biased in CV space (not Q1/Q2 space!!).</span>

<span class="sd">            :param fns: file name (or list of file names) which contain trajectories that are used to compute the conditional probability.</span>
<span class="sd">            :type fns: str or list(str)</span>

<span class="sd">            :param Q1: collective variable used to compute the Q1 value from a trajectory file</span>
<span class="sd">            :type Q1: CollectiveVariable</span>

<span class="sd">            :param Q2: collective variable used to compute the Q2 value from a trajectory file</span>
<span class="sd">            :type Q2: CollectiveVariable</span>

<span class="sd">            :param CV: collective variable used to compute the CV value from a trajectory file</span>
<span class="sd">            :type CV: CollectiveVariable</span>

<span class="sd">            :param sub: python slice instance to subsample the trajectory, defaults to slice(None, None, None)</span>
<span class="sd">            :type sub: slice, optional</span>

<span class="sd">            :param finish: set to True if the given file name(s) are the only relevant trajectories and hence the conditional probability should be computed from only these trajectories. Setting it to True will trigger histogram construction and normalization. Set to False if you would like to call a process_trajectory routine again afterwards. Defaults to True</span>
<span class="sd">            :type finish: bool, optional</span>

<span class="sd">            :param verbose: set to True to increase verbosity, defaults to False</span>
<span class="sd">            :type verbose: bool, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cv_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">CV</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">q1_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">Q1</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">q2_reader</span> <span class="o">=</span> <span class="n">CVComputer</span><span class="p">([</span><span class="n">Q2</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_simulation</span><span class="p">([(</span><span class="n">fn</span><span class="p">,</span><span class="n">q1_reader</span><span class="p">),</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">q2_reader</span><span class="p">)],</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span><span class="n">cv_reader</span><span class="p">)])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D2D.process_trajectory_cvs"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D.process_trajectory_cvs">[docs]</a>    <span class="k">def</span> <span class="nf">process_trajectory_cvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fns</span><span class="p">,</span> <span class="n">col_q1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">col_q2</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">col_cv</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">unit_q1</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">unit_q2</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">unit_cv</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">sub</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Included for backwards compatibility, this routine will call the more general process_trajectory routine of the parent class.</span>

<span class="sd">            Extract Q and CV samples from the given COLVAR trajectories. These samples will later be utilized by the finish routine to construct the conditional probability. The trajectory files may also contain data from simulations that are biased in CV space (not Q space!!). Each CV trajectory file contains rows of the form</span>

<span class="sd">                time q1 q2 cv</span>

<span class="sd">            If the trajectory file contains this data in a different order, it can be accounted for using the col_xx keyword arguments.</span>

<span class="sd">            :param fns: file name (or list of file names) of colvar files with the above formatting containing the trajectory data.</span>
<span class="sd">            :type fns: str or list(str)</span>

<span class="sd">            :param col_q1: column index of the collective variable Q1 in the given input file, defaults to 1</span>
<span class="sd">            :type col_q1: int, optional</span>

<span class="sd">            :param col_q2: column index of the collective variable Q2 in the given input file, defaults to 2</span>
<span class="sd">            :type col_q2: int, optional</span>

<span class="sd">            :param col_cv: column index of the collective variable CV in the given input file, defaults to 3</span>
<span class="sd">            :type col_cv: int, optional</span>

<span class="sd">            :param unit_q1: unit in which the q1 values are stored in the file, defaults to &#39;au&#39;</span>
<span class="sd">            :type unit_q1: str, optional</span>

<span class="sd">            :param unit_q2: unit in which the q2 values are stored in the file, defaults to &#39;au&#39;</span>
<span class="sd">            :type unit_q2: str, optional</span>

<span class="sd">            :param unit_cv: unit in which the cv values are stored in the file, defaults to &#39;au&#39;</span>
<span class="sd">            :type unit_cv: str, optional</span>
<span class="sd">            </span>
<span class="sd">            :param sub: python slice instance to subsample the trajectory, defaults to slice(None, None, None)</span>
<span class="sd">            :type sub: slice, optional</span>

<span class="sd">            :param finish: set to True if the given file name(s) are the only relevant trajectories and hence the conditional probability should be computed from only these trajectories. Setting it to True will trigger histogram construction and normalization. Set to False if you would like to call a process_trajectory routine again afterwards. Defaults to True</span>
<span class="sd">            :type finish: bool, optional</span>

<span class="sd">            :param verbose: set to True to increase verbosity, defaults to False</span>
<span class="sd">            :type verbose: bool, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">q1_reader</span>  <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_q1</span><span class="p">]</span> <span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_q1</span><span class="p">]</span> <span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Q1&#39;</span> <span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">q2_reader</span>  <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_q2</span><span class="p">]</span> <span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_q2</span><span class="p">]</span> <span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Q2&#39;</span> <span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">cv_reader</span> <span class="o">=</span> <span class="n">ColVarReader</span><span class="p">([</span><span class="n">col_cv</span><span class="p">],</span> <span class="n">units</span><span class="o">=</span><span class="p">[</span><span class="n">unit_cv</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;CV&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">sub</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_simulation</span><span class="p">([(</span><span class="n">fn</span><span class="p">,</span><span class="n">q1_reader</span><span class="p">),</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">q2_reader</span><span class="p">)],</span> <span class="p">[(</span><span class="n">fn</span><span class="p">,</span><span class="n">cv_reader</span><span class="p">)])</span></div>

<div class="viewcode-block" id="ConditionalProbability1D2D.deproject"><a class="viewcode-back" href="../../../rg_thermo.html#thermolib.thermodynamics.condprob.ConditionalProbability1D2D.deproject">[docs]</a>    <span class="k">def</span> <span class="nf">deproject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fep</span><span class="p">,</span> <span class="n">q1_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">q2_output_unit</span><span class="o">=</span><span class="s1">&#39;au&#39;</span><span class="p">,</span> <span class="n">q1_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q2_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="s1">&#39;kjmol&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Transform the provided 1D FEP to a 2D FES using the current conditional probability according to the formula</span>

<span class="sd">            .. math:: F(q_1,q_2) &amp;= -kT\cdot\\ln\\left(\\int p(q_1,q_2|v)\\cdot e^{-\\beta F(v)}dv\\right)</span>

<span class="sd">            :param fep: the input free energy profile F(cv) which will be transformed towards F(q)</span>
<span class="sd">            :type fep: BaseFreeEnergyProfile or child classes</span>

<span class="sd">            :param q1_output_unit: the unit of the new collective variable Q1 to be used in plotting and printing, defaults to &#39;au&#39;</span>
<span class="sd">            :type q1_output_unit: str, optional</span>

<span class="sd">            :param q2_output_unit: the unit of the new collective variable Q2 to be used in plotting and printing, defaults to &#39;au&#39;</span>
<span class="sd">            :type q2_output_unit: str, optional</span>

<span class="sd">            :param f_output_unit: the unit of the the transformed free energy profile to be used in plotting and printing of energies. By default, the f_output_unit of the given free energy profile will be used.</span>
<span class="sd">            :type f_output_unit: str, optional</span>

<span class="sd">            :param f_output_class: the class of the output free energy profile, defaults to BaseFreeEnergyProfile</span>
<span class="sd">            :type f_output_class: class, optional</span>

<span class="sd">            :param q1_label: the label of the new collective variable Q1 to be used in plot labels. This argument is deprecated, the q_labels[0] as defined upon initializing the class instance is used by default.</span>
<span class="sd">            :type q1_label: str, optional</span>

<span class="sd">            :param q2_label: the label of the new collective variable Q2 to be used in plot labels. This argument is deprecated, the q_labels[1] as defined upon initializing the class instance is used by default.</span>
<span class="sd">            :type q2_label: str, optional</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1">#consistency checks and initalization</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finished</span><span class="p">,</span> <span class="s2">&quot;Conditional probability needs to be finished before applying at in transformations.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fep</span><span class="p">,</span> <span class="n">BaseFreeEnergyProfile</span><span class="p">),</span> <span class="s1">&#39;Input argument should be instance of (child of) BaseFreeEnergyProfile, instead received </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">fep</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;Dimension of 1D CV in conditional probability inconsistent with 1D FEP&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;Values of 1D CV in conditional probability not identical to those of 1D FEP&#39;</span>
        <span class="k">if</span> <span class="n">q1_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">q1_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">q2_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">q2_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">f_output_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">f_output_unit</span> <span class="o">=</span> <span class="n">fep</span><span class="o">.</span><span class="n">f_output_unit</span>
        <span class="c1">#construct 2D FES</span>
        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pconds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">fep</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="n">fs</span><span class="p">[</span><span class="n">mask</span><span class="p">]),</span> <span class="n">x</span><span class="o">=</span><span class="n">fep</span><span class="o">.</span><span class="n">cvs</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
            <span class="n">ps</span> <span class="o">/=</span> <span class="n">integrate2d</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">fs_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">fs_new</span><span class="p">[</span><span class="n">ps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">ps</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">fep</span><span class="o">.</span><span class="n">beta</span>
            <span class="k">return</span> <span class="n">fs_new</span>

        <span class="n">fs</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
        <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="n">ncycles_default</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">GaussianDistribution</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transf1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">fs</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pconds</span><span class="p">)</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transf1</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">error</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">propagator</span> <span class="o">=</span> <span class="n">Propagator</span><span class="p">(</span><span class="n">ncycles</span><span class="o">=</span><span class="n">ncycles_default</span><span class="p">)</span>
            <span class="n">transf2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">pconds</span><span class="p">:</span> <span class="n">transform</span><span class="p">(</span><span class="n">fep</span><span class="o">.</span><span class="n">fs</span><span class="p">,</span> <span class="n">pconds</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">transf2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">target_distribution</span><span class="o">=</span><span class="n">LogGaussianDistribution</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FreeEnergySurface2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fep</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span> <span class="n">cv1_output_unit</span><span class="o">=</span><span class="n">q1_output_unit</span><span class="p">,</span> <span class="n">cv2_output_unit</span><span class="o">=</span><span class="n">q2_output_unit</span><span class="p">,</span> <span class="n">f_output_unit</span><span class="o">=</span><span class="n">f_output_unit</span><span class="p">,</span> <span class="n">cv1_label</span><span class="o">=</span><span class="n">q1_label</span><span class="p">,</span> <span class="n">cv2_label</span><span class="o">=</span><span class="n">q2_label</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Louis Vanduyfhuys.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>